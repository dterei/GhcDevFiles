24 patches for repository http://darcs.haskell.org/ghc:

Thu Feb 10 16:45:45 PST 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: Add trust flag to packages.

Wed Feb 16 14:02:49 PST 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: Add Safe & Trustworthy pragmas
  
  These don't actually do anything for the moment except
  record in the iterface file of a module that the module
  was compiled in safe mode.

Thu Feb 17 09:00:17 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Fix spelling mistake in comment.

Tue Feb 22 16:27:14 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Fix warnings in HsImpExp.lhs

Tue Feb 22 16:28:10 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Remove unused imports

Tue Feb 22 16:28:35 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Formatting fixes in Lexer.x

Tue Feb 22 16:28:53 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Remove unused import

Mon Feb 28 10:56:48 PST 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: Add safe import flag (not functional).
  
  The safe import flag is now recognised by the lexer and parser. For
  now it doesn't have any sematics though.
  

Mon Feb 28 11:03:37 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Tiny formatting change.

Mon Feb 28 16:09:57 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Share some work in MkIface.

Tue Mar  1 14:11:55 PST 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: Record safe imports in interface files.

Tue Mar  1 14:28:44 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Formatting fixes.
  
  As I'm working through SafeHaskell I've been cleaning. (e.g death to
  tabs and trailing spaces!).

Wed Mar  2 17:03:40 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Fix small error in comment

Wed Mar  2 17:04:42 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Fix another small error in comments

Wed Mar  2 17:07:22 PST 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: Force all imports to be safe when Safe mode

Wed Mar  2 17:09:29 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Fix missing eol marker in RnSource.lhs

Thu Mar  3 14:01:29 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Formatting changes to Lexer.x

Mon Mar  7 16:41:19 PST 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: First pass at checking safe imports are valid

Mon Mar  7 16:43:29 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Trim some trailing spaces

Wed Mar  9 11:07:51 PST 2011  David Terei <davidt@scs.stanford.edu>
  * Consistent order of flag processing.
  
  Some code paths for handling pragmas would check they are valid
  and then check if any are depreciated, while others would swap these
  steps around. We now consistently check they are valid and then warn
  for depreciated.

Wed Mar 30 14:27:40 PDT 2011  David Terei <davidt@scs.stanford.edu>
  * Format wibble

Wed Mar 30 14:27:52 PDT 2011  David Terei <davidt@scs.stanford.edu>
  * Format wibble

Wed Mar 30 14:28:41 PDT 2011  David Terei <davidt@scs.stanford.edu>
  * Change GhcMake to unix file format

Tue Apr 12 10:12:40 PDT 2011  David Terei <davidt@scs.stanford.edu>
  * SafeHaskell: Disable unsafe flags in Safe mode

New patches:

[SafeHaskell: Add trust flag to packages.
David Terei <davidt@scs.stanford.edu>**20110211004545
 Ignore-this: 4a4198bb4b6784945684336d7da66c4c
] {
hunk ./libraries/bin-package-db/Distribution/InstalledPackageInfo/Binary.hs 67
   put (exposed ipi)
   put (exposedModules ipi)
   put (hiddenModules ipi)
+  put (trusted ipi)
   put (importDirs ipi)
   put (libraryDirs ipi)
   put (hsLibraries ipi)
hunk ./libraries/bin-package-db/Distribution/InstalledPackageInfo/Binary.hs 100
   exposed <- get
   exposedModules <- get
   hiddenModules <- get
+  trusted <- get
   importDirs <- get
   libraryDirs <- get
   hsLibraries <- get
hunk ./utils/ghc-pkg/Main.hs 190
   "  $p hide {pkg-id}\n" ++
   "    Hide the specified package.\n" ++
   "\n" ++
+  "  $p trust {pkg-id}\n" ++
+  "    Trust the specified package.\n" ++
+  "\n" ++
+  "  $p distrust {pkg-id}\n" ++
+  "    Distrust the specified package.\n" ++
+  "\n" ++
   "  $p list [pkg]\n" ++
   "    List registered packages in the global database, and also the\n" ++
   "    user database if --user is given. If a package name is given\n" ++
hunk ./utils/ghc-pkg/Main.hs 334
     ["hide",   pkgid_str] -> do
         pkgid <- readGlobPkgId pkgid_str
         hidePackage pkgid verbosity cli force
+    ["trust",    pkgid_str] -> do
+        pkgid <- readGlobPkgId pkgid_str
+        trustPackage pkgid verbosity cli force
+    ["distrust", pkgid_str] -> do
+        pkgid <- readGlobPkgId pkgid_str
+        distrustPackage pkgid verbosity cli force
     ["list"] -> do
         listPackages verbosity cli Nothing Nothing
     ["list", pkgid_str] ->
hunk ./utils/ghc-pkg/Main.hs 408
 -- Package databases
 
 -- Some commands operate on a single database:
---      register, unregister, expose, hide
+--      register, unregister, expose, hide, trust, distrust
 -- however these commands also check the union of the available databases
 -- in order to check consistency.  For example, register will check that
 -- dependencies exist before registering a package.
hunk ./utils/ghc-pkg/Main.hs 745
       else ioError e
 
 -- -----------------------------------------------------------------------------
--- Exposing, Hiding, Unregistering are all similar
+-- Exposing, Hiding, Trusting, Distrusting, Unregistering are all similar
 
 exposePackage :: PackageIdentifier -> Verbosity -> [Flag] -> Force -> IO ()
 exposePackage = modifyPackage (\p -> ModifyPackage p{exposed=True})
hunk ./utils/ghc-pkg/Main.hs 753
 hidePackage :: PackageIdentifier -> Verbosity -> [Flag] -> Force -> IO ()
 hidePackage = modifyPackage (\p -> ModifyPackage p{exposed=False})
 
+trustPackage :: PackageIdentifier -> Verbosity -> [Flag] -> Force -> IO ()
+trustPackage = modifyPackage (\p -> ModifyPackage p{trusted=True})
+
+distrustPackage :: PackageIdentifier -> Verbosity -> [Flag] -> Force -> IO ()
+distrustPackage = modifyPackage (\p -> ModifyPackage p{trusted=False})
+
 unregisterPackage :: PackageIdentifier -> Verbosity -> [Flag] -> Force -> IO ()
 unregisterPackage = modifyPackage RemovePackage
 
}
[SafeHaskell: Add Safe & Trustworthy pragmas
David Terei <davidt@scs.stanford.edu>**20110216220249
 Ignore-this: cea31399b56d4ecfc9adf998c4b4cd9
 
 These don't actually do anything for the moment except
 record in the iterface file of a module that the module
 was compiled in safe mode.
] {
hunk ./compiler/iface/BinIface.hs 394
 		 mi_rules     = rules,
 		 mi_orphan_hash = orphan_hash,
                  mi_vect_info = vect_info,
-		 mi_hpc       = hpc_info }) = do
+		 mi_hpc       = hpc_info,
+		 mi_trust     = trust }) = do
 	put_ bh mod
 	put_ bh is_boot
 	put_ bh iface_hash
hunk ./compiler/iface/BinIface.hs 416
 	put_ bh orphan_hash
         put_ bh vect_info
 	put_ bh hpc_info
+	put_ bh trust
 
    get bh = do
 	mod_name  <- get bh
hunk ./compiler/iface/BinIface.hs 439
 	orphan_hash <- get bh
         vect_info <- get bh
         hpc_info  <- get bh
+        trust     <- get bh
 	return (ModIface {
 		 mi_module    = mod_name,
 		 mi_boot      = is_boot,
hunk ./compiler/iface/BinIface.hs 462
 		 mi_orphan_hash = orphan_hash,
                  mi_vect_info = vect_info,
 		 mi_hpc       = hpc_info,
+		 mi_trust     = trust,
 			-- And build the cached values
 		 mi_warn_fn   = mkIfaceWarnCache warns,
 		 mi_fix_fn    = mkIfaceFixCache fixities,
hunk ./compiler/iface/BinIface.hs 1508
 	    a3 <- get bh
 	    return (IfaceVectInfo a1 a2 a3)
 
+instance Binary IfaceTrustInfo where
+    put_ bh iftrust = putByte bh $ trustInfoToNum iftrust
+    get bh = getByte bh >>= (return . numToTrustInfo)
 
hunk ./compiler/iface/LoadIface.lhs 669
 	, vcat (map ppr (mi_fam_insts iface))
 	, vcat (map ppr (mi_rules iface))
         , pprVectInfo (mi_vect_info iface)
+        , pprVectInfo (mi_vect_info iface)
 	, ppr (mi_warns iface)
hunk ./compiler/iface/LoadIface.lhs 671
+	, pprTrustInfo (mi_trust iface)
  	]
   where
     pp_boot | mi_boot iface = ptext (sLit "[boot]")
hunk ./compiler/iface/LoadIface.lhs 744
   , ptext (sLit "vectorised reused tycons:") <+> hsep (map ppr tyconsReuse)
   ]
 
+pprTrustInfo :: IfaceTrustInfo -> SDoc
+pprTrustInfo trust = ptext (sLit "trusted:") <+> ppr trust
+
 instance Outputable Warnings where
     ppr = pprWarns
 
hunk ./compiler/iface/MkIface.lhs 10
 module MkIface ( 
         mkUsedNames,
         mkDependencies,
-	mkIface, 	-- Build a ModIface from a ModGuts, 
-			-- including computing version information
+        mkIface,        -- Build a ModIface from a ModGuts, 
+                        -- including computing version information
 
         mkIfaceTc,
 
hunk ./compiler/iface/MkIface.lhs 15
-	writeIfaceFile,	-- Write the interface file
+        writeIfaceFile, -- Write the interface file
 
hunk ./compiler/iface/MkIface.lhs 17
-	checkOldIface,	-- See if recompilation is required, by
-			-- comparing version information
+        checkOldIface,  -- See if recompilation is required, by
+                        -- comparing version information
 
         tyThingToIfaceDecl -- Converting things to their Iface equivalents
  ) where
hunk ./compiler/iface/MkIface.lhs 24
 \end{code}
 
-	-----------------------------------------------
-        	Recompilation checking
-	-----------------------------------------------
+        -----------------------------------------------
+                Recompilation checking
+        -----------------------------------------------
 
 A complete description of how recompilation checking works can be
 found in the wiki commentary:
hunk ./compiler/iface/MkIface.lhs 108
 
 
 %************************************************************************
-%*				 					*
+%*                                                                      *
 \subsection{Completing an interface}
hunk ./compiler/iface/MkIface.lhs 110
-%*				 					*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/iface/MkIface.lhs 115
 mkIface :: HscEnv
-	-> Maybe Fingerprint	-- The old fingerprint, if we have it
-	-> ModDetails		-- The trimmed, tidied interface
-	-> ModGuts		-- Usages, deprecations, etc
-	-> IO (Messages,
+        -> Maybe Fingerprint    -- The old fingerprint, if we have it
+        -> ModDetails           -- The trimmed, tidied interface
+        -> ModGuts              -- Usages, deprecations, etc
+        -> IO (Messages,
                Maybe (ModIface, -- The new one
hunk ./compiler/iface/MkIface.lhs 120
-	              Bool))	-- True <=> there was an old Iface, and the
+                      Bool))    -- True <=> there was an old Iface, and the
                                 --          new one is identical, so no need
                                 --          to write it
 
hunk ./compiler/iface/MkIface.lhs 125
 mkIface hsc_env maybe_old_fingerprint mod_details
-	 ModGuts{     mg_module    = this_mod,
+         ModGuts{     mg_module    = this_mod,
 		      mg_boot      = is_boot,
 		      mg_used_names = used_names,
 		      mg_deps      = deps,
hunk ./compiler/iface/MkIface.lhs 234
 		; iface_insts = map instanceToIfaceInst insts
 		; iface_fam_insts = map famInstToIfaceFamInst fam_insts
                 ; iface_vect_info = flattenVectInfo vect_info
+                ; trust_info = (setSafeMode . safeHaskell . hsc_dflags) hsc_env
 
 	        ; intermediate_iface = ModIface { 
 			mi_module   = this_mod,
hunk ./compiler/iface/MkIface.lhs 267
 			mi_decls     = deliberatelyOmitted "decls",
 			mi_hash_fn   = deliberatelyOmitted "hash_fn",
 			mi_hpc       = isHpcUsed hpc_info,
+			mi_trust     = trust_info,
 
 			-- And build the cached values
 			mi_warn_fn = mkIfaceWarnCache warns,
hunk ./compiler/iface/MkIface.lhs 1034
 	      -> IO (RecompileRequired, Maybe ModIface)
 
 checkOldIface hsc_env mod_summary source_unchanged maybe_iface
-  = do	{ showPass (hsc_dflags hsc_env) 
-	           ("Checking old interface for " ++ 
-			showSDoc (ppr (ms_mod mod_summary))) ;
-
-	; initIfaceCheck hsc_env $
-	  check_old_iface hsc_env mod_summary source_unchanged maybe_iface
-     }
+  = do  showPass (hsc_dflags hsc_env) $
+            "Checking old interface for " ++ (showSDoc $ ppr $ ms_mod mod_summary)
+        initIfaceCheck hsc_env $
+            check_old_iface hsc_env mod_summary source_unchanged maybe_iface
 
 check_old_iface :: HscEnv -> ModSummary -> Bool -> Maybe ModIface
                 -> IfG (Bool, Maybe ModIface)
hunk ./compiler/iface/MkIface.lhs 1041
-check_old_iface hsc_env mod_summary source_unchanged maybe_iface
- =  do 	-- CHECK WHETHER THE SOURCE HAS CHANGED
-    { when (not source_unchanged)
-	   (traceHiDiffs (nest 4 (text "Source file changed or recompilation check turned off")))
-
-     -- If the source has changed and we're in interactive mode, avoid reading
-     -- an interface; just return the one we might have been supplied with.
-    ; let dflags = hsc_dflags hsc_env
-    ; if not (isObjectTarget (hscTarget dflags)) && not source_unchanged then
-         return (outOfDate, maybe_iface)
-      else
-      case maybe_iface of {
-        Just old_iface -> do -- Use the one we already have
-	  { traceIf (text "We already have the old interface for" <+> ppr (ms_mod mod_summary))
-	  ; recomp <- checkVersions hsc_env source_unchanged mod_summary old_iface
-	  ; return (recomp, Just old_iface) }
-
-      ; Nothing -> do
-
-	-- Try and read the old interface for the current module
-	-- from the .hi file left from the last time we compiled it
-    { let iface_path = msHiFilePath mod_summary
-    ; read_result <- readIface (ms_mod mod_summary) iface_path False
-    ; case read_result of {
-         Failed err -> do	-- Old interface file not found, or garbled; give up
-		{ traceIf (text "FYI: cannot read old interface file:"
-			   	 $$ nest 4 err)
-	        ; return (outOfDate, Nothing) }
-
-      ;  Succeeded iface -> do
+check_old_iface hsc_env mod_summary src_unchanged maybe_iface
+  = let src_changed = not src_unchanged
+        dflags = hsc_dflags hsc_env
+        getIface =
+             case maybe_iface of
+                 Just _  -> do
+                     traceIf (text "We already have the old interface for" <+> ppr (ms_mod mod_summary))
+                     return maybe_iface
+                 Nothing -> do
+                     let iface_path = msHiFilePath mod_summary
+                     read_result <- readIface (ms_mod mod_summary) iface_path False
+                     case read_result of
+                         Failed err -> do
+                             traceIf (text "FYI: cannont read old interface file:" $$ nest 4 err)
+                             return Nothing
+                         Succeeded iface -> do
+                             traceIf (text "Read the interface file" <+> text iface_path)
+                             return $ Just iface
 
hunk ./compiler/iface/MkIface.lhs 1060
-	-- We have got the old iface; check its versions
-    { traceIf (text "Read the interface file" <+> text iface_path)
-    ; recomp <- checkVersions hsc_env source_unchanged mod_summary iface
-    ; return (recomp, Just iface)
-    }}}}}
+    in do
+        when src_changed
+             (traceHiDiffs (nest 4 (text "Source file changed or recompilation check turned off")))
 
hunk ./compiler/iface/MkIface.lhs 1064
+         -- If the source has changed and we're in interactive mode, avoid reading
+         -- an interface; just return the one we might have been supplied with.
+        if not (isObjectTarget $ hscTarget dflags) && src_changed
+            then return (outOfDate, maybe_iface)
+            else do
+                -- Try and read the old interface for the current module
+                -- from the .hi file left from the last time we compiled it
+                maybe_iface' <- getIface
+                case maybe_iface' of
+                    Nothing -> return (outOfDate, maybe_iface')
+                    Just iface -> do
+                        -- We have got the old iface; check its versions
+                        recomp <- checkVersions hsc_env src_unchanged mod_summary iface
+                        return recomp
 \end{code}
 
 @recompileRequired@ is called from the HscMain.   It checks whether
hunk ./compiler/iface/MkIface.lhs 1091
 upToDate  = False	-- Recompile not required
 outOfDate = True	-- Recompile required
 
+-- | Check the safe haskell flags haven't changed
+--   (e.g different flag on command line now)
+checkSafeHaskell :: HscEnv -> ModIface -> Bool
+checkSafeHaskell hsc_env iface
+  = (getSafeMode $ mi_trust iface) /= (safeHaskell $ hsc_dflags hsc_env)
+
 checkVersions :: HscEnv
 	      -> Bool		-- True <=> source unchanged
               -> ModSummary
hunk ./compiler/iface/MkIface.lhs 1101
 	      -> ModIface 	-- Old interface
-	      -> IfG RecompileRequired
+	      -> IfG (RecompileRequired, Maybe ModIface)
 checkVersions hsc_env source_unchanged mod_summary iface
   | not source_unchanged
hunk ./compiler/iface/MkIface.lhs 1104
-  = return outOfDate
+  = return (outOfDate, Just iface)
   | otherwise
hunk ./compiler/iface/MkIface.lhs 1106
-  = do	{ traceHiDiffs (text "Considering whether compilation is required for" <+> 
-		        ppr (mi_module iface) <> colon)
+  = do  { traceHiDiffs (text "Considering whether compilation is required for" <+> 
+                        ppr (mi_module iface) <> colon)
 
         ; recomp <- checkDependencies hsc_env mod_summary iface
hunk ./compiler/iface/MkIface.lhs 1110
-        ; if recomp then return outOfDate else do {
+        ; if recomp then return (outOfDate, Just iface) else do {
+        ; if trust_dif then return (outOfDate, Nothing) else do {
 
hunk ./compiler/iface/MkIface.lhs 1113
-	-- Source code unchanged and no errors yet... carry on 
+        -- Source code unchanged and no errors yet... carry on 
         --
hunk ./compiler/iface/MkIface.lhs 1115
-	-- First put the dependent-module info, read from the old
-	-- interface, into the envt, so that when we look for
-	-- interfaces we look for the right one (.hi or .hi-boot)
-	-- 
-	-- It's just temporary because either the usage check will succeed 
-	-- (in which case we are done with this module) or it'll fail (in which
-	-- case we'll compile the module from scratch anyhow).
-	--	
-	-- We do this regardless of compilation mode, although in --make mode
-	-- all the dependent modules should be in the HPT already, so it's
-	-- quite redundant
-	  updateEps_ $ \eps  -> eps { eps_is_boot = mod_deps }
+        -- First put the dependent-module info, read from the old
+        -- interface, into the envt, so that when we look for
+        -- interfaces we look for the right one (.hi or .hi-boot)
+        -- 
+        -- It's just temporary because either the usage check will succeed 
+        -- (in which case we are done with this module) or it'll fail (in which
+        -- case we'll compile the module from scratch anyhow).
+        -- 
+        -- We do this regardless of compilation mode, although in --make mode
+        -- all the dependent modules should be in the HPT already, so it's
+        -- quite redundant
+  updateEps_ $ \eps  -> eps { eps_is_boot = mod_deps }
 
hunk ./compiler/iface/MkIface.lhs 1128
-	; let this_pkg = thisPackage (hsc_dflags hsc_env)
-	; checkList [checkModUsage this_pkg u | u <- mi_usages iface]
-    }}
+        ; let this_pkg = thisPackage (hsc_dflags hsc_env)
+        ; recomp <- checkList [checkModUsage this_pkg u | u <- mi_usages iface]
+        ; return (recomp, Just iface)
+    }}}
   where
hunk ./compiler/iface/MkIface.lhs 1133
-	-- This is a bit of a hack really
+    trust_dif = checkSafeHaskell hsc_env iface
+    -- This is a bit of a hack really
     mod_deps :: ModuleNameEnv (ModuleName, IsBootInterface)
     mod_deps = mkModDeps (dep_mods (mi_deps iface))
 
hunk ./compiler/main/DynFlags.hs 37
         fFlags, fLangFlags, xFlags,
         DPHBackend(..), dphPackage,
         wayNames,
+        SafeHaskellMode(..),
 
         -- ** Manipulating DynFlags
         defaultDynFlags,                -- DynFlags
hunk ./compiler/main/DynFlags.hs 297
 
 data Language = Haskell98 | Haskell2010
 
+-- | The various SafeHaskell modes
+data SafeHaskellMode
+   = Sf_None
+   | Sf_SafeImports
+   | Sf_SafeLanguage
+   | Sf_Trustworthy
+   | Sf_TrustworthyWithSafeLanguage
+   | Sf_Safe
+   deriving (Eq)
+
+instance Show SafeHaskellMode where
+    show Sf_None = "None"
+    show Sf_SafeImports = "SafeImports"
+    show Sf_SafeLanguage = "SafeLanguage"
+    show Sf_Trustworthy = "Trustworthy"
+    show Sf_TrustworthyWithSafeLanguage = "Trustworthy + SafeLanguage"
+    show Sf_Safe = "Safe"
+
 data ExtensionFlag
    = Opt_Cpp
    | Opt_OverlappingInstances
hunk ./compiler/main/DynFlags.hs 529
   flags                 :: [DynFlag],
   -- Don't change this without updating extensionFlags:
   language              :: Maybe Language,
+  -- | Safe Haskell mode
+  safeHaskell           :: SafeHaskellMode,
   -- Don't change this without updating extensionFlags:
   extensions            :: [OnOff ExtensionFlag],
   -- extensionFlags should always be equal to
hunk ./compiler/main/DynFlags.hs 774
         haddockOptions = Nothing,
         flags = defaultFlags,
         language = Nothing,
+        safeHaskell = Sf_None,
         extensions = [],
         extensionFlags = flattenExtensionFlags Nothing [],
 
hunk ./compiler/main/DynFlags.hs 882
                          extensionFlags = flattenExtensionFlags mLang oneoffs
                      }
 
+-- | Set a 'SafeHaskell' flag
+setSafeHaskell :: SafeHaskellMode -> DynP ()
+setSafeHaskell s = upd f
+    where f dfs = let sf = safeHaskell dfs
+                  in dfs {
+                         safeHaskell = combineSafeFlags sf s
+                     }
+
+-- | Combine two SafeHaskell modes correctly. Used for dealing with multiple flags.
+-- This makes SafeHaskell very much a monoid but for now I prefer this as I don't
+-- want to export this functionality from the module but do want to export the
+-- type constructors.
+combineSafeFlags :: SafeHaskellMode -> SafeHaskellMode -> SafeHaskellMode
+combineSafeFlags a b =
+    case (a,b) of
+        (Sf_None, sf) -> sf
+        (sf, Sf_None) -> sf
+
+        (Sf_SafeImports, sf) -> sf
+        (sf, Sf_SafeImports) -> sf
+
+        (Sf_SafeLanguage, Sf_Safe) -> err
+        (Sf_Safe, Sf_SafeLanguage) -> err
+
+        (Sf_SafeLanguage, Sf_Trustworthy) -> Sf_TrustworthyWithSafeLanguage
+        (Sf_Trustworthy, Sf_SafeLanguage) -> Sf_TrustworthyWithSafeLanguage
+
+        (Sf_TrustworthyWithSafeLanguage, Sf_Trustworthy)  -> Sf_TrustworthyWithSafeLanguage
+        (Sf_TrustworthyWithSafeLanguage, Sf_SafeLanguage) -> Sf_TrustworthyWithSafeLanguage
+        (Sf_Trustworthy, Sf_TrustworthyWithSafeLanguage)  -> Sf_TrustworthyWithSafeLanguage
+        (Sf_SafeLanguage, Sf_TrustworthyWithSafeLanguage) -> Sf_TrustworthyWithSafeLanguage
+
+        (Sf_Trustworthy, Sf_Safe) -> err
+        (Sf_Safe, Sf_Trustworthy) -> err
+
+        (a,b) | a == b -> a
+              | otherwise -> err
+
+    where err = ghcError (CmdLineError $ "Incompatible SafeHaskell flags! ("
+                                        ++ show a ++ "," ++ show b ++ ")")
+
 -- | Retrieve the options corresponding to a particular @opt_*@ field in the correct order
 getOpts :: DynFlags             -- ^ 'DynFlags' to retrieve the options from
         -> (DynFlags -> [a])    -- ^ Relevant record accessor: one of the @opt_*@ accessors
hunk ./compiler/main/DynFlags.hs 1426
  ++ map (mkFlag turnOn  "X"    setExtensionFlag  ) xFlags
  ++ map (mkFlag turnOff "XNo"  unSetExtensionFlag) xFlags
  ++ map (mkFlag turnOn  "X"    setLanguage) languageFlags
+ ++ map (mkFlag turnOn  "X"    setSafeHaskell) safeHaskellFlags
 
 package_flags :: [Flag (CmdLineP DynFlags)]
 package_flags = [
hunk ./compiler/main/DynFlags.hs 1606
 supportedLanguages :: [String]
 supportedLanguages = [ name | (name, _, _) <- languageFlags ]
 
+supportedLanguageOverlays :: [String]
+supportedLanguageOverlays = [ name | (name, _, _) <- safeHaskellFlags ]
+
 supportedExtensions :: [String]
 supportedExtensions = [ name' | (name, _, _) <- xFlags, name' <- [name, "No" ++ name] ]
 
hunk ./compiler/main/DynFlags.hs 1613
 supportedLanguagesAndExtensions :: [String]
-supportedLanguagesAndExtensions = supportedLanguages ++ supportedExtensions
+supportedLanguagesAndExtensions =
+    supportedLanguages ++ supportedLanguageOverlays ++ supportedExtensions
 
 -- | These -X<blah> flags cannot be reversed with -XNo<blah>
 languageFlags :: [FlagSpec Language]
hunk ./compiler/main/DynFlags.hs 1623
   ( "Haskell2010",                      Haskell2010, nop )
   ]
 
+-- | These -X<blah> flags cannot be reversed with -XNo<blah>
+-- They are used to place hard requirements on what GHC Haskell language
+-- features can be used.
+safeHaskellFlags :: [FlagSpec SafeHaskellMode]
+safeHaskellFlags = map mkF [Sf_SafeImports, Sf_SafeLanguage, Sf_Trustworthy, Sf_Safe]
+    where mkF flag = (show flag, flag, nop)
+
 -- | These -X<blah> flags can all be reversed with -XNo<blah>
 xFlags :: [FlagSpec ExtensionFlag]
 xFlags = [
hunk ./compiler/main/HscTypes.lhs 93
         VectInfo(..), IfaceVectInfo(..), noVectInfo, plusVectInfo, 
         noIfaceVectInfo,
 
+        -- * Safe Haskell information
+        IfaceTrustInfo, getSafeMode, setSafeMode, noIfaceTrustInfo,
+        trustInfoToNum, numToTrustInfo,
+
         -- * Compilation errors and warnings
         SourceError, GhcApiError, mkSrcErr, srcErrorMessages, mkApiErr,
         throwOneError, handleSourceError,
hunk ./compiler/main/HscTypes.lhs 132
 import PrelNames	( gHC_PRIM )
 import Packages hiding ( Version(..) )
 import DynFlags		( DynFlags(..), isOneShot, HscTarget (..), dopt,
-                          DynFlag(..) )
+                          DynFlag(..), SafeHaskellMode(..) )
 import DriverPhases	( HscSource(..), isHsBoot, hscSourceString, Phase )
 import BasicTypes	( IPName, defaultFixity, WarningTxt(..) )
 import OptimizationFuel	( OptFuelState )
hunk ./compiler/main/HscTypes.lhs 159
 import Data.Array       ( Array, array )
 import Data.List
 import Data.Map (Map)
+import Data.Word
 import Control.Monad    ( mplus, guard, liftM, when )
 import Exception
 
hunk ./compiler/main/HscTypes.lhs 683
 			-- isn't in decls. It's useful to know that when
 			-- seeing if we are up to date wrt. the old interface.
                         -- The 'OccName' is the parent of the name, if it has one.
-	mi_hpc    :: !AnyHpcUsage
+	mi_hpc    :: !AnyHpcUsage,
 	        -- ^ True if this program uses Hpc at any point in the program.
hunk ./compiler/main/HscTypes.lhs 685
+	mi_trust  :: !IfaceTrustInfo
+	        -- ^ Safe Haskell Trust information for this module.
      }
 
 -- | The 'ModDetails' is essentially a cache for information in the 'ModIface'
hunk ./compiler/main/HscTypes.lhs 855
 	       mi_warn_fn    = emptyIfaceWarnCache,
 	       mi_fix_fn    = emptyIfaceFixCache,
 	       mi_hash_fn   = emptyIfaceHashCache,
-	       mi_hpc       = False
+	       mi_hpc       = False,
+	       mi_trust     = noIfaceTrustInfo
     }		
 \end{code}
 
hunk ./compiler/main/HscTypes.lhs 1765
 noIfaceVectInfo = IfaceVectInfo [] [] []
 \end{code}
 
+%************************************************************************
+%*									*
+\subsection{Safe Haskell Support}
+%*									*
+%************************************************************************
+
+This stuff here is related to supporting the Safe Haskell extension,
+primarily about storing under what trust type a module has been compiled.
+
+\begin{code}
+-- | Safe Haskell information for 'ModIface'
+-- Simply a wrapper around SafeHaskellMode to sepperate iface and flags
+newtype IfaceTrustInfo = TrustInfo SafeHaskellMode
+
+getSafeMode :: IfaceTrustInfo -> SafeHaskellMode
+getSafeMode (TrustInfo x) = x
+
+setSafeMode :: SafeHaskellMode -> IfaceTrustInfo
+setSafeMode = TrustInfo
+
+noIfaceTrustInfo :: IfaceTrustInfo
+noIfaceTrustInfo = setSafeMode Sf_None
+
+trustInfoToNum :: IfaceTrustInfo -> Word8
+trustInfoToNum it
+  = case getSafeMode it of
+            Sf_None -> 0
+            Sf_SafeImports -> 1
+            Sf_SafeLanguage -> 2
+            Sf_Trustworthy -> 3
+            Sf_TrustworthyWithSafeLanguage -> 4
+            Sf_Safe -> 5
+
+numToTrustInfo :: Word8 -> IfaceTrustInfo
+numToTrustInfo 0 = setSafeMode Sf_None
+numToTrustInfo 1 = setSafeMode Sf_SafeImports
+numToTrustInfo 2 = setSafeMode Sf_SafeLanguage
+numToTrustInfo 3 = setSafeMode Sf_Trustworthy
+numToTrustInfo 4 = setSafeMode Sf_TrustworthyWithSafeLanguage
+numToTrustInfo 5 = setSafeMode Sf_Safe
+numToTrustInfo n = error $ "numToTrustInfo: bad input number! (" ++ show n ++ ")"
+
+instance Outputable IfaceTrustInfo where
+    ppr (TrustInfo Sf_None)         = ptext $ sLit "none"
+    ppr (TrustInfo Sf_SafeImports)  = ptext $ sLit "safe-imports"
+    ppr (TrustInfo Sf_SafeLanguage) = ptext $ sLit "safe-language"
+    ppr (TrustInfo Sf_Trustworthy)  = ptext $ sLit "trustworthy"
+    ppr (TrustInfo Sf_TrustworthyWithSafeLanguage)
+                                    = ptext $ sLit "trustworthy + safe-language"
+    ppr (TrustInfo Sf_Safe)         = ptext $ sLit "safe"
+\end{code}
+
 %************************************************************************
 %*									*
 \subsection{Linkable stuff}
}
[Fix spelling mistake in comment.
David Terei <davidt@scs.stanford.edu>**20110217170017
 Ignore-this: e5589bfb24ead6f5a958c52786ded9dd
] hunk ./compiler/main/HscTypes.lhs 723
 -- | A ModGuts is carried through the compiler, accumulating stuff as it goes
 -- There is only one ModGuts at any time, the one for the module
 -- being compiled right now.  Once it is compiled, a 'ModIface' and 
--- 'ModDetails' are extracted and the ModGuts is dicarded.
+-- 'ModDetails' are extracted and the ModGuts is discarded.
 data ModGuts
   = ModGuts {
         mg_module    :: !Module,         -- ^ Module being compiled
[Fix warnings in HsImpExp.lhs
David Terei <davidt@scs.stanford.edu>**20110223002714
 Ignore-this: d79493888f752920179ac31aacb2b37a
] {
hunk ./compiler/hsSyn/HsImpExp.lhs 9
 HsImpExp: Abstract syntax: imports, exports, interfaces
 
 \begin{code}
-{-# OPTIONS -fno-warn-incomplete-patterns #-}
--- The above warning supression flag is a temporary kludge.
--- While working on this module you are encouraged to remove it and fix
--- any warnings in the module. See
---     http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#Warnings
--- for details
 {-# LANGUAGE DeriveDataTypeable #-}
 
 module HsImpExp where
hunk ./compiler/hsSyn/HsImpExp.lhs 100
 ieName (IEThingAbs  n)   = n
 ieName (IEThingWith n _) = n
 ieName (IEThingAll  n)   = n
+ieName _ = panic "ieName failed pattern match!"
 
 ieNames :: IE a -> [a]
 ieNames (IEVar            n   ) = [n]
hunk ./compiler/hsSyn/HsImpExp.lhs 120
     ppr (IEThingAll	thing)	= hcat [ppr thing, text "(..)"]
     ppr (IEThingWith thing withs)
 	= ppr thing <> parens (fsep (punctuate comma (map pprHsVar withs)))
-    ppr (IEModuleContents mod)
-	= ptext (sLit "module") <+> ppr mod
+    ppr (IEModuleContents mod')
+	= ptext (sLit "module") <+> ppr mod'
     ppr (IEGroup n _)           = text ("<IEGroup: " ++ (show n) ++ ">")
     ppr (IEDoc doc)             = ppr doc
     ppr (IEDocNamed string)     = text ("<IEDocNamed: " ++ string ++ ">")
}
[Remove unused imports
David Terei <davidt@scs.stanford.edu>**20110223002810
 Ignore-this: 20d5d810d2a41669fb6d398e57a29846
] {
hunk ./compiler/main/DriverMkDepend.hs 19
 #include "HsVersions.h"
 
 import qualified GHC
--- import GHC              ( ModSummary(..), GhcMonad )
 import GhcMonad
 import HsSyn            ( ImportDecl(..) )
 import DynFlags
hunk ./compiler/main/DriverMkDepend.hs 37
 
 import Exception
 import ErrUtils
--- import MonadUtils       ( liftIO )
 
 import System.Directory
 import System.FilePath
}
[Formatting fixes in Lexer.x
David Terei <davidt@scs.stanford.edu>**20110223002835
 Ignore-this: c0f3ba687f77a02d064c64ce1439d2de
] {
hunk ./compiler/parser/Lexer.x 1857
 mkPState :: DynFlags -> StringBuffer -> SrcLoc -> PState
 mkPState flags buf loc =
   PState {
-      buffer	      = buf,
+      buffer        = buf,
       dflags        = flags,
       messages      = emptyMessages,
       last_loc      = mkSrcSpan loc loc,
hunk ./compiler/parser/Lexer.x 1875
     }
     where
       bitmap = genericsBit `setBitIf` xopt Opt_Generics flags
-	       .|. ffiBit            `setBitIf` xopt Opt_ForeignFunctionInterface flags
-	       .|. parrBit           `setBitIf` xopt Opt_ParallelArrays  flags
-	       .|. arrowsBit         `setBitIf` xopt Opt_Arrows          flags
-	       .|. thBit             `setBitIf` xopt Opt_TemplateHaskell flags
-	       .|. qqBit             `setBitIf` xopt Opt_QuasiQuotes	 flags
-	       .|. ipBit             `setBitIf` xopt Opt_ImplicitParams	 flags
-	       .|. explicitForallBit `setBitIf` xopt Opt_ExplicitForAll  flags
-	       .|. bangPatBit        `setBitIf` xopt Opt_BangPatterns flags
-	       .|. tyFamBit          `setBitIf` xopt Opt_TypeFamilies flags
-	       .|. haddockBit        `setBitIf` dopt Opt_Haddock      flags
-	       .|. magicHashBit      `setBitIf` xopt Opt_MagicHash    flags
-	       .|. kindSigsBit       `setBitIf` xopt Opt_KindSignatures flags
-	       .|. recursiveDoBit    `setBitIf` xopt Opt_RecursiveDo flags
-	       .|. recBit 	     `setBitIf` xopt Opt_DoRec  flags
-	       .|. recBit 	     `setBitIf` xopt Opt_Arrows flags
-	       .|. unicodeSyntaxBit  `setBitIf` xopt Opt_UnicodeSyntax flags
-	       .|. unboxedTuplesBit  `setBitIf` xopt Opt_UnboxedTuples flags
+               .|. ffiBit            `setBitIf` xopt Opt_ForeignFunctionInterface flags
+               .|. parrBit           `setBitIf` xopt Opt_ParallelArrays  flags
+               .|. arrowsBit         `setBitIf` xopt Opt_Arrows          flags
+               .|. thBit             `setBitIf` xopt Opt_TemplateHaskell flags
+               .|. qqBit             `setBitIf` xopt Opt_QuasiQuotes     flags
+               .|. ipBit             `setBitIf` xopt Opt_ImplicitParams  flags
+               .|. explicitForallBit `setBitIf` xopt Opt_ExplicitForAll  flags
+               .|. bangPatBit        `setBitIf` xopt Opt_BangPatterns flags
+               .|. tyFamBit          `setBitIf` xopt Opt_TypeFamilies flags
+               .|. haddockBit        `setBitIf` dopt Opt_Haddock      flags
+               .|. magicHashBit      `setBitIf` xopt Opt_MagicHash    flags
+               .|. kindSigsBit       `setBitIf` xopt Opt_KindSignatures flags
+               .|. recursiveDoBit    `setBitIf` xopt Opt_RecursiveDo flags
+               .|. recBit            `setBitIf` xopt Opt_DoRec  flags
+               .|. recBit            `setBitIf` xopt Opt_Arrows flags
+               .|. unicodeSyntaxBit  `setBitIf` xopt Opt_UnicodeSyntax flags
+               .|. unboxedTuplesBit  `setBitIf` xopt Opt_UnboxedTuples flags
                .|. datatypeContextsBit `setBitIf` xopt Opt_DatatypeContexts flags
                .|. transformComprehensionsBit `setBitIf` xopt Opt_TransformListComp flags
                .|. rawTokenStreamBit `setBitIf` dopt Opt_KeepRawTokenStream flags
hunk ./compiler/parser/Lexer.x 1901
       --
       setBitIf :: Int -> Bool -> Int
       b `setBitIf` cond | cond      = bit b
-			| otherwise = 0
+                        | otherwise = 0
 
 addWarning :: DynFlag -> SrcSpan -> SDoc -> P ()
 addWarning option srcspan warning
}
[Remove unused import
David Terei <davidt@scs.stanford.edu>**20110223002853
 Ignore-this: 394ca73c86bb95f9019a64d02f942996
] hunk ./compiler/typecheck/TcSMonad.lhs 109
 
 import TcRnTypes
 
-import Control.Monad
 import Data.IORef
 \end{code}
 
[SafeHaskell: Add safe import flag (not functional).
David Terei <davidt@scs.stanford.edu>**20110228185648
 Ignore-this: 9f804417027fa5d8d61ca2d78542848d
 
 The safe import flag is now recognised by the lexer and parser. For
 now it doesn't have any sematics though.
 
] {
hunk ./compiler/hsSyn/HsImpExp.lhs 39
       ideclName      :: Located ModuleName, -- ^ Module name.
       ideclPkgQual   :: Maybe FastString,   -- ^ Package qualifier.
       ideclSource    :: Bool,               -- ^ True <=> {-# SOURCE #-} import
+      ideclSafe      :: Bool,               -- ^ True => safe import
       ideclQualified :: Bool,               -- ^ True => qualified
       ideclAs        :: Maybe ModuleName,   -- ^ as Module
       ideclHiding    :: Maybe (Bool, [LIE name]) -- ^ (True => hiding, names)
hunk ./compiler/hsSyn/HsImpExp.lhs 48
 
 \begin{code}
 instance (Outputable name) => Outputable (ImportDecl name) where
-    ppr (ImportDecl mod pkg from qual as spec)
-      = hang (hsep [ptext (sLit "import"), ppr_imp from, 
-                    pp_qual qual, pp_pkg pkg, ppr mod, pp_as as])
+    ppr (ImportDecl mod' pkg from safe qual as spec)
+      = hang (hsep [ptext (sLit "import"), ppr_imp from, pp_safe safe,
+                    pp_qual qual, pp_pkg pkg, ppr mod', pp_as as])
 	     4 (pp_spec spec)
       where
         pp_pkg Nothing  = empty
hunk ./compiler/hsSyn/HsImpExp.lhs 59
 	pp_qual False   = empty
 	pp_qual True	= ptext (sLit "qualified")
 
+	pp_safe False   = empty
+	pp_safe True	= ptext (sLit "safe")
+
 	pp_as Nothing   = empty
 	pp_as (Just a)  = ptext (sLit "as") <+> ppr a
 
hunk ./compiler/iface/MkIface.lhs 1161
    orM = foldr f (return False)
     where f m rest = do b <- m; if b then return True else rest
 
-   dep_missing (L _ (ImportDecl (L _ mod) pkg _ _ _ _)) = do
+   dep_missing (L _ (ImportDecl (L _ mod) pkg _ _ _ _ _)) = do
      find_res <- liftIO $ findImportedModule hsc_env mod pkg
      case find_res of
         Found _ mod
hunk ./compiler/main/DynFlags.hs 38
         DPHBackend(..), dphPackage,
         wayNames,
         SafeHaskellMode(..),
+        safeHaskellOn,
 
         -- ** Manipulating DynFlags
         defaultDynFlags,                -- DynFlags
hunk ./compiler/main/DynFlags.hs 874
       in dfs { extensions = onoffs,
                extensionFlags = flattenExtensionFlags (language dfs) onoffs }
 
+-- | Set the Haskell language standard to use
 setLanguage :: Language -> DynP ()
 setLanguage l = upd f
     where f dfs = let mLang = Just l
hunk ./compiler/main/DynFlags.hs 884
                          extensionFlags = flattenExtensionFlags mLang oneoffs
                      }
 
+-- | Test if SafeHaskell is on in some form
+safeHaskellOn :: DynFlags -> Bool
+safeHaskellOn dflags = safeHaskell dflags /= Sf_None
+
 -- | Set a 'SafeHaskell' flag
 setSafeHaskell :: SafeHaskellMode -> DynP ()
 setSafeHaskell s = upd f
hunk ./compiler/main/HeaderInfo.hs 101
   | otherwise = [preludeImportDecl]
   where
       explicit_prelude_import
-       = notNull [ () | L _ (ImportDecl mod Nothing _ _ _ _) <- import_decls,
+       = notNull [ () | L _ (ImportDecl mod Nothing _ _ _ _ _) <- import_decls,
 	           unLoc mod == pRELUDE_NAME ]
 
       preludeImportDecl :: LImportDecl RdrName
hunk ./compiler/main/HeaderInfo.hs 110
 	  ImportDecl (L loc pRELUDE_NAME)
                Nothing {- no specific package -}
 	       False {- Not a boot interface -}
+	       False {- Not a safe interface -}
 	       False	{- Not qualified -}
 	       Nothing	{- No "as" -}
 	       Nothing	{- No import list -}
hunk ./compiler/main/HscStats.lhs 35
 	       [("ExportAll        ", export_all), -- 1 if no export list
 		("ExportDecls      ", export_ds),
 		("ExportModules    ", export_ms),
-		("Imports          ", import_no),
-		("  ImpQual        ", import_qual),
-		("  ImpAs          ", import_as),
-		("  ImpAll         ", import_all),
-		("  ImpPartial     ", import_partial),
-		("  ImpHiding      ", import_hiding),
+		("Imports          ", imp_no),
+		("  ImpSafe        ", imp_safe),
+		("  ImpQual        ", imp_qual),
+		("  ImpAs          ", imp_as),
+		("  ImpAll         ", imp_all),
+		("  ImpPartial     ", imp_partial),
+		("  ImpHiding      ", imp_hiding),
 		("FixityDecls      ", fixity_sigs),
 		("DefaultDecls     ", default_ds),
 	      	("TypeDecls        ", type_ds),
hunk ./compiler/main/HscStats.lhs 102
     (val_bind_ds, fn_bind_ds)
 	= foldr add2 (0,0) (map count_bind val_decls)
 
-    (import_no, import_qual, import_as, import_all, import_partial, import_hiding)
-	= foldr add6 (0,0,0,0,0,0) (map import_info imports)
+    (imp_no, imp_safe, imp_qual, imp_as, imp_all, imp_partial, imp_hiding)
+	= foldr add7 (0,0,0,0,0,0,0) (map import_info imports)
     (data_constrs, data_derivs)
 	= foldr add2 (0,0) (map data_info tycl_decls)
     (class_method_ds, default_method_ds)
hunk ./compiler/main/HscStats.lhs 124
     sig_info (InlineSig _ _)    = (0,0,0,1)
     sig_info _                  = (0,0,0,0)
 
-    import_info (L _ (ImportDecl _ _ _ qual as spec))
-	= add6 (1, qual_info qual, as_info as, 0,0,0) (spec_info spec)
+    import_info (L _ (ImportDecl _ _ _ safe qual as spec))
+	= add7 (1, safe_info safe, qual_info qual, as_info as, 0,0,0) (spec_info spec)
+    safe_info = qual_info
     qual_info False  = 0
     qual_info True   = 1
     as_info Nothing  = 0
hunk ./compiler/main/HscStats.lhs 131
     as_info (Just _) = 1
-    spec_info Nothing 	        = (0,0,0,1,0,0)
-    spec_info (Just (False, _)) = (0,0,0,0,1,0)
-    spec_info (Just (True, _))  = (0,0,0,0,0,1)
+    spec_info Nothing 	        = (0,0,0,0,1,0,0)
+    spec_info (Just (False, _)) = (0,0,0,0,0,1,0)
+    spec_info (Just (True, _))  = (0,0,0,0,0,0,1)
 
     data_info (TyData {tcdCons = cs, tcdDerivs = derivs})
 	= (length cs, case derivs of Nothing -> 0
hunk ./compiler/main/HscStats.lhs 164
     add2  :: (Int,Int) -> (Int,Int) -> (Int, Int)
     add4  :: (Int,Int,Int,Int) -> (Int,Int,Int,Int) -> (Int, Int, Int, Int)
     add5  :: (Int,Int,Int,Int,Int) -> (Int,Int,Int,Int,Int) -> (Int, Int, Int, Int, Int)
-    add6  :: (Int,Int,Int,Int,Int,Int) -> (Int,Int,Int,Int,Int,Int) -> (Int, Int, Int, Int, Int, Int)
+    add7  :: (Int,Int,Int,Int,Int,Int,Int) -> (Int,Int,Int,Int,Int,Int,Int) -> (Int, Int, Int, Int, Int, Int, Int)
 
     addpr (x,y) = x+y
     add2 (x1,x2) (y1,y2) = (x1+y1,x2+y2)
hunk ./compiler/main/HscStats.lhs 170
     add4 (x1,x2,x3,x4) (y1,y2,y3,y4) = (x1+y1,x2+y2,x3+y3,x4+y4)
     add5 (x1,x2,x3,x4,x5) (y1,y2,y3,y4,y5) = (x1+y1,x2+y2,x3+y3,x4+y4,x5+y5)
-    add6 (x1,x2,x3,x4,x5,x6) (y1,y2,y3,y4,y5,y6) = (x1+y1,x2+y2,x3+y3,x4+y4,x5+y5,x6+y6)
+    add7 (x1,x2,x3,x4,x5,x6,x7) (y1,y2,y3,y4,y5,y6,y7) = (x1+y1,x2+y2,x3+y3,x4+y4,x5+y5,x6+y6,x7+y7)
 \end{code}
 
 
hunk ./compiler/parser/Lexer.x 665
 	( "export",	ITexport,	 bit ffiBit),
 	( "label",	ITlabel,	 bit ffiBit),
 	( "dynamic",	ITdynamic,	 bit ffiBit),
-	( "safe",	ITsafe,		 bit ffiBit),
+	( "safe",	ITsafe,		 bit ffiBit .|. bit safeHaskellBit),
 	( "threadsafe",	ITthreadsafe,	 bit ffiBit),  -- ToDo: remove
 	( "interruptible", ITinterruptible, bit ffiBit),
 	( "unsafe",	ITunsafe,	 bit ffiBit),
hunk ./compiler/parser/Lexer.x 1801
 relaxedLayoutBit = 24
 nondecreasingIndentationBit :: Int
 nondecreasingIndentationBit = 25
+safeHaskellBit :: Int
+safeHaskellBit = 26
 
 always :: Int -> Bool
 always           _     = True
hunk ./compiler/parser/Lexer.x 1900
                .|. alternativeLayoutRuleBit `setBitIf` xopt Opt_AlternativeLayoutRule flags
                .|. relaxedLayoutBit `setBitIf` xopt Opt_RelaxedLayout flags
                .|. nondecreasingIndentationBit `setBitIf` xopt Opt_NondecreasingIndentation flags
+               .|. safeHaskellBit    `setBitIf` safeHaskellOn flags
       --
       setBitIf :: Int -> Bool -> Int
       b `setBitIf` cond | cond      = bit b
hunk ./compiler/parser/Parser.y.pp 502
 	| {- empty -}				{ [] }
 
 importdecl :: { LImportDecl RdrName }
-	: 'import' maybe_src optqualified maybe_pkg modid maybeas maybeimpspec 
-		{ L (comb4 $1 $5 $6 $7) (ImportDecl $5 $4 $2 $3 (unLoc $6) (unLoc $7)) }
+	: 'import' maybe_src maybe_safe optqualified maybe_pkg modid maybeas maybeimpspec 
+		{ L (comb4 $1 $6 $7 $8) (ImportDecl $6 $5 $2 $3 $4 (unLoc $7) (unLoc $8)) }
 
 maybe_src :: { IsBootInterface }
 	: '{-# SOURCE' '#-}'			{ True }
hunk ./compiler/parser/Parser.y.pp 509
 	| {- empty -}				{ False }
 
+maybe_safe :: { Bool }
+	: 'safe'				{ True }
+	| {- empty -}				{ False }
+
 maybe_pkg :: { Maybe FastString }
         : STRING                                { Just (getSTRING $1) }
         | {- empty -}                           { Nothing }
hunk ./compiler/rename/RnNames.lhs 68
          implicit_prelude <- xoptM Opt_ImplicitPrelude
          let prel_imports       = mkPrelImports (moduleName this_mod) implicit_prelude imports
              (source, ordinary) = partition is_source_import imports
-             is_source_import (L _ (ImportDecl _ _ is_boot _ _ _)) = is_boot
+             is_source_import (L _ (ImportDecl _ _ is_boot _ _ _ _)) = is_boot
 
          ifDOptM Opt_WarnImplicitPrelude (
             when (notNull prel_imports) $ addWarn (implicitPreludeWarn)
hunk ./compiler/rename/RnNames.lhs 97
 
 rnImportDecl this_mod implicit_prelude
              (L loc (ImportDecl { ideclName = loc_imp_mod_name, ideclPkgQual = mb_pkg
-                                , ideclSource = want_boot, ideclQualified = qual_only
+                                , ideclSource = want_boot, ideclSafe = mod_safe
+                                , ideclQualified = qual_only
                                 , ideclAs = as_mod, ideclHiding = imp_details }))
   = setSrcSpan loc $ do
 
hunk ./compiler/rename/RnNames.lhs 236
           _           -> return ()
      )
 
-    let new_imp_decl = L loc (ImportDecl loc_imp_mod_name mb_pkg want_boot
+    let new_imp_decl = L loc (ImportDecl loc_imp_mod_name mb_pkg want_boot mod_safe
                                          qual_only as_mod new_imp_details)
 
     return (new_imp_decl, gbl_env, imports, mi_hpc iface)
}
[Tiny formatting change.
David Terei <davidt@scs.stanford.edu>**20110228190337
 Ignore-this: 8bb9c40fb6930b237339d65a3b3aa4ef
] hunk ./compiler/typecheck/TcRnTypes.lhs 641
   (ImportAvails { imp_mods = mods2,
 		  imp_dep_mods = dmods2, imp_dep_pkgs = dpkgs2,
                   imp_orphs = orphs2, imp_finsts = finsts2 })
-  = ImportAvails { imp_mods     = plusModuleEnv_C (++) mods1 mods2,	
+  = ImportAvails { imp_mods     = plusModuleEnv_C (++) mods1 mods2,
 		   imp_dep_mods = plusUFM_C plus_mod_dep dmods1 dmods2,	
 		   imp_dep_pkgs = dpkgs1 `unionLists` dpkgs2,
 		   imp_orphs    = orphs1 `unionLists` orphs2,
[Share some work in MkIface.
David Terei <davidt@scs.stanford.edu>**20110301000957
 Ignore-this: c41f6dd62e32b7cc8cb85bf79e593858
] hunk ./compiler/iface/MkIface.lhs 923
                 Nothing -> pprPanic "mkUsage" (ppr mod <+> ppr occ <+> ppr used_names)
                 Just r  -> r
 
-        depend_on_exports mod = 
-           case lookupModuleEnv direct_imports mod of
-    	        Just _ -> True
-                  -- Even if we used 'import M ()', we have to register a
-                  -- usage on the export list because we are sensitive to
-                  -- changes in orphan instances/rules.
-	    	Nothing -> False
-                  -- In GHC 6.8.x the above line read "True", and in
-                  -- fact it recorded a dependency on *all* the
-                  -- modules underneath in the dependency tree.  This
-                  -- happens to make orphans work right, but is too
-                  -- expensive: it'll read too many interface files.
-                  -- The 'isNothing maybe_iface' check above saved us
-                  -- from generating many of these usages (at least in
-                  -- one-shot mode), but that's even more bogus!
+        depend_on_exports = is_direct_import
+        {- True
+              Even if we used 'import M ()', we have to register a
+              usage on the export list because we are sensitive to
+              changes in orphan instances/rules.
+           False
+              In GHC 6.8.x we always returned true, and in
+              fact it recorded a dependency on *all* the
+              modules underneath in the dependency tree.  This
+              happens to make orphans work right, but is too
+              expensive: it'll read too many interface files.
+              The 'isNothing maybe_iface' check above saved us
+              from generating many of these usages (at least in
+              one-shot mode), but that's even more bogus!
+        -}
 \end{code}
 
 \begin{code}
[SafeHaskell: Record safe imports in interface files.
David Terei <davidt@scs.stanford.edu>**20110301221155
 Ignore-this: 2095cef9c3ddfd67ea0f40b2ed383a16
] {
hunk ./compiler/iface/BinIface.hs 515
         putByte bh 0
 	put_ bh (usg_mod usg)
 	put_ bh (usg_mod_hash usg)
+	put_ bh (usg_safe     usg)
     put_ bh usg@UsageHomeModule{} = do 
         putByte bh 1
 	put_ bh (usg_mod_name usg)
hunk ./compiler/iface/BinIface.hs 522
 	put_ bh (usg_mod_hash usg)
 	put_ bh (usg_exports  usg)
 	put_ bh (usg_entities usg)
+	put_ bh (usg_safe     usg)
 
     get bh = do
         h <- getByte bh
hunk ./compiler/iface/BinIface.hs 530
           0 -> do
             nm    <- get bh
             mod   <- get bh
-            return UsagePackageModule { usg_mod = nm, usg_mod_hash = mod }
+            safe  <- get bh
+            return UsagePackageModule { usg_mod = nm, usg_mod_hash = mod, usg_safe = safe }
           _ -> do
             nm    <- get bh
             mod   <- get bh
hunk ./compiler/iface/BinIface.hs 537
             exps  <- get bh
             ents  <- get bh
+            safe  <- get bh
             return UsageHomeModule { usg_mod_name = nm, usg_mod_hash = mod,
hunk ./compiler/iface/BinIface.hs 539
-                            usg_exports = exps, usg_entities = ents }
+                     usg_exports = exps, usg_entities = ents, usg_safe = safe }
 
 instance Binary Warnings where
     put_ bh NoWarnings     = putByte bh 0
hunk ./compiler/iface/LoadIface.lhs 700
 
 pprUsage :: Usage -> SDoc
 pprUsage usage@UsagePackageModule{}
-  = hsep [ptext (sLit "import"), ppr (usg_mod usage), 
-	  ppr (usg_mod_hash usage)]
+  = pprUsageImport usage usg_mod
 pprUsage usage@UsageHomeModule{}
hunk ./compiler/iface/LoadIface.lhs 702
-  = hsep [ptext (sLit "import"), ppr (usg_mod_name usage), 
-	  ppr (usg_mod_hash usage)] $$
+  = pprUsageImport usage usg_mod_name $$
     nest 2 (
 	maybe empty (\v -> text "exports: " <> ppr v) (usg_exports usage) $$
         vcat [ ppr n <+> ppr v | (n,v) <- usg_entities usage ]
hunk ./compiler/iface/LoadIface.lhs 708
         )
 
+pprUsageImport :: Outputable a => Usage -> (Usage -> a) -> SDoc
+pprUsageImport usage usg_mod'
+  = hsep [ptext (sLit "import"), safe, ppr (usg_mod' usage),
+                       ppr (usg_mod_hash usage)]
+    where
+        safe | usg_safe usage = ptext $ sLit "safe"
+             | otherwise      = ptext $ sLit " -/ "
+
 pprDeps :: Dependencies -> SDoc
 pprDeps (Deps { dep_mods = mods, dep_pkgs = pkgs, dep_orphs = orphs,
 		dep_finsts = finsts })
hunk ./compiler/iface/MkIface.lhs 876
 
       | modulePackageId mod /= this_pkg
       = Just UsagePackageModule{ usg_mod      = mod,
-                                 usg_mod_hash = mod_hash }
+                                 usg_mod_hash = mod_hash,
+                                 usg_safe     = imp_safe }
         -- for package modules, we record the module hash only
 
       | (null used_occs
hunk ./compiler/iface/MkIface.lhs 892
       | otherwise	
       = Just UsageHomeModule { 
                       usg_mod_name = moduleName mod,
-    	  	      usg_mod_hash = mod_hash,
-    		      usg_exports  = export_hash,
-    		      usg_entities = Map.toList ent_hashs }
+                      usg_mod_hash = mod_hash,
+                      usg_exports  = export_hash,
+                      usg_entities = Map.toList ent_hashs,
+                      usg_safe     = imp_safe }
       where
hunk ./compiler/iface/MkIface.lhs 897
-	maybe_iface  = lookupIfaceByModule dflags hpt pit mod
-		-- In one-shot mode, the interfaces for home-package 
-		-- modules accumulate in the PIT not HPT.  Sigh.
-
-        is_direct_import = mod `elemModuleEnv` direct_imports
+        maybe_iface  = lookupIfaceByModule dflags hpt pit mod
+                -- In one-shot mode, the interfaces for home-package
+                -- modules accumulate in the PIT not HPT.  Sigh.
 
         Just iface   = maybe_iface
 	finsts_mod   = mi_finsts    iface
hunk ./compiler/iface/MkIface.lhs 905
         hash_env     = mi_hash_fn   iface
         mod_hash     = mi_mod_hash  iface
-        export_hash | depend_on_exports mod = Just (mi_exp_hash iface)
-    		    | otherwise 	    = Nothing
+        export_hash | depend_on_exports = Just (mi_exp_hash iface)
+                    | otherwise         = Nothing
+
+        (is_direct_import, imp_safe)
+            = case lookupModuleEnv direct_imports mod of
+                Just ((_,_,_,safe):xs) -> (True, safe)
+                Just _                 -> pprPanic "mkUsage: empty direct import" empty
+                Nothing                -> (False, False)
     
         used_occs = lookupModuleEnv ent_map mod `orElse` []
 
hunk ./compiler/main/HscTypes.lhs 95
 
         -- * Safe Haskell information
         IfaceTrustInfo, getSafeMode, setSafeMode, noIfaceTrustInfo,
-        trustInfoToNum, numToTrustInfo,
+        trustInfoToNum, numToTrustInfo, IsSafeImport,
 
         -- * Compilation errors and warnings
         SourceError, GhcApiError, mkSrcErr, srcErrorMessages, mkApiErr,
hunk ./compiler/main/HscTypes.lhs 716
                              } 
 
 -- | Records the modules directly imported by a module for extracting e.g. usage information
-type ImportedMods = ModuleEnv [(ModuleName, Bool, SrcSpan)]
+type ImportedMods = ModuleEnv [(ModuleName, Bool, SrcSpan, IsSafeImport)]
 -- TODO: we are not actually using the codomain of this type at all, so it can be
 -- replaced with ModuleEnv ()
 
hunk ./compiler/main/HscTypes.lhs 1430
   = UsagePackageModule {
         usg_mod      :: Module,
            -- ^ External package module depended on
-        usg_mod_hash :: Fingerprint
+        usg_mod_hash :: Fingerprint,
+	    -- ^ Cached module fingerprint
+        usg_safe :: IsSafeImport
+            -- ^ Was this module imported as a safe import
     }                                           -- ^ Module from another package
   | UsageHomeModule {
         usg_mod_name :: ModuleName,
hunk ./compiler/main/HscTypes.lhs 1447
 	usg_exports  :: Maybe Fingerprint
             -- ^ Fingerprint for the export list we used to depend on this module,
             -- if we depend on the export list
+        usg_safe :: IsSafeImport
+            -- ^ Was this module imported as a safe import
     }                                           -- ^ Module from the current package
     deriving( Eq )
 	-- The export list field is (Just v) if we depend on the export list:
hunk ./compiler/main/HscTypes.lhs 1780
 primarily about storing under what trust type a module has been compiled.
 
 \begin{code}
+-- | Is an import a safe import?
+type IsSafeImport = Bool
+
 -- | Safe Haskell information for 'ModIface'
 -- Simply a wrapper around SafeHaskellMode to sepperate iface and flags
 newtype IfaceTrustInfo = TrustInfo SafeHaskellMode
hunk ./compiler/rename/RnNames.lhs 222
                         _                    -> False
 
         imports   = ImportAvails {
-                        imp_mods     = unitModuleEnv imp_mod [(qual_mod_name, import_all, loc)],
+                        imp_mods     = unitModuleEnv imp_mod [(qual_mod_name, import_all, loc, mod_safe)],
                         imp_orphs    = orphans,
                         imp_finsts   = finsts,
                         imp_dep_mods = mkModDeps dependent_mods,
hunk ./compiler/rename/RnNames.lhs 910
 
     imported_modules = [ qual_name
                        | xs <- moduleEnvElts $ imp_mods imports,
-                         (qual_name, _, _) <- xs ]
+                         (qual_name, _, _, _) <- xs ]
 
     exports_from_item :: ExportAccum -> LIE RdrName -> RnM ExportAccum
     exports_from_item acc@(ie_names, occs, exports)
hunk ./compiler/typecheck/TcRnMonad.lhs 87
              maybe_rn_syntax :: forall a. a -> Maybe a ;
              maybe_rn_syntax empty_val
 		| keep_rn_syntax = Just empty_val
-		| otherwise	 = Nothing ;
-			
+		| otherwise      = Nothing ;
+
 	     gbl_env = TcGblEnv {
 		tcg_mod       = mod,
 		tcg_src	      = hsc_src,
hunk ./compiler/typecheck/TcRnTypes.lhs 569
 --
 data ImportAvails 
    = ImportAvails {
-	imp_mods :: ModuleEnv [(ModuleName, Bool, SrcSpan)],
+	imp_mods :: ImportedMods,
+	  --      = ModuleEnv [(ModuleName, Bool, SrcSpan, Bool)],
           -- ^ Domain is all directly-imported modules
           -- The 'ModuleName' is what the module was imported as, e.g. in
           -- @
}
[Formatting fixes.
David Terei <davidt@scs.stanford.edu>**20110301222844
 Ignore-this: f36a27308b9aff5c32eed04c2f2a7be1
 
 As I'm working through SafeHaskell I've been cleaning. (e.g death to
 tabs and trailing spaces!).
] {
hunk ./compiler/iface/BinIface.hs 1
-
 {-# OPTIONS_GHC -O #-}
 -- We always optimise this, otherwise performance of a non-optimised
 -- compiler is severely affected
hunk ./compiler/iface/BinIface.hs 131
         -- Initialise the user-data field of bh
   ud <- newReadState dict
   bh <- return (setUserData bh ud)
-        
+
   symtab_p <- Binary.get bh     -- Get the symtab ptr
   data_p <- tellBin bh          -- Remember where we are now
   seekBin bh symtab_p
hunk ./compiler/iface/BinIface.hs 160
   let way_descr = getWayDescr dflags
   put_  bh way_descr
 
-	-- Remember where the dictionary pointer will go
+        -- Remember where the dictionary pointer will go
   dict_p_p <- tellBin bh
hunk ./compiler/iface/BinIface.hs 162
-  put_ bh dict_p_p	-- Placeholder for ptr to dictionary
+  put_ bh dict_p_p      -- Placeholder for ptr to dictionary
 
         -- Remember where the symbol table pointer will go
   symtab_p_p <- tellBin bh
hunk ./compiler/iface/BinIface.hs 168
   put_ bh symtab_p_p
 
-	-- Make some intial state
+        -- Make some intial state
   symtab_next <- newFastMutInt
   writeFastMutInt symtab_next 0
   symtab_map <- newIORef emptyUFM
hunk ./compiler/iface/BinIface.hs 183
                       bin_dict_map  = dict_map_ref }
   ud <- newWriteState (putName bin_symtab) (putFastString bin_dict)
 
-	-- Put the main thing, 
+        -- Put the main thing,
   bh <- return $ setUserData bh ud
   put_ bh mod_iface
 
hunk ./compiler/iface/BinIface.hs 187
-	-- Write the symtab pointer at the fornt of the file
-  symtab_p <- tellBin bh	        -- This is where the symtab will start
-  putAt bh symtab_p_p symtab_p	-- Fill in the placeholder
-  seekBin bh symtab_p		-- Seek back to the end of the file
+        -- Write the symtab pointer at the fornt of the file
+  symtab_p <- tellBin bh                -- This is where the symtab will start
+  putAt bh symtab_p_p symtab_p  -- Fill in the placeholder
+  seekBin bh symtab_p           -- Seek back to the end of the file
 
         -- Write the symbol table itself
   symtab_next <- readFastMutInt symtab_next
hunk ./compiler/iface/BinIface.hs 196
   symtab_map  <- readIORef symtab_map
   putSymbolTable bh symtab_next symtab_map
-  debugTraceMsg dflags 3 (text "writeBinIface:" <+> int symtab_next 
+  debugTraceMsg dflags 3 (text "writeBinIface:" <+> int symtab_next
                                 <+> text "Names")
 
         -- NB. write the dictionary after the symbol table, because
hunk ./compiler/iface/BinIface.hs 202
         -- writing the symbol table may create more dictionary entries.
 
-	-- Write the dictionary pointer at the fornt of the file
-  dict_p <- tellBin bh	        -- This is where the dictionary will start
-  putAt bh dict_p_p dict_p	-- Fill in the placeholder
-  seekBin bh dict_p		-- Seek back to the end of the file
+        -- Write the dictionary pointer at the fornt of the file
+  dict_p <- tellBin bh          -- This is where the dictionary will start
+  putAt bh dict_p_p dict_p      -- Fill in the placeholder
+  seekBin bh dict_p             -- Seek back to the end of the file
 
hunk ./compiler/iface/BinIface.hs 207
-	-- Write the dictionary itself
+        -- Write the dictionary itself
   dict_next <- readFastMutInt dict_next_ref
   dict_map  <- readIORef dict_map_ref
   putDictionary bh dict_next dict_map
hunk ./compiler/iface/BinIface.hs 214
   debugTraceMsg dflags 3 (text "writeBinIface:" <+> int dict_next
                                  <+> text "dict entries")
 
-	-- And send the result to the file
+        -- And send the result to the file
   writeBinMem bh hi_path
 
 initBinMemSize :: Int
hunk ./compiler/iface/BinIface.hs 229
 #elif WORD_SIZE_IN_BITS == 64
 binaryInterfaceMagic = 0x1face64
 #endif
-  
+
 -- -----------------------------------------------------------------------------
 -- The symbol table
 
hunk ./compiler/iface/BinIface.hs 247
   update_namecache $ \namecache ->
     let
         arr = listArray (0,sz-1) names
-        (namecache', names) =    
+        (namecache', names) =
                 mapAccumR (fromOnDiskName arr) namecache od_names
     in (namecache', arr)
 
hunk ./compiler/iface/BinIface.hs 281
 
 
 putName :: BinSymbolTable -> BinHandle -> Name -> IO ()
-putName BinSymbolTable{ 
+putName BinSymbolTable{
             bin_symtab_map = symtab_map_ref,
             bin_symtab_next = symtab_next }    bh name
   = do
hunk ./compiler/iface/BinIface.hs 374
 
 instance Binary ModIface where
    put_ bh (ModIface {
-		 mi_module    = mod,
-		 mi_boot      = is_boot,
-		 mi_iface_hash= iface_hash,
-		 mi_mod_hash  = mod_hash,
-		 mi_orphan    = orphan,
-		 mi_finsts    = hasFamInsts,
-		 mi_deps      = deps,
-		 mi_usages    = usages,
-		 mi_exports   = exports,
-		 mi_exp_hash  = exp_hash,
-		 mi_fixities  = fixities,
-		 mi_warns     = warns,
-		 mi_anns      = anns,
-		 mi_decls     = decls,
-		 mi_insts     = insts,
-		 mi_fam_insts = fam_insts,
-		 mi_rules     = rules,
-		 mi_orphan_hash = orphan_hash,
+                 mi_module    = mod,
+                 mi_boot      = is_boot,
+                 mi_iface_hash= iface_hash,
+                 mi_mod_hash  = mod_hash,
+                 mi_orphan    = orphan,
+                 mi_finsts    = hasFamInsts,
+                 mi_deps      = deps,
+                 mi_usages    = usages,
+                 mi_exports   = exports,
+                 mi_exp_hash  = exp_hash,
+                 mi_fixities  = fixities,
+                 mi_warns     = warns,
+                 mi_anns      = anns,
+                 mi_decls     = decls,
+                 mi_insts     = insts,
+                 mi_fam_insts = fam_insts,
+                 mi_rules     = rules,
+                 mi_orphan_hash = orphan_hash,
                  mi_vect_info = vect_info,
hunk ./compiler/iface/BinIface.hs 393
-		 mi_hpc       = hpc_info,
-		 mi_trust     = trust }) = do
-	put_ bh mod
-	put_ bh is_boot
-	put_ bh iface_hash
-	put_ bh mod_hash
-	put_ bh orphan
-	put_ bh hasFamInsts
-	lazyPut bh deps
-	lazyPut bh usages
-	put_ bh exports
-	put_ bh exp_hash
-	put_ bh fixities
-	lazyPut bh warns
-	lazyPut bh anns
+                 mi_hpc       = hpc_info,
+                 mi_trust     = trust }) = do
+        put_ bh mod
+        put_ bh is_boot
+        put_ bh iface_hash
+        put_ bh mod_hash
+        put_ bh orphan
+        put_ bh hasFamInsts
+        lazyPut bh deps
+        lazyPut bh usages
+        put_ bh exports
+        put_ bh exp_hash
+        put_ bh fixities
+        lazyPut bh warns
+        lazyPut bh anns
         put_ bh decls
hunk ./compiler/iface/BinIface.hs 409
-	put_ bh insts
-	put_ bh fam_insts
-	lazyPut bh rules
-	put_ bh orphan_hash
+        put_ bh insts
+        put_ bh fam_insts
+        lazyPut bh rules
+        put_ bh orphan_hash
         put_ bh vect_info
hunk ./compiler/iface/BinIface.hs 414
-	put_ bh hpc_info
-	put_ bh trust
+        put_ bh hpc_info
+        put_ bh trust
 
    get bh = do
hunk ./compiler/iface/BinIface.hs 418
-	mod_name  <- get bh
-	is_boot   <- get bh
-	iface_hash <- get bh
-	mod_hash  <- get bh
-	orphan    <- get bh
-	hasFamInsts <- get bh
-	deps	  <- lazyGet bh
-	usages	  <- {-# SCC "bin_usages" #-} lazyGet bh
-	exports	  <- {-# SCC "bin_exports" #-} get bh
-	exp_hash  <- get bh
-	fixities  <- {-# SCC "bin_fixities" #-} get bh
-	warns     <- {-# SCC "bin_warns" #-} lazyGet bh
-	anns      <- {-# SCC "bin_anns" #-} lazyGet bh
-        decls 	  <- {-# SCC "bin_tycldecls" #-} get bh
-	insts     <- {-# SCC "bin_insts" #-} get bh
-	fam_insts <- {-# SCC "bin_fam_insts" #-} get bh
-	rules	  <- {-# SCC "bin_rules" #-} lazyGet bh
-	orphan_hash <- get bh
+        mod_name  <- get bh
+        is_boot   <- get bh
+        iface_hash <- get bh
+        mod_hash  <- get bh
+        orphan    <- get bh
+        hasFamInsts <- get bh
+        deps      <- lazyGet bh
+        usages    <- {-# SCC "bin_usages" #-} lazyGet bh
+        exports   <- {-# SCC "bin_exports" #-} get bh
+        exp_hash  <- get bh
+        fixities  <- {-# SCC "bin_fixities" #-} get bh
+        warns     <- {-# SCC "bin_warns" #-} lazyGet bh
+        anns      <- {-# SCC "bin_anns" #-} lazyGet bh
+        decls     <- {-# SCC "bin_tycldecls" #-} get bh
+        insts     <- {-# SCC "bin_insts" #-} get bh
+        fam_insts <- {-# SCC "bin_fam_insts" #-} get bh
+        rules     <- {-# SCC "bin_rules" #-} lazyGet bh
+        orphan_hash <- get bh
         vect_info <- get bh
         hpc_info  <- get bh
         trust     <- get bh
hunk ./compiler/iface/BinIface.hs 439
-	return (ModIface {
-		 mi_module    = mod_name,
-		 mi_boot      = is_boot,
-		 mi_iface_hash = iface_hash,
-		 mi_mod_hash  = mod_hash,
-		 mi_orphan    = orphan,
-		 mi_finsts    = hasFamInsts,
-		 mi_deps      = deps,
-		 mi_usages    = usages,
-		 mi_exports   = exports,
-		 mi_exp_hash  = exp_hash,
-		 mi_anns      = anns,
-		 mi_fixities  = fixities,
-		 mi_warns     = warns,
-		 mi_decls     = decls,
-		 mi_globals   = Nothing,
-		 mi_insts     = insts,
-		 mi_fam_insts = fam_insts,
-		 mi_rules     = rules,
-		 mi_orphan_hash = orphan_hash,
+        return (ModIface {
+                 mi_module    = mod_name,
+                 mi_boot      = is_boot,
+                 mi_iface_hash = iface_hash,
+                 mi_mod_hash  = mod_hash,
+                 mi_orphan    = orphan,
+                 mi_finsts    = hasFamInsts,
+                 mi_deps      = deps,
+                 mi_usages    = usages,
+                 mi_exports   = exports,
+                 mi_exp_hash  = exp_hash,
+                 mi_anns      = anns,
+                 mi_fixities  = fixities,
+                 mi_warns     = warns,
+                 mi_decls     = decls,
+                 mi_globals   = Nothing,
+                 mi_insts     = insts,
+                 mi_fam_insts = fam_insts,
+                 mi_rules     = rules,
+                 mi_orphan_hash = orphan_hash,
                  mi_vect_info = vect_info,
hunk ./compiler/iface/BinIface.hs 460
-		 mi_hpc       = hpc_info,
-		 mi_trust     = trust,
-			-- And build the cached values
-		 mi_warn_fn   = mkIfaceWarnCache warns,
-		 mi_fix_fn    = mkIfaceFixCache fixities,
-		 mi_hash_fn   = mkIfaceHashCache decls })
+                 mi_hpc       = hpc_info,
+                 mi_trust     = trust,
+                        -- And build the cached values
+                 mi_warn_fn   = mkIfaceWarnCache warns,
+                 mi_fix_fn    = mkIfaceFixCache fixities,
+                 mi_hash_fn   = mkIfaceHashCache decls })
 
 getWayDescr :: DynFlags -> String
 getWayDescr dflags
hunk ./compiler/iface/BinIface.hs 472
   | cGhcUnregisterised == "YES" = 'u':tag
   | otherwise                   = tag
   where tag = buildTag dflags
-	-- if this is an unregisterised build, make sure our interfaces
-	-- can't be used by a registerised build.
+        -- if this is an unregisterised build, make sure our interfaces
+        -- can't be used by a registerised build.
 
 -------------------------------------------------------------------------
hunk ./compiler/iface/BinIface.hs 476
---		Types from: HscTypes
+--              Types from: HscTypes
 -------------------------------------------------------------------------
 
 instance Binary Dependencies where
hunk ./compiler/iface/BinIface.hs 481
     put_ bh deps = do put_ bh (dep_mods deps)
-		      put_ bh (dep_pkgs deps)
-		      put_ bh (dep_orphs deps)
-		      put_ bh (dep_finsts deps)
+                      put_ bh (dep_pkgs deps)
+                      put_ bh (dep_orphs deps)
+                      put_ bh (dep_finsts deps)
 
hunk ./compiler/iface/BinIface.hs 485
-    get bh = do ms <- get bh 
-		ps <- get bh
-		os <- get bh
-		fis <- get bh
-		return (Deps { dep_mods = ms, dep_pkgs = ps, dep_orphs = os,
-			       dep_finsts = fis })
+    get bh = do ms <- get bh
+                ps <- get bh
+                os <- get bh
+                fis <- get bh
+                return (Deps { dep_mods = ms, dep_pkgs = ps, dep_orphs = os,
+                               dep_finsts = fis })
 
 instance (Binary name) => Binary (GenAvailInfo name) where
     put_ bh (Avail aa) = do
hunk ./compiler/iface/BinIface.hs 494
-	    putByte bh 0
-	    put_ bh aa
+            putByte bh 0
+            put_ bh aa
     put_ bh (AvailTC ab ac) = do
hunk ./compiler/iface/BinIface.hs 497
-	    putByte bh 1
-	    put_ bh ab
-	    put_ bh ac
+            putByte bh 1
+            put_ bh ab
+            put_ bh ac
     get bh = do
hunk ./compiler/iface/BinIface.hs 501
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      return (Avail aa)
-	      _ -> do ab <- get bh
-		      ac <- get bh
-		      return (AvailTC ab ac)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      return (Avail aa)
+              _ -> do ab <- get bh
+                      ac <- get bh
+                      return (AvailTC ab ac)
 
 instance Binary Usage where
hunk ./compiler/iface/BinIface.hs 510
-    put_ bh usg@UsagePackageModule{} = do 
+    put_ bh usg@UsagePackageModule{} = do
         putByte bh 0
hunk ./compiler/iface/BinIface.hs 512
-	put_ bh (usg_mod usg)
-	put_ bh (usg_mod_hash usg)
-	put_ bh (usg_safe     usg)
-    put_ bh usg@UsageHomeModule{} = do 
+        put_ bh (usg_mod usg)
+        put_ bh (usg_mod_hash usg)
+        put_ bh (usg_safe     usg)
+    put_ bh usg@UsageHomeModule{} = do
         putByte bh 1
hunk ./compiler/iface/BinIface.hs 517
-	put_ bh (usg_mod_name usg)
-	put_ bh (usg_mod_hash usg)
-	put_ bh (usg_exports  usg)
-	put_ bh (usg_entities usg)
-	put_ bh (usg_safe     usg)
+        put_ bh (usg_mod_name usg)
+        put_ bh (usg_mod_hash usg)
+        put_ bh (usg_exports  usg)
+        put_ bh (usg_entities usg)
+        put_ bh (usg_safe     usg)
 
     get bh = do
         h <- getByte bh
hunk ./compiler/iface/BinIface.hs 575
                       return (DeprecatedTxt d)
 
 -------------------------------------------------------------------------
---		Types from: BasicTypes
+--              Types from: BasicTypes
 -------------------------------------------------------------------------
 
 instance Binary Activation where
hunk ./compiler/iface/BinIface.hs 580
     put_ bh NeverActive = do
-	    putByte bh 0
+            putByte bh 0
     put_ bh AlwaysActive = do
hunk ./compiler/iface/BinIface.hs 582
-	    putByte bh 1
+            putByte bh 1
     put_ bh (ActiveBefore aa) = do
hunk ./compiler/iface/BinIface.hs 584
-	    putByte bh 2
-	    put_ bh aa
+            putByte bh 2
+            put_ bh aa
     put_ bh (ActiveAfter ab) = do
hunk ./compiler/iface/BinIface.hs 587
-	    putByte bh 3
-	    put_ bh ab
+            putByte bh 3
+            put_ bh ab
     get bh = do
hunk ./compiler/iface/BinIface.hs 590
-	    h <- getByte bh
-	    case h of
-	      0 -> do return NeverActive
-	      1 -> do return AlwaysActive
-	      2 -> do aa <- get bh
-		      return (ActiveBefore aa)
-	      _ -> do ab <- get bh
-		      return (ActiveAfter ab)
+            h <- getByte bh
+            case h of
+              0 -> do return NeverActive
+              1 -> do return AlwaysActive
+              2 -> do aa <- get bh
+                      return (ActiveBefore aa)
+              _ -> do ab <- get bh
+                      return (ActiveAfter ab)
 
 instance Binary RuleMatchInfo where
     put_ bh FunLike = putByte bh 0
hunk ./compiler/iface/BinIface.hs 640
     put_ bh HsUnpack        = putByte bh 2
     put_ bh HsUnpackFailed  = putByte bh 3
     get bh = do
-	    h <- getByte bh
-	    case h of
-	      0 -> do return HsNoBang
-	      1 -> do return HsStrict
-	      2 -> do return HsUnpack
-	      _ -> do return HsUnpackFailed
+            h <- getByte bh
+            case h of
+              0 -> do return HsNoBang
+              1 -> do return HsStrict
+              2 -> do return HsUnpack
+              _ -> do return HsUnpackFailed
 
 instance Binary Boxity where
     put_ bh Boxed   = putByte bh 0
hunk ./compiler/iface/BinIface.hs 651
     put_ bh Unboxed = putByte bh 1
     get bh = do
-	    h <- getByte bh
-	    case h of
-	      0 -> do return Boxed
-	      _ -> do return Unboxed
+            h <- getByte bh
+            case h of
+              0 -> do return Boxed
+              _ -> do return Unboxed
 
 instance Binary TupCon where
     put_ bh (TupCon ab ac) = do
hunk ./compiler/iface/BinIface.hs 658
-	    put_ bh ab
-	    put_ bh ac
+            put_ bh ab
+            put_ bh ac
     get bh = do
hunk ./compiler/iface/BinIface.hs 661
-	  ab <- get bh
-	  ac <- get bh
-	  return (TupCon ab ac)
+          ab <- get bh
+          ac <- get bh
+          return (TupCon ab ac)
 
 instance Binary RecFlag where
     put_ bh Recursive = do
hunk ./compiler/iface/BinIface.hs 667
-	    putByte bh 0
+            putByte bh 0
     put_ bh NonRecursive = do
hunk ./compiler/iface/BinIface.hs 669
-	    putByte bh 1
+            putByte bh 1
     get bh = do
hunk ./compiler/iface/BinIface.hs 671
-	    h <- getByte bh
-	    case h of
-	      0 -> do return Recursive
-	      _ -> do return NonRecursive
+            h <- getByte bh
+            case h of
+              0 -> do return Recursive
+              _ -> do return NonRecursive
 
 instance Binary DefMethSpec where
     put_ bh NoDM      = putByte bh 0
hunk ./compiler/iface/BinIface.hs 681
     put_ bh VanillaDM = putByte bh 1
     put_ bh GenericDM = putByte bh 2
     get bh = do
-	    h <- getByte bh
-	    case h of
-	      0 -> return NoDM
-	      1 -> return VanillaDM
-	      _ -> return GenericDM
+            h <- getByte bh
+            case h of
+              0 -> return NoDM
+              1 -> return VanillaDM
+              _ -> return GenericDM
 
 instance Binary FixityDirection where
     put_ bh InfixL = do
hunk ./compiler/iface/BinIface.hs 689
-	    putByte bh 0
+            putByte bh 0
     put_ bh InfixR = do
hunk ./compiler/iface/BinIface.hs 691
-	    putByte bh 1
+            putByte bh 1
     put_ bh InfixN = do
hunk ./compiler/iface/BinIface.hs 693
-	    putByte bh 2
+            putByte bh 2
     get bh = do
hunk ./compiler/iface/BinIface.hs 695
-	    h <- getByte bh
-	    case h of
-	      0 -> do return InfixL
-	      1 -> do return InfixR
-	      _ -> do return InfixN
+            h <- getByte bh
+            case h of
+              0 -> do return InfixL
+              1 -> do return InfixR
+              _ -> do return InfixN
 
 instance Binary Fixity where
     put_ bh (Fixity aa ab) = do
hunk ./compiler/iface/BinIface.hs 703
-	    put_ bh aa
-	    put_ bh ab
+            put_ bh aa
+            put_ bh ab
     get bh = do
hunk ./compiler/iface/BinIface.hs 706
-	  aa <- get bh
-	  ab <- get bh
-	  return (Fixity aa ab)
+          aa <- get bh
+          ab <- get bh
+          return (Fixity aa ab)
 
 instance (Binary name) => Binary (IPName name) where
     put_ bh (IPName aa) = put_ bh aa
hunk ./compiler/iface/BinIface.hs 713
     get bh = do aa <- get bh
-	        return (IPName aa)
+                return (IPName aa)
 
 -------------------------------------------------------------------------
hunk ./compiler/iface/BinIface.hs 716
---		Types from: Demand
+--              Types from: Demand
 -------------------------------------------------------------------------
 
 instance Binary DmdType where
hunk ./compiler/iface/BinIface.hs 720
-	-- Ignore DmdEnv when spitting out the DmdType
+        -- Ignore DmdEnv when spitting out the DmdType
   put bh (DmdType _ ds dr) = do p <- put bh ds; put_ bh dr; return (castBin p)
   get bh = do ds <- get bh; dr <- get bh; return (DmdType emptyVarEnv ds dr)
 
hunk ./compiler/iface/BinIface.hs 726
 instance Binary Demand where
     put_ bh Top = do
-	    putByte bh 0
+            putByte bh 0
     put_ bh Abs = do
hunk ./compiler/iface/BinIface.hs 728
-	    putByte bh 1
+            putByte bh 1
     put_ bh (Call aa) = do
hunk ./compiler/iface/BinIface.hs 730
-	    putByte bh 2
-	    put_ bh aa
+            putByte bh 2
+            put_ bh aa
     put_ bh (Eval ab) = do
hunk ./compiler/iface/BinIface.hs 733
-	    putByte bh 3
-	    put_ bh ab
+            putByte bh 3
+            put_ bh ab
     put_ bh (Defer ac) = do
hunk ./compiler/iface/BinIface.hs 736
-	    putByte bh 4
-	    put_ bh ac
+            putByte bh 4
+            put_ bh ac
     put_ bh (Box ad) = do
hunk ./compiler/iface/BinIface.hs 739
-	    putByte bh 5
-	    put_ bh ad
+            putByte bh 5
+            put_ bh ad
     put_ bh Bot = do
hunk ./compiler/iface/BinIface.hs 742
-	    putByte bh 6
+            putByte bh 6
     get bh = do
hunk ./compiler/iface/BinIface.hs 744
-	    h <- getByte bh
-	    case h of
-	      0 -> do return Top
-	      1 -> do return Abs
-	      2 -> do aa <- get bh
-		      return (Call aa)
-	      3 -> do ab <- get bh
-		      return (Eval ab)
-	      4 -> do ac <- get bh
-		      return (Defer ac)
-	      5 -> do ad <- get bh
-		      return (Box ad)
-	      _ -> do return Bot
+            h <- getByte bh
+            case h of
+              0 -> do return Top
+              1 -> do return Abs
+              2 -> do aa <- get bh
+                      return (Call aa)
+              3 -> do ab <- get bh
+                      return (Eval ab)
+              4 -> do ac <- get bh
+                      return (Defer ac)
+              5 -> do ad <- get bh
+                      return (Box ad)
+              _ -> do return Bot
 
 instance Binary Demands where
     put_ bh (Poly aa) = do
hunk ./compiler/iface/BinIface.hs 760
-	    putByte bh 0
-	    put_ bh aa
+            putByte bh 0
+            put_ bh aa
     put_ bh (Prod ab) = do
hunk ./compiler/iface/BinIface.hs 763
-	    putByte bh 1
-	    put_ bh ab
+            putByte bh 1
+            put_ bh ab
     get bh = do
hunk ./compiler/iface/BinIface.hs 766
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      return (Poly aa)
-	      _ -> do ab <- get bh
-		      return (Prod ab)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      return (Poly aa)
+              _ -> do ab <- get bh
+                      return (Prod ab)
 
 instance Binary DmdResult where
     put_ bh TopRes = do
hunk ./compiler/iface/BinIface.hs 775
-	    putByte bh 0
+            putByte bh 0
     put_ bh RetCPR = do
hunk ./compiler/iface/BinIface.hs 777
-	    putByte bh 1
+            putByte bh 1
     put_ bh BotRes = do
hunk ./compiler/iface/BinIface.hs 779
-	    putByte bh 2
+            putByte bh 2
     get bh = do
hunk ./compiler/iface/BinIface.hs 781
-	    h <- getByte bh
-	    case h of
-	      0 -> do return TopRes
-	      1 -> do return RetCPR	-- Really use RetCPR even if -fcpr-off
-					-- The wrapper was generated for CPR in 
-					-- the imported module!
-	      _ -> do return BotRes
+            h <- getByte bh
+            case h of
+              0 -> do return TopRes
+              1 -> do return RetCPR     -- Really use RetCPR even if -fcpr-off
+                                        -- The wrapper was generated for CPR in
+                                        -- the imported module!
+              _ -> do return BotRes
 
 instance Binary StrictSig where
     put_ bh (StrictSig aa) = do
hunk ./compiler/iface/BinIface.hs 791
-	    put_ bh aa
+            put_ bh aa
     get bh = do
hunk ./compiler/iface/BinIface.hs 793
-	  aa <- get bh
-	  return (StrictSig aa)
+          aa <- get bh
+          return (StrictSig aa)
 
 
 -------------------------------------------------------------------------
hunk ./compiler/iface/BinIface.hs 798
---		Types from: CostCentre
+--              Types from: CostCentre
 -------------------------------------------------------------------------
 
 instance Binary IsCafCC where
hunk ./compiler/iface/BinIface.hs 803
     put_ bh CafCC = do
-	    putByte bh 0
+            putByte bh 0
     put_ bh NotCafCC = do
hunk ./compiler/iface/BinIface.hs 805
-	    putByte bh 1
+            putByte bh 1
     get bh = do
hunk ./compiler/iface/BinIface.hs 807
-	    h <- getByte bh
-	    case h of
-	      0 -> do return CafCC
-	      _ -> do return NotCafCC
+            h <- getByte bh
+            case h of
+              0 -> do return CafCC
+              _ -> do return NotCafCC
 
 instance Binary IsDupdCC where
     put_ bh OriginalCC = do
hunk ./compiler/iface/BinIface.hs 814
-	    putByte bh 0
+            putByte bh 0
     put_ bh DupdCC = do
hunk ./compiler/iface/BinIface.hs 816
-	    putByte bh 1
+            putByte bh 1
     get bh = do
hunk ./compiler/iface/BinIface.hs 818
-	    h <- getByte bh
-	    case h of
-	      0 -> do return OriginalCC
-	      _ -> do return DupdCC
+            h <- getByte bh
+            case h of
+              0 -> do return OriginalCC
+              _ -> do return DupdCC
 
 instance Binary CostCentre where
     put_ bh NoCostCentre = do
hunk ./compiler/iface/BinIface.hs 825
-	    putByte bh 0
+            putByte bh 0
     put_ bh (NormalCC aa ab ac ad) = do
hunk ./compiler/iface/BinIface.hs 827
-	    putByte bh 1
-	    put_ bh aa
-	    put_ bh ab
-	    put_ bh ac
-	    put_ bh ad
+            putByte bh 1
+            put_ bh aa
+            put_ bh ab
+            put_ bh ac
+            put_ bh ad
     put_ bh (AllCafsCC ae) = do
hunk ./compiler/iface/BinIface.hs 833
-	    putByte bh 2
-	    put_ bh ae
+            putByte bh 2
+            put_ bh ae
     get bh = do
hunk ./compiler/iface/BinIface.hs 836
-	    h <- getByte bh
-	    case h of
-	      0 -> do return NoCostCentre
-	      1 -> do aa <- get bh
-		      ab <- get bh
-		      ac <- get bh
-		      ad <- get bh
-		      return (NormalCC aa ab ac ad)
-	      _ -> do ae <- get bh
-		      return (AllCafsCC ae)
+            h <- getByte bh
+            case h of
+              0 -> do return NoCostCentre
+              1 -> do aa <- get bh
+                      ab <- get bh
+                      ac <- get bh
+                      ad <- get bh
+                      return (NormalCC aa ab ac ad)
+              _ -> do ae <- get bh
+                      return (AllCafsCC ae)
 
 -------------------------------------------------------------------------
hunk ./compiler/iface/BinIface.hs 848
---		IfaceTypes and friends
+--              IfaceTypes and friends
 -------------------------------------------------------------------------
 
 instance Binary IfaceBndr where
hunk ./compiler/iface/BinIface.hs 853
     put_ bh (IfaceIdBndr aa) = do
-	    putByte bh 0
-	    put_ bh aa
+            putByte bh 0
+            put_ bh aa
     put_ bh (IfaceTvBndr ab) = do
hunk ./compiler/iface/BinIface.hs 856
-	    putByte bh 1
-	    put_ bh ab
+            putByte bh 1
+            put_ bh ab
     get bh = do
hunk ./compiler/iface/BinIface.hs 859
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      return (IfaceIdBndr aa)
-	      _ -> do ab <- get bh
-		      return (IfaceTvBndr ab)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      return (IfaceIdBndr aa)
+              _ -> do ab <- get bh
+                      return (IfaceTvBndr ab)
 
 instance Binary IfaceLetBndr where
     put_ bh (IfLetBndr a b c) = do
hunk ./compiler/iface/BinIface.hs 868
-	    put_ bh a
-	    put_ bh b
-	    put_ bh c
+            put_ bh a
+            put_ bh b
+            put_ bh c
     get bh = do a <- get bh
hunk ./compiler/iface/BinIface.hs 872
-	        b <- get bh
-	        c <- get bh
-		return (IfLetBndr a b c)	   
+                b <- get bh
+                c <- get bh
+                return (IfLetBndr a b c)
 
 instance Binary IfaceType where
     put_ bh (IfaceForAllTy aa ab) = do
hunk ./compiler/iface/BinIface.hs 878
-	    putByte bh 0
-	    put_ bh aa
-	    put_ bh ab
+            putByte bh 0
+            put_ bh aa
+            put_ bh ab
     put_ bh (IfaceTyVar ad) = do
hunk ./compiler/iface/BinIface.hs 882
-	    putByte bh 1
-	    put_ bh ad
+            putByte bh 1
+            put_ bh ad
     put_ bh (IfaceAppTy ae af) = do
hunk ./compiler/iface/BinIface.hs 885
-	    putByte bh 2
-	    put_ bh ae
-	    put_ bh af
+            putByte bh 2
+            put_ bh ae
+            put_ bh af
     put_ bh (IfaceFunTy ag ah) = do
hunk ./compiler/iface/BinIface.hs 889
-	    putByte bh 3
-	    put_ bh ag
-	    put_ bh ah
+            putByte bh 3
+            put_ bh ag
+            put_ bh ah
     put_ bh (IfacePredTy aq) = do
hunk ./compiler/iface/BinIface.hs 893
-	    putByte bh 5
-	    put_ bh aq
+            putByte bh 5
+            put_ bh aq
 
hunk ./compiler/iface/BinIface.hs 896
-	-- Simple compression for common cases of TyConApp
+        -- Simple compression for common cases of TyConApp
     put_ bh (IfaceTyConApp IfaceIntTc  [])   = putByte bh 6
     put_ bh (IfaceTyConApp IfaceCharTc [])   = putByte bh 7
     put_ bh (IfaceTyConApp IfaceBoolTc [])   = putByte bh 8
hunk ./compiler/iface/BinIface.hs 901
     put_ bh (IfaceTyConApp IfaceListTc [ty]) = do { putByte bh 9; put_ bh ty }
-	-- Unit tuple and pairs
-    put_ bh (IfaceTyConApp (IfaceTupTc Boxed 0) []) 	 = putByte bh 10
+        -- Unit tuple and pairs
+    put_ bh (IfaceTyConApp (IfaceTupTc Boxed 0) [])      = putByte bh 10
     put_ bh (IfaceTyConApp (IfaceTupTc Boxed 2) [t1,t2]) = do { putByte bh 11; put_ bh t1; put_ bh t2 }
         -- Kind cases
     put_ bh (IfaceTyConApp IfaceLiftedTypeKindTc [])   = putByte bh 12
hunk ./compiler/iface/BinIface.hs 910
     put_ bh (IfaceTyConApp IfaceUnliftedTypeKindTc []) = putByte bh 14
     put_ bh (IfaceTyConApp IfaceUbxTupleKindTc [])     = putByte bh 15
     put_ bh (IfaceTyConApp IfaceArgTypeKindTc [])      = putByte bh 16
-    put_ bh (IfaceTyConApp (IfaceAnyTc k) []) 	       = do { putByte bh 17; put_ bh k }
+    put_ bh (IfaceTyConApp (IfaceAnyTc k) [])          = do { putByte bh 17; put_ bh k }
 
hunk ./compiler/iface/BinIface.hs 912
-	-- Generic cases
+        -- Generic cases
 
     put_ bh (IfaceTyConApp (IfaceTc tc) tys) = do { putByte bh 18; put_ bh tc; put_ bh tys }
hunk ./compiler/iface/BinIface.hs 915
-    put_ bh (IfaceTyConApp tc tys) 	     = do { putByte bh 19; put_ bh tc; put_ bh tys }
+    put_ bh (IfaceTyConApp tc tys)           = do { putByte bh 19; put_ bh tc; put_ bh tys }
 
     get bh = do
hunk ./compiler/iface/BinIface.hs 918
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      ab <- get bh
-		      return (IfaceForAllTy aa ab)
-	      1 -> do ad <- get bh
-		      return (IfaceTyVar ad)
-	      2 -> do ae <- get bh
-		      af <- get bh
-		      return (IfaceAppTy ae af)
-	      3 -> do ag <- get bh
-		      ah <- get bh
-		      return (IfaceFunTy ag ah)
-	      5 -> do ap <- get bh
-		      return (IfacePredTy ap)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      ab <- get bh
+                      return (IfaceForAllTy aa ab)
+              1 -> do ad <- get bh
+                      return (IfaceTyVar ad)
+              2 -> do ae <- get bh
+                      af <- get bh
+                      return (IfaceAppTy ae af)
+              3 -> do ag <- get bh
+                      ah <- get bh
+                      return (IfaceFunTy ag ah)
+              5 -> do ap <- get bh
+                      return (IfacePredTy ap)
 
hunk ./compiler/iface/BinIface.hs 934
-		-- Now the special cases for TyConApp
-	      6 -> return (IfaceTyConApp IfaceIntTc [])
-	      7 -> return (IfaceTyConApp IfaceCharTc [])
-	      8 -> return (IfaceTyConApp IfaceBoolTc [])
-	      9 -> do { ty <- get bh; return (IfaceTyConApp IfaceListTc [ty]) }
-	      10 -> return (IfaceTyConApp (IfaceTupTc Boxed 0) [])
-	      11 -> do { t1 <- get bh; t2 <- get bh; return (IfaceTyConApp (IfaceTupTc Boxed 2) [t1,t2]) }
+                -- Now the special cases for TyConApp
+              6 -> return (IfaceTyConApp IfaceIntTc [])
+              7 -> return (IfaceTyConApp IfaceCharTc [])
+              8 -> return (IfaceTyConApp IfaceBoolTc [])
+              9 -> do { ty <- get bh; return (IfaceTyConApp IfaceListTc [ty]) }
+              10 -> return (IfaceTyConApp (IfaceTupTc Boxed 0) [])
+              11 -> do { t1 <- get bh; t2 <- get bh; return (IfaceTyConApp (IfaceTupTc Boxed 2) [t1,t2]) }
               12 -> return (IfaceTyConApp IfaceLiftedTypeKindTc [])
               13 -> return (IfaceTyConApp IfaceOpenTypeKindTc [])
               14 -> return (IfaceTyConApp IfaceUnliftedTypeKindTc [])
hunk ./compiler/iface/BinIface.hs 948
               16 -> return (IfaceTyConApp IfaceArgTypeKindTc [])
               17 -> do { k <- get bh; return (IfaceTyConApp (IfaceAnyTc k) []) }
 
-	      18 -> do { tc <- get bh; tys <- get bh; return (IfaceTyConApp (IfaceTc tc) tys) }
-	      _  -> do { tc <- get bh; tys <- get bh; return (IfaceTyConApp tc tys) }
+              18 -> do { tc <- get bh; tys <- get bh; return (IfaceTyConApp (IfaceTc tc) tys) }
+              _  -> do { tc <- get bh; tys <- get bh; return (IfaceTyConApp tc tys) }
 
 instance Binary IfaceTyCon where
hunk ./compiler/iface/BinIface.hs 952
-	-- Int,Char,Bool can't show up here because they can't not be saturated
+        -- Int,Char,Bool can't show up here because they can't not be saturated
 
hunk ./compiler/iface/BinIface.hs 954
-   put_ bh IfaceIntTc  	      = putByte bh 1
-   put_ bh IfaceBoolTc 	      = putByte bh 2
-   put_ bh IfaceCharTc 	      = putByte bh 3
-   put_ bh IfaceListTc 	      = putByte bh 4
-   put_ bh IfacePArrTc 	      = putByte bh 5
+   put_ bh IfaceIntTc         = putByte bh 1
+   put_ bh IfaceBoolTc        = putByte bh 2
+   put_ bh IfaceCharTc        = putByte bh 3
+   put_ bh IfaceListTc        = putByte bh 4
+   put_ bh IfacePArrTc        = putByte bh 5
    put_ bh IfaceLiftedTypeKindTc   = putByte bh 6
    put_ bh IfaceOpenTypeKindTc     = putByte bh 7
    put_ bh IfaceUnliftedTypeKindTc = putByte bh 8
hunk ./compiler/iface/BinIface.hs 969
    put_ bh (IfaceAnyTc k)     = do { putByte bh 13; put_ bh k }
 
    get bh = do
-	h <- getByte bh
-	case h of
-	  1 -> return IfaceIntTc
-	  2 -> return IfaceBoolTc
-	  3 -> return IfaceCharTc
-	  4 -> return IfaceListTc
-	  5 -> return IfacePArrTc
-          6 -> return IfaceLiftedTypeKindTc 
-          7 -> return IfaceOpenTypeKindTc 
+        h <- getByte bh
+        case h of
+          1 -> return IfaceIntTc
+          2 -> return IfaceBoolTc
+          3 -> return IfaceCharTc
+          4 -> return IfaceListTc
+          5 -> return IfacePArrTc
+          6 -> return IfaceLiftedTypeKindTc
+          7 -> return IfaceOpenTypeKindTc
           8 -> return IfaceUnliftedTypeKindTc
           9 -> return IfaceUbxTupleKindTc
           10 -> return IfaceArgTypeKindTc
hunk ./compiler/iface/BinIface.hs 981
-	  11 -> do { bx <- get bh; ar <- get bh; return (IfaceTupTc bx ar) }
-	  12 -> do { ext <- get bh; return (IfaceTc ext) }
-	  _  -> do { k <- get bh; return (IfaceAnyTc k) }
+          11 -> do { bx <- get bh; ar <- get bh; return (IfaceTupTc bx ar) }
+          12 -> do { ext <- get bh; return (IfaceTc ext) }
+          _  -> do { k <- get bh; return (IfaceAnyTc k) }
 
 instance Binary IfacePredType where
     put_ bh (IfaceClassP aa ab) = do
hunk ./compiler/iface/BinIface.hs 987
-	    putByte bh 0
-	    put_ bh aa
-	    put_ bh ab
+            putByte bh 0
+            put_ bh aa
+            put_ bh ab
     put_ bh (IfaceIParam ac ad) = do
hunk ./compiler/iface/BinIface.hs 991
-	    putByte bh 1
-	    put_ bh ac
-	    put_ bh ad
+            putByte bh 1
+            put_ bh ac
+            put_ bh ad
     put_ bh (IfaceEqPred ac ad) = do
hunk ./compiler/iface/BinIface.hs 995
-	    putByte bh 2
-	    put_ bh ac
-	    put_ bh ad
+            putByte bh 2
+            put_ bh ac
+            put_ bh ad
     get bh = do
hunk ./compiler/iface/BinIface.hs 999
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      ab <- get bh
-		      return (IfaceClassP aa ab)
-	      1 -> do ac <- get bh
-		      ad <- get bh
-		      return (IfaceIParam ac ad)
-	      2 -> do ac <- get bh
-		      ad <- get bh
-		      return (IfaceEqPred ac ad)
-	      _ -> panic ("get IfacePredType " ++ show h)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      ab <- get bh
+                      return (IfaceClassP aa ab)
+              1 -> do ac <- get bh
+                      ad <- get bh
+                      return (IfaceIParam ac ad)
+              2 -> do ac <- get bh
+                      ad <- get bh
+                      return (IfaceEqPred ac ad)
+              _ -> panic ("get IfacePredType " ++ show h)
 
 -------------------------------------------------------------------------
hunk ./compiler/iface/BinIface.hs 1013
---		IfaceExpr and friends
+--              IfaceExpr and friends
 -------------------------------------------------------------------------
 
 instance Binary IfaceExpr where
hunk ./compiler/iface/BinIface.hs 1018
     put_ bh (IfaceLcl aa) = do
-	    putByte bh 0
-	    put_ bh aa
+            putByte bh 0
+            put_ bh aa
     put_ bh (IfaceType ab) = do
hunk ./compiler/iface/BinIface.hs 1021
-	    putByte bh 1
-	    put_ bh ab
+            putByte bh 1
+            put_ bh ab
     put_ bh (IfaceTuple ac ad) = do
hunk ./compiler/iface/BinIface.hs 1024
-	    putByte bh 2
-	    put_ bh ac
-	    put_ bh ad
+            putByte bh 2
+            put_ bh ac
+            put_ bh ad
     put_ bh (IfaceLam ae af) = do
hunk ./compiler/iface/BinIface.hs 1028
-	    putByte bh 3
-	    put_ bh ae
-	    put_ bh af
+            putByte bh 3
+            put_ bh ae
+            put_ bh af
     put_ bh (IfaceApp ag ah) = do
hunk ./compiler/iface/BinIface.hs 1032
-	    putByte bh 4
-	    put_ bh ag
-	    put_ bh ah
+            putByte bh 4
+            put_ bh ag
+            put_ bh ah
 -- gaw 2004
     put_ bh (IfaceCase ai aj al ak) = do
hunk ./compiler/iface/BinIface.hs 1037
-	    putByte bh 5
-	    put_ bh ai
-	    put_ bh aj
+            putByte bh 5
+            put_ bh ai
+            put_ bh aj
 -- gaw 2004
             put_ bh al
hunk ./compiler/iface/BinIface.hs 1042
-	    put_ bh ak
+            put_ bh ak
     put_ bh (IfaceLet al am) = do
hunk ./compiler/iface/BinIface.hs 1044
-	    putByte bh 6
-	    put_ bh al
-	    put_ bh am
+            putByte bh 6
+            put_ bh al
+            put_ bh am
     put_ bh (IfaceNote an ao) = do
hunk ./compiler/iface/BinIface.hs 1048
-	    putByte bh 7
-	    put_ bh an
-	    put_ bh ao
+            putByte bh 7
+            put_ bh an
+            put_ bh ao
     put_ bh (IfaceLit ap) = do
hunk ./compiler/iface/BinIface.hs 1052
-	    putByte bh 8
-	    put_ bh ap
+            putByte bh 8
+            put_ bh ap
     put_ bh (IfaceFCall as at) = do
hunk ./compiler/iface/BinIface.hs 1055
-	    putByte bh 9
-	    put_ bh as
-	    put_ bh at
+            putByte bh 9
+            put_ bh as
+            put_ bh at
     put_ bh (IfaceExt aa) = do
hunk ./compiler/iface/BinIface.hs 1059
-	    putByte bh 10
-	    put_ bh aa
+            putByte bh 10
+            put_ bh aa
     put_ bh (IfaceCast ie ico) = do
             putByte bh 11
             put_ bh ie
hunk ./compiler/iface/BinIface.hs 1070
             put_ bh m
             put_ bh ix
     get bh = do
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      return (IfaceLcl aa)
-	      1 -> do ab <- get bh
-		      return (IfaceType ab)
-	      2 -> do ac <- get bh
-		      ad <- get bh
-		      return (IfaceTuple ac ad)
-	      3 -> do ae <- get bh
-		      af <- get bh
-		      return (IfaceLam ae af)
-	      4 -> do ag <- get bh
-		      ah <- get bh
-		      return (IfaceApp ag ah)
-	      5 -> do ai <- get bh
-		      aj <- get bh
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      return (IfaceLcl aa)
+              1 -> do ab <- get bh
+                      return (IfaceType ab)
+              2 -> do ac <- get bh
+                      ad <- get bh
+                      return (IfaceTuple ac ad)
+              3 -> do ae <- get bh
+                      af <- get bh
+                      return (IfaceLam ae af)
+              4 -> do ag <- get bh
+                      ah <- get bh
+                      return (IfaceApp ag ah)
+              5 -> do ai <- get bh
+                      aj <- get bh
 -- gaw 2004
hunk ./compiler/iface/BinIface.hs 1088
-                      al <- get bh                   
-		      ak <- get bh
+                      al <- get bh
+                      ak <- get bh
 -- gaw 2004
hunk ./compiler/iface/BinIface.hs 1091
-		      return (IfaceCase ai aj al ak)
-	      6 -> do al <- get bh
-		      am <- get bh
-		      return (IfaceLet al am)
-	      7 -> do an <- get bh
-		      ao <- get bh
-		      return (IfaceNote an ao)
-	      8 -> do ap <- get bh
-		      return (IfaceLit ap)
-	      9 -> do as <- get bh
-		      at <- get bh
-		      return (IfaceFCall as at)
-	      10 -> do aa <- get bh
-		       return (IfaceExt aa)
+                      return (IfaceCase ai aj al ak)
+              6 -> do al <- get bh
+                      am <- get bh
+                      return (IfaceLet al am)
+              7 -> do an <- get bh
+                      ao <- get bh
+                      return (IfaceNote an ao)
+              8 -> do ap <- get bh
+                      return (IfaceLit ap)
+              9 -> do as <- get bh
+                      at <- get bh
+                      return (IfaceFCall as at)
+              10 -> do aa <- get bh
+                       return (IfaceExt aa)
               11 -> do ie <- get bh
                        ico <- get bh
                        return (IfaceCast ie ico)
hunk ./compiler/iface/BinIface.hs 1115
 
 instance Binary IfaceConAlt where
     put_ bh IfaceDefault = do
-	    putByte bh 0
+            putByte bh 0
     put_ bh (IfaceDataAlt aa) = do
hunk ./compiler/iface/BinIface.hs 1117
-	    putByte bh 1
-	    put_ bh aa
+            putByte bh 1
+            put_ bh aa
     put_ bh (IfaceTupleAlt ab) = do
hunk ./compiler/iface/BinIface.hs 1120
-	    putByte bh 2
-	    put_ bh ab
+            putByte bh 2
+            put_ bh ab
     put_ bh (IfaceLitAlt ac) = do
hunk ./compiler/iface/BinIface.hs 1123
-	    putByte bh 3
-	    put_ bh ac
+            putByte bh 3
+            put_ bh ac
     get bh = do
hunk ./compiler/iface/BinIface.hs 1126
-	    h <- getByte bh
-	    case h of
-	      0 -> do return IfaceDefault
-	      1 -> do aa <- get bh
-		      return (IfaceDataAlt aa)
-	      2 -> do ab <- get bh
-		      return (IfaceTupleAlt ab)
-	      _ -> do ac <- get bh
-		      return (IfaceLitAlt ac)
+            h <- getByte bh
+            case h of
+              0 -> do return IfaceDefault
+              1 -> do aa <- get bh
+                      return (IfaceDataAlt aa)
+              2 -> do ab <- get bh
+                      return (IfaceTupleAlt ab)
+              _ -> do ac <- get bh
+                      return (IfaceLitAlt ac)
 
 instance Binary IfaceBinding where
     put_ bh (IfaceNonRec aa ab) = do
hunk ./compiler/iface/BinIface.hs 1138
-	    putByte bh 0
-	    put_ bh aa
-	    put_ bh ab
+            putByte bh 0
+            put_ bh aa
+            put_ bh ab
     put_ bh (IfaceRec ac) = do
hunk ./compiler/iface/BinIface.hs 1142
-	    putByte bh 1
-	    put_ bh ac
+            putByte bh 1
+            put_ bh ac
     get bh = do
hunk ./compiler/iface/BinIface.hs 1145
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      ab <- get bh
-		      return (IfaceNonRec aa ab)
-	      _ -> do ac <- get bh
-		      return (IfaceRec ac)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      ab <- get bh
+                      return (IfaceNonRec aa ab)
+              _ -> do ac <- get bh
+                      return (IfaceRec ac)
 
 instance Binary IfaceIdDetails where
     put_ bh IfVanillaId      = putByte bh 0
hunk ./compiler/iface/BinIface.hs 1158
     put_ bh (IfRecSelId a b) = do { putByte bh 1; put_ bh a; put_ bh b }
     put_ bh (IfDFunId n)     = do { putByte bh 2; put_ bh n }
     get bh = do
-	    h <- getByte bh
-	    case h of
-	      0 -> return IfVanillaId
-	      1 -> do a <- get bh
-		      b <- get bh
-		      return (IfRecSelId a b)
+            h <- getByte bh
+            case h of
+              0 -> return IfVanillaId
+              1 -> do a <- get bh
+                      b <- get bh
+                      return (IfRecSelId a b)
               _ -> do { n <- get bh; return (IfDFunId n) }
 
 instance Binary IfaceIdInfo where
hunk ./compiler/iface/BinIface.hs 1169
     put_ bh NoInfo = putByte bh 0
     put_ bh (HasInfo i) = do
-	    putByte bh 1
-	    lazyPut bh i			-- NB lazyPut
+            putByte bh 1
+            lazyPut bh i                        -- NB lazyPut
 
     get bh = do
hunk ./compiler/iface/BinIface.hs 1173
-	    h <- getByte bh
-	    case h of
-	      0 -> return NoInfo
-	      _ -> do info <- lazyGet bh	-- NB lazyGet
-		      return (HasInfo info)
+            h <- getByte bh
+            case h of
+              0 -> return NoInfo
+              _ -> do info <- lazyGet bh        -- NB lazyGet
+                      return (HasInfo info)
 
 instance Binary IfaceInfoItem where
     put_ bh (HsArity aa) = do
hunk ./compiler/iface/BinIface.hs 1181
-	    putByte bh 0
-	    put_ bh aa
+            putByte bh 0
+            put_ bh aa
     put_ bh (HsStrictness ab) = do
hunk ./compiler/iface/BinIface.hs 1184
-	    putByte bh 1
-	    put_ bh ab
+            putByte bh 1
+            put_ bh ab
     put_ bh (HsUnfold lb ad) = do
hunk ./compiler/iface/BinIface.hs 1187
-	    putByte bh 2
-	    put_ bh lb
-	    put_ bh ad
+            putByte bh 2
+            put_ bh lb
+            put_ bh ad
     put_ bh (HsInline ad) = do
hunk ./compiler/iface/BinIface.hs 1191
-	    putByte bh 3
-	    put_ bh ad
+            putByte bh 3
+            put_ bh ad
     put_ bh HsNoCafRefs = do
hunk ./compiler/iface/BinIface.hs 1194
-	    putByte bh 4
+            putByte bh 4
     get bh = do
hunk ./compiler/iface/BinIface.hs 1196
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      return (HsArity aa)
-	      1 -> do ab <- get bh
-		      return (HsStrictness ab)
-	      2 -> do lb <- get bh
-		      ad <- get bh
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      return (HsArity aa)
+              1 -> do ab <- get bh
+                      return (HsStrictness ab)
+              2 -> do lb <- get bh
+                      ad <- get bh
                       return (HsUnfold lb ad)
hunk ./compiler/iface/BinIface.hs 1205
-	      3 -> do ad <- get bh
-		      return (HsInline ad)
-	      _ -> do return HsNoCafRefs
+              3 -> do ad <- get bh
+                      return (HsInline ad)
+              _ -> do return HsNoCafRefs
 
 instance Binary IfaceUnfolding where
     put_ bh (IfCoreUnfold s e) = do
hunk ./compiler/iface/BinIface.hs 1211
-	putByte bh 0
-	put_ bh s
-	put_ bh e
+        putByte bh 0
+        put_ bh s
+        put_ bh e
     put_ bh (IfInlineRule a b c d) = do
hunk ./compiler/iface/BinIface.hs 1215
-	putByte bh 1
-	put_ bh a
-	put_ bh b
-	put_ bh c
-	put_ bh d
+        putByte bh 1
+        put_ bh a
+        put_ bh b
+        put_ bh c
+        put_ bh d
     put_ bh (IfLclWrapper a n) = do
hunk ./compiler/iface/BinIface.hs 1221
-	putByte bh 2
-	put_ bh a
-	put_ bh n
+        putByte bh 2
+        put_ bh a
+        put_ bh n
     put_ bh (IfExtWrapper a n) = do
hunk ./compiler/iface/BinIface.hs 1225
-	putByte bh 3
-	put_ bh a
-	put_ bh n
+        putByte bh 3
+        put_ bh a
+        put_ bh n
     put_ bh (IfDFunUnfold as) = do
hunk ./compiler/iface/BinIface.hs 1229
-	putByte bh 4
-	put_ bh as
+        putByte bh 4
+        put_ bh as
     put_ bh (IfCompulsory e) = do
hunk ./compiler/iface/BinIface.hs 1232
-	putByte bh 5
-	put_ bh e
+        putByte bh 5
+        put_ bh e
     get bh = do
hunk ./compiler/iface/BinIface.hs 1235
-	h <- getByte bh
-	case h of
-	  0 -> do s <- get bh
-		  e <- get bh
-		  return (IfCoreUnfold s e)
-	  1 -> do a <- get bh
-		  b <- get bh
-		  c <- get bh
-		  d <- get bh
-		  return (IfInlineRule a b c d)
-	  2 -> do a <- get bh
-		  n <- get bh
-		  return (IfLclWrapper a n)
-	  3 -> do a <- get bh
-		  n <- get bh
-		  return (IfExtWrapper a n)
-	  4 -> do as <- get bh
-		  return (IfDFunUnfold as)
-	  _ -> do e <- get bh
-		  return (IfCompulsory e)
+        h <- getByte bh
+        case h of
+          0 -> do s <- get bh
+                  e <- get bh
+                  return (IfCoreUnfold s e)
+          1 -> do a <- get bh
+                  b <- get bh
+                  c <- get bh
+                  d <- get bh
+                  return (IfInlineRule a b c d)
+          2 -> do a <- get bh
+                  n <- get bh
+                  return (IfLclWrapper a n)
+          3 -> do a <- get bh
+                  n <- get bh
+                  return (IfExtWrapper a n)
+          4 -> do as <- get bh
+                  return (IfDFunUnfold as)
+          _ -> do e <- get bh
+                  return (IfCompulsory e)
 
 instance Binary (DFunArg IfaceExpr) where
     put_ bh (DFunPolyArg  e) = putByte bh 0 >> put_ bh e
hunk ./compiler/iface/BinIface.hs 1268
 
 instance Binary IfaceNote where
     put_ bh (IfaceSCC aa) = do
-	    putByte bh 0
-	    put_ bh aa
+            putByte bh 0
+            put_ bh aa
     put_ bh (IfaceCoreNote s) = do
             putByte bh 4
             put_ bh s
hunk ./compiler/iface/BinIface.hs 1274
     get bh = do
-	    h <- getByte bh
-	    case h of
-	      0 -> do aa <- get bh
-		      return (IfaceSCC aa)
+            h <- getByte bh
+            case h of
+              0 -> do aa <- get bh
+                      return (IfaceSCC aa)
               4 -> do ac <- get bh
                       return (IfaceCoreNote ac)
               _ -> panic ("get IfaceNote " ++ show h)
hunk ./compiler/iface/BinIface.hs 1283
 
 -------------------------------------------------------------------------
---		IfaceDecl and friends
+--              IfaceDecl and friends
 -------------------------------------------------------------------------
 
 -- A bit of magic going on here: there's no need to store the OccName
hunk ./compiler/iface/BinIface.hs 1294
 
 instance Binary IfaceDecl where
     put_ bh (IfaceId name ty details idinfo) = do
-	    putByte bh 0
-	    put_ bh (occNameFS name)
-	    put_ bh ty
-	    put_ bh details
-	    put_ bh idinfo
-    put_ _ (IfaceForeign _ _) = 
-	error "Binary.put_(IfaceDecl): IfaceForeign"
+            putByte bh 0
+            put_ bh (occNameFS name)
+            put_ bh ty
+            put_ bh details
+            put_ bh idinfo
+    put_ _ (IfaceForeign _ _) =
+        error "Binary.put_(IfaceDecl): IfaceForeign"
     put_ bh (IfaceData a1 a2 a3 a4 a5 a6 a7 a8) = do
hunk ./compiler/iface/BinIface.hs 1302
-	    putByte bh 2
-	    put_ bh (occNameFS a1)
-	    put_ bh a2
-	    put_ bh a3
-	    put_ bh a4
-	    put_ bh a5
-	    put_ bh a6
-	    put_ bh a7
-	    put_ bh a8
+            putByte bh 2
+            put_ bh (occNameFS a1)
+            put_ bh a2
+            put_ bh a3
+            put_ bh a4
+            put_ bh a5
+            put_ bh a6
+            put_ bh a7
+            put_ bh a8
     put_ bh (IfaceSyn a1 a2 a3 a4 a5) = do
hunk ./compiler/iface/BinIface.hs 1312
-	    putByte bh 3
-	    put_ bh (occNameFS a1)
-	    put_ bh a2
-	    put_ bh a3
-	    put_ bh a4
-	    put_ bh a5
+            putByte bh 3
+            put_ bh (occNameFS a1)
+            put_ bh a2
+            put_ bh a3
+            put_ bh a4
+            put_ bh a5
     put_ bh (IfaceClass a1 a2 a3 a4 a5 a6 a7) = do
hunk ./compiler/iface/BinIface.hs 1319
-	    putByte bh 4
-	    put_ bh a1
-	    put_ bh (occNameFS a2)
-	    put_ bh a3
-	    put_ bh a4
-	    put_ bh a5
-	    put_ bh a6
-	    put_ bh a7
+            putByte bh 4
+            put_ bh a1
+            put_ bh (occNameFS a2)
+            put_ bh a3
+            put_ bh a4
+            put_ bh a5
+            put_ bh a6
+            put_ bh a7
     get bh = do
hunk ./compiler/iface/BinIface.hs 1328
-	    h <- getByte bh
-	    case h of
-	      0 -> do name    <- get bh
-		      ty      <- get bh
-		      details <- get bh
-		      idinfo  <- get bh
+            h <- getByte bh
+            case h of
+              0 -> do name    <- get bh
+                      ty      <- get bh
+                      details <- get bh
+                      idinfo  <- get bh
                       occ <- return $! mkOccNameFS varName name
hunk ./compiler/iface/BinIface.hs 1335
-		      return (IfaceId occ ty details idinfo)
-	      1 -> error "Binary.get(TyClDecl): ForeignType"
-	      2 -> do
-		    a1 <- get bh
-		    a2 <- get bh
-		    a3 <- get bh
-		    a4 <- get bh
-		    a5 <- get bh
-		    a6 <- get bh
-		    a7 <- get bh
-		    a8 <- get bh
+                      return (IfaceId occ ty details idinfo)
+              1 -> error "Binary.get(TyClDecl): ForeignType"
+              2 -> do
+                    a1 <- get bh
+                    a2 <- get bh
+                    a3 <- get bh
+                    a4 <- get bh
+                    a5 <- get bh
+                    a6 <- get bh
+                    a7 <- get bh
+                    a8 <- get bh
                     occ <- return $! mkOccNameFS tcName a1
hunk ./compiler/iface/BinIface.hs 1347
-		    return (IfaceData occ a2 a3 a4 a5 a6 a7 a8)
-	      3 -> do
-		    a1 <- get bh
-		    a2 <- get bh
-		    a3 <- get bh
-		    a4 <- get bh
-		    a5 <- get bh
+                    return (IfaceData occ a2 a3 a4 a5 a6 a7 a8)
+              3 -> do
+                    a1 <- get bh
+                    a2 <- get bh
+                    a3 <- get bh
+                    a4 <- get bh
+                    a5 <- get bh
                     occ <- return $! mkOccNameFS tcName a1
hunk ./compiler/iface/BinIface.hs 1355
-		    return (IfaceSyn occ a2 a3 a4 a5)
-	      _ -> do
-		    a1 <- get bh
-		    a2 <- get bh
-		    a3 <- get bh
-		    a4 <- get bh
-		    a5 <- get bh
-		    a6 <- get bh
-		    a7 <- get bh
+                    return (IfaceSyn occ a2 a3 a4 a5)
+              _ -> do
+                    a1 <- get bh
+                    a2 <- get bh
+                    a3 <- get bh
+                    a4 <- get bh
+                    a5 <- get bh
+                    a6 <- get bh
+                    a7 <- get bh
                     occ <- return $! mkOccNameFS clsName a2
hunk ./compiler/iface/BinIface.hs 1365
-		    return (IfaceClass a1 occ a3 a4 a5 a6 a7)
+                    return (IfaceClass a1 occ a3 a4 a5 a6 a7)
 
 instance Binary IfaceInst where
     put_ bh (IfaceInst cls tys dfun flag orph) = do
hunk ./compiler/iface/BinIface.hs 1369
-	    put_ bh cls
-	    put_ bh tys
-	    put_ bh dfun
-	    put_ bh flag
-	    put_ bh orph
+            put_ bh cls
+            put_ bh tys
+            put_ bh dfun
+            put_ bh flag
+            put_ bh orph
     get bh = do cls  <- get bh
hunk ./compiler/iface/BinIface.hs 1375
-		tys  <- get bh
-		dfun <- get bh
-		flag <- get bh
-		orph <- get bh
-		return (IfaceInst cls tys dfun flag orph)
+                tys  <- get bh
+                dfun <- get bh
+                flag <- get bh
+                orph <- get bh
+                return (IfaceInst cls tys dfun flag orph)
 
 instance Binary IfaceFamInst where
     put_ bh (IfaceFamInst fam tys tycon) = do
hunk ./compiler/iface/BinIface.hs 1383
-	    put_ bh fam
-	    put_ bh tys
-	    put_ bh tycon
+            put_ bh fam
+            put_ bh tys
+            put_ bh tycon
     get bh = do fam   <- get bh
hunk ./compiler/iface/BinIface.hs 1387
-		tys   <- get bh
-		tycon <- get bh
-		return (IfaceFamInst fam tys tycon)
+                tys   <- get bh
+                tycon <- get bh
+                return (IfaceFamInst fam tys tycon)
 
 instance Binary OverlapFlag where
     put_ bh NoOverlap  = putByte bh 0
hunk ./compiler/iface/BinIface.hs 1396
     put_ bh OverlapOk  = putByte bh 1
     put_ bh Incoherent = putByte bh 2
     get bh = do h <- getByte bh
-		case h of
-		  0 -> return NoOverlap
-		  1 -> return OverlapOk
-		  2 -> return Incoherent
-		  _ -> panic ("get OverlapFlag " ++ show h)
+                case h of
+                  0 -> return NoOverlap
+                  1 -> return OverlapOk
+                  2 -> return Incoherent
+                  _ -> panic ("get OverlapFlag " ++ show h)
 
 instance Binary IfaceConDecls where
     put_ bh IfAbstractTyCon = putByte bh 0
hunk ./compiler/iface/BinIface.hs 1406
     put_ bh IfOpenDataTyCon = putByte bh 1
     put_ bh (IfDataTyCon cs) = do { putByte bh 2
-				  ; put_ bh cs }
+                                  ; put_ bh cs }
     put_ bh (IfNewTyCon c)  = do { putByte bh 3
hunk ./compiler/iface/BinIface.hs 1408
-				  ; put_ bh c }
+                                  ; put_ bh c }
     get bh = do
hunk ./compiler/iface/BinIface.hs 1410
-	    h <- getByte bh
-	    case h of
-	      0 -> return IfAbstractTyCon
-	      1 -> return IfOpenDataTyCon
-	      2 -> do cs <- get bh
-		      return (IfDataTyCon cs)
-	      _ -> do aa <- get bh
-		      return (IfNewTyCon aa)
+            h <- getByte bh
+            case h of
+              0 -> return IfAbstractTyCon
+              1 -> return IfOpenDataTyCon
+              2 -> do cs <- get bh
+                      return (IfDataTyCon cs)
+              _ -> do aa <- get bh
+                      return (IfNewTyCon aa)
 
 instance Binary IfaceConDecl where
     put_ bh (IfCon a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = do
hunk ./compiler/iface/BinIface.hs 1421
-	    put_ bh a1
-	    put_ bh a2
-	    put_ bh a3
-	    put_ bh a4
-	    put_ bh a5
-	    put_ bh a6
-	    put_ bh a7
-	    put_ bh a8
-	    put_ bh a9
-	    put_ bh a10
+            put_ bh a1
+            put_ bh a2
+            put_ bh a3
+            put_ bh a4
+            put_ bh a5
+            put_ bh a6
+            put_ bh a7
+            put_ bh a8
+            put_ bh a9
+            put_ bh a10
     get bh = do a1 <- get bh
hunk ./compiler/iface/BinIface.hs 1432
-		a2 <- get bh
-		a3 <- get bh	      
-		a4 <- get bh
-		a5 <- get bh
-		a6 <- get bh
-		a7 <- get bh
-		a8 <- get bh
-		a9 <- get bh
-		a10 <- get bh
-	        return (IfCon a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
+                a2 <- get bh
+                a3 <- get bh
+                a4 <- get bh
+                a5 <- get bh
+                a6 <- get bh
+                a7 <- get bh
+                a8 <- get bh
+                a9 <- get bh
+                a10 <- get bh
+                return (IfCon a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
 
 instance Binary IfaceClassOp where
hunk ./compiler/iface/BinIface.hs 1444
-   put_ bh (IfaceClassOp n def ty) = do	
-	put_ bh (occNameFS n)
-	put_ bh def	
-	put_ bh ty
+   put_ bh (IfaceClassOp n def ty) = do
+        put_ bh (occNameFS n)
+        put_ bh def
+        put_ bh ty
    get bh = do
hunk ./compiler/iface/BinIface.hs 1449
-	n <- get bh
-	def <- get bh
-	ty <- get bh
+        n <- get bh
+        def <- get bh
+        ty <- get bh
         occ <- return $! mkOccNameFS varName n
hunk ./compiler/iface/BinIface.hs 1453
-	return (IfaceClassOp occ def ty)
+        return (IfaceClassOp occ def ty)
 
 instance Binary IfaceRule where
     put_ bh (IfaceRule a1 a2 a3 a4 a5 a6 a7 a8) = do
hunk ./compiler/iface/BinIface.hs 1457
-	    put_ bh a1
-	    put_ bh a2
-	    put_ bh a3
-	    put_ bh a4
-	    put_ bh a5
-	    put_ bh a6
-	    put_ bh a7
-	    put_ bh a8
+            put_ bh a1
+            put_ bh a2
+            put_ bh a3
+            put_ bh a4
+            put_ bh a5
+            put_ bh a6
+            put_ bh a7
+            put_ bh a8
     get bh = do
hunk ./compiler/iface/BinIface.hs 1466
-	    a1 <- get bh
-	    a2 <- get bh
-	    a3 <- get bh
-	    a4 <- get bh
-	    a5 <- get bh
-	    a6 <- get bh
-	    a7 <- get bh
-	    a8 <- get bh
-	    return (IfaceRule a1 a2 a3 a4 a5 a6 a7 a8)
+            a1 <- get bh
+            a2 <- get bh
+            a3 <- get bh
+            a4 <- get bh
+            a5 <- get bh
+            a6 <- get bh
+            a7 <- get bh
+            a8 <- get bh
+            return (IfaceRule a1 a2 a3 a4 a5 a6 a7 a8)
 
 instance Binary IfaceAnnotation where
     put_ bh (IfaceAnnotation a1 a2) = do
hunk ./compiler/iface/BinIface.hs 1502
 
 instance Binary IfaceVectInfo where
     put_ bh (IfaceVectInfo a1 a2 a3) = do
-	    put_ bh a1
-	    put_ bh a2
-	    put_ bh a3
+            put_ bh a1
+            put_ bh a2
+            put_ bh a3
     get bh = do
hunk ./compiler/iface/BinIface.hs 1506
-	    a1 <- get bh
-	    a2 <- get bh
-	    a3 <- get bh
-	    return (IfaceVectInfo a1 a2 a3)
+            a1 <- get bh
+            a2 <- get bh
+            a3 <- get bh
+            return (IfaceVectInfo a1 a2 a3)
 
 instance Binary IfaceTrustInfo where
     put_ bh iftrust = putByte bh $ trustInfoToNum iftrust
hunk ./compiler/iface/LoadIface.lhs 10
 
 \begin{code}
 module LoadIface (
-	loadInterface, loadInterfaceForName, loadWiredInHomeIface, 
-	loadSrcInterface, loadSysInterface, loadUserInterface, loadOrphanModules, 
-	findAndReadIface, readIface,	-- Used when reading the module's old interface
-	loadDecls,	-- Should move to TcIface and be renamed
-	initExternalPackageState,
+        loadInterface, loadInterfaceForName, loadWiredInHomeIface,
+        loadSrcInterface, loadSysInterface, loadUserInterface, loadOrphanModules,
+        findAndReadIface, readIface,    -- Used when reading the module's old interface
+        loadDecls,      -- Should move to TcIface and be renamed
+        initExternalPackageState,
 
hunk ./compiler/iface/LoadIface.lhs 16
-	ifaceStats, pprModIface, showIface
+        ifaceStats, pprModIface, showIface
    ) where
 
 #include "HsVersions.h"
hunk ./compiler/iface/LoadIface.lhs 21
 
-import {-# SOURCE #-}	TcIface( tcIfaceDecl, tcIfaceRules, tcIfaceInst, 
-				 tcIfaceFamInst, tcIfaceVectInfo, tcIfaceAnnotations )
+import {-# SOURCE #-}   TcIface( tcIfaceDecl, tcIfaceRules, tcIfaceInst,
+                                 tcIfaceFamInst, tcIfaceVectInfo, tcIfaceAnnotations )
 
 import DynFlags
 import IfaceSyn
hunk ./compiler/iface/LoadIface.lhs 34
 
 import PrelNames
 import PrelInfo
-import MkId	( seqId )
+import MkId     ( seqId )
 import Rules
 import Annotations
 import InstEnv
hunk ./compiler/iface/LoadIface.lhs 59
 
 
 %************************************************************************
-%*									*
-	loadSrcInterface, loadOrphanModules, loadHomeInterface
+%*                                                                      *
+        loadSrcInterface, loadOrphanModules, loadHomeInterface
 
hunk ./compiler/iface/LoadIface.lhs 62
-		These three are called from TcM-land	
-%*									*
+                These three are called from TcM-land
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 67
--- | Load the interface corresponding to an @import@ directive in 
+-- | Load the interface corresponding to an @import@ directive in
 -- source code.  On a failure, fail in the monad with an error message.
 loadSrcInterface :: SDoc
                  -> ModuleName
hunk ./compiler/iface/LoadIface.lhs 87
     Found _ mod -> do
       mb_iface <- initIfaceTcRn $ loadInterface doc mod (ImportByUser want_boot)
       case mb_iface of
-	Failed err      -> failWithTc err
-	Succeeded iface -> return iface
+        Failed err      -> failWithTc err
+        Succeeded iface -> return iface
     err ->
         let dflags = hsc_dflags hsc_env in
hunk ./compiler/iface/LoadIface.lhs 91
-	failWithTc (cannotFindInterface dflags mod err)
+        failWithTc (cannotFindInterface dflags mod err)
 
 -- | Load interfaces for a collection of orphan modules.
hunk ./compiler/iface/LoadIface.lhs 94
-loadOrphanModules :: [Module]	      -- the modules
-		  -> Bool	      -- these are family instance-modules
-		  -> TcM ()
+loadOrphanModules :: [Module]         -- the modules
+                  -> Bool             -- these are family instance-modules
+                  -> TcM ()
 loadOrphanModules mods isFamInstMod
   | null mods = return ()
   | otherwise = initIfaceTcRn $
hunk ./compiler/iface/LoadIface.lhs 100
-		do { traceIf (text "Loading orphan modules:" <+> 
-		     		 fsep (map ppr mods))
-		   ; mapM_ load mods
-		   ; return () }
+                do { traceIf (text "Loading orphan modules:" <+>
+                                 fsep (map ppr mods))
+                   ; mapM_ load mods
+                   ; return () }
   where
     load mod   = loadSysInterface (mk_doc mod) mod
hunk ./compiler/iface/LoadIface.lhs 106
-    mk_doc mod 
+    mk_doc mod
       | isFamInstMod = ppr mod <+> ptext (sLit "is a family-instance module")
       | otherwise    = ppr mod <+> ptext (sLit "is a orphan-instance module")
 
hunk ./compiler/iface/LoadIface.lhs 113
 -- | Loads the interface for a given Name.
 loadInterfaceForName :: SDoc -> Name -> TcRn ModIface
 loadInterfaceForName doc name
-  = do { 
+  = do {
     when debugIsOn $ do
         -- Should not be called with a name from the module being compiled
         { this_mod <- getModule
hunk ./compiler/iface/LoadIface.lhs 119
         ; MASSERT2( not (nameIsLocalOrFrom this_mod name), ppr name <+> parens doc )
         }
-  ; ASSERT2( isExternalName name, ppr name ) 
+  ; ASSERT2( isExternalName name, ppr name )
     initIfaceTcRn $ loadSysInterface doc (nameModule name)
   }
 
hunk ./compiler/iface/LoadIface.lhs 145
 -- | A wrapper for 'loadInterface' that throws an exception if it fails
 loadInterfaceWithException :: SDoc -> Module -> WhereFrom -> IfM lcl ModIface
 loadInterfaceWithException doc mod_name where_from
-  = do	{ mb_iface <- loadInterface doc mod_name where_from
-	; case mb_iface of 
-	    Failed err      -> ghcError (ProgramError (showSDoc err))
-	    Succeeded iface -> return iface }
+  = do  { mb_iface <- loadInterface doc mod_name where_from
+        ; case mb_iface of
+            Failed err      -> ghcError (ProgramError (showSDoc err))
+            Succeeded iface -> return iface }
 \end{code}
 
 
hunk ./compiler/iface/LoadIface.lhs 153
 %*********************************************************
-%*							*
-		loadInterface
+%*                                                      *
+                loadInterface
 
hunk ./compiler/iface/LoadIface.lhs 156
-	The main function to load an interface
-	for an imported module, and put it in
-	the External Package State
-%*							*
+        The main function to load an interface
+        for an imported module, and put it in
+        the External Package State
+%*                                                      *
 %*********************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 164
 loadInterface :: SDoc -> Module -> WhereFrom
-	      -> IfM lcl (MaybeErr Message ModIface)
+              -> IfM lcl (MaybeErr Message ModIface)
 
 -- loadInterface looks in both the HPT and PIT for the required interface
hunk ./compiler/iface/LoadIface.lhs 167
--- If not found, it loads it, and puts it in the PIT (always). 
+-- If not found, it loads it, and puts it in the PIT (always).
 
 -- If it can't find a suitable interface file, we
hunk ./compiler/iface/LoadIface.lhs 170
---	a) modify the PackageIfaceTable to have an empty entry
---		(to avoid repeated complaints)
---	b) return (Left message)
+--      a) modify the PackageIfaceTable to have an empty entry
+--              (to avoid repeated complaints)
+--      b) return (Left message)
 --
 -- It's not necessarily an error for there not to be an interface
hunk ./compiler/iface/LoadIface.lhs 175
--- file -- perhaps the module has changed, and that interface 
+-- file -- perhaps the module has changed, and that interface
 -- is no longer used
 
 loadInterface doc_str mod from
hunk ./compiler/iface/LoadIface.lhs 179
-  = do	{ 	-- Read the state
-	  (eps,hpt) <- getEpsAndHpt
+  = do  {       -- Read the state
+          (eps,hpt) <- getEpsAndHpt
 
hunk ./compiler/iface/LoadIface.lhs 182
-	; traceIf (text "Considering whether to load" <+> ppr mod <+> ppr from)
+        ; traceIf (text "Considering whether to load" <+> ppr mod <+> ppr from)
 
hunk ./compiler/iface/LoadIface.lhs 184
-		-- Check whether we have the interface already
- 	; dflags <- getDOpts
-	; case lookupIfaceByModule dflags hpt (eps_PIT eps) mod of {
-	    Just iface 
-		-> return (Succeeded iface) ;	-- Already loaded
-			-- The (src_imp == mi_boot iface) test checks that the already-loaded
-			-- interface isn't a boot iface.  This can conceivably happen,
-			-- if an earlier import had a before we got to real imports.   I think.
-	    _ -> do {
+                -- Check whether we have the interface already
+        ; dflags <- getDOpts
+        ; case lookupIfaceByModule dflags hpt (eps_PIT eps) mod of {
+            Just iface
+                -> return (Succeeded iface) ;   -- Already loaded
+                        -- The (src_imp == mi_boot iface) test checks that the already-loaded
+                        -- interface isn't a boot iface.  This can conceivably happen,
+                        -- if an earlier import had a before we got to real imports.   I think.
+            _ -> do {
 
hunk ./compiler/iface/LoadIface.lhs 194
-	-- READ THE MODULE IN
-	; read_result <- case (wantHiBootFile dflags eps mod from) of
+        -- READ THE MODULE IN
+        ; read_result <- case (wantHiBootFile dflags eps mod from) of
                            Failed err             -> return (Failed err)
                            Succeeded hi_boot_file -> findAndReadIface doc_str mod hi_boot_file
hunk ./compiler/iface/LoadIface.lhs 198
-	; case read_result of {
-	    Failed err -> do
-	  	{ let fake_iface = emptyModIface mod
+        ; case read_result of {
+            Failed err -> do
+                { let fake_iface = emptyModIface mod
 
hunk ./compiler/iface/LoadIface.lhs 202
-		; updateEps_ $ \eps ->
-			eps { eps_PIT = extendModuleEnv (eps_PIT eps) (mi_module fake_iface) fake_iface }
-			-- Not found, so add an empty iface to 
-			-- the EPS map so that we don't look again
-				
-		; return (Failed err) } ;
+                ; updateEps_ $ \eps ->
+                        eps { eps_PIT = extendModuleEnv (eps_PIT eps) (mi_module fake_iface) fake_iface }
+                        -- Not found, so add an empty iface to
+                        -- the EPS map so that we don't look again
 
hunk ./compiler/iface/LoadIface.lhs 207
-	-- Found and parsed!
-	-- We used to have a sanity check here that looked for:
-	--  * System importing ..
-	--  * a home package module ..
-	--  * that we know nothing about (mb_dep == Nothing)!
-	--
-	-- But this is no longer valid because thNameToGhcName allows users to
-	-- cause the system to load arbitrary interfaces (by supplying an appropriate
-	-- Template Haskell original-name).
-	    Succeeded (iface, file_path) ->
+                ; return (Failed err) } ;
 
hunk ./compiler/iface/LoadIface.lhs 209
-	let 
-	    loc_doc = text file_path
-	in 
-	initIfaceLcl mod loc_doc $ do
+        -- Found and parsed!
+        -- We used to have a sanity check here that looked for:
+        --  * System importing ..
+        --  * a home package module ..
+        --  * that we know nothing about (mb_dep == Nothing)!
+        --
+        -- But this is no longer valid because thNameToGhcName allows users to
+        -- cause the system to load arbitrary interfaces (by supplying an appropriate
+        -- Template Haskell original-name).
+            Succeeded (iface, file_path) ->
+
+        let
+            loc_doc = text file_path
+        in
+        initIfaceLcl mod loc_doc $ do
 
hunk ./compiler/iface/LoadIface.lhs 225
-	-- 	Load the new ModIface into the External Package State
-	-- Even home-package interfaces loaded by loadInterface 
-	-- 	(which only happens in OneShot mode; in Batch/Interactive 
-	--  	mode, home-package modules are loaded one by one into the HPT)
-	-- are put in the EPS.
-	--
-	-- The main thing is to add the ModIface to the PIT, but
-	-- we also take the
-	--	IfaceDecls, IfaceInst, IfaceFamInst, IfaceRules, IfaceVectInfo
-	-- out of the ModIface and put them into the big EPS pools
+        --      Load the new ModIface into the External Package State
+        -- Even home-package interfaces loaded by loadInterface
+        --      (which only happens in OneShot mode; in Batch/Interactive
+        --      mode, home-package modules are loaded one by one into the HPT)
+        -- are put in the EPS.
+        --
+        -- The main thing is to add the ModIface to the PIT, but
+        -- we also take the
+        --      IfaceDecls, IfaceInst, IfaceFamInst, IfaceRules, IfaceVectInfo
+        -- out of the ModIface and put them into the big EPS pools
 
hunk ./compiler/iface/LoadIface.lhs 236
-	-- NB: *first* we do loadDecl, so that the provenance of all the locally-defined
-	---    names is done correctly (notably, whether this is an .hi file or .hi-boot file).
-	--     If we do loadExport first the wrong info gets into the cache (unless we
-	-- 	explicitly tag each export which seems a bit of a bore)
+        -- NB: *first* we do loadDecl, so that the provenance of all the locally-defined
+        ---    names is done correctly (notably, whether this is an .hi file or .hi-boot file).
+        --     If we do loadExport first the wrong info gets into the cache (unless we
+        --      explicitly tag each export which seems a bit of a bore)
 
hunk ./compiler/iface/LoadIface.lhs 241
-	; ignore_prags      <- doptM Opt_IgnoreInterfacePragmas
-	; new_eps_decls     <- loadDecls ignore_prags (mi_decls iface)
-	; new_eps_insts     <- mapM tcIfaceInst (mi_insts iface)
-	; new_eps_fam_insts <- mapM tcIfaceFamInst (mi_fam_insts iface)
-	; new_eps_rules     <- tcIfaceRules ignore_prags (mi_rules iface)
-	; new_eps_anns      <- tcIfaceAnnotations (mi_anns iface)
-        ; new_eps_vect_info <- tcIfaceVectInfo mod (mkNameEnv new_eps_decls) 
+        ; ignore_prags      <- doptM Opt_IgnoreInterfacePragmas
+        ; new_eps_decls     <- loadDecls ignore_prags (mi_decls iface)
+        ; new_eps_insts     <- mapM tcIfaceInst (mi_insts iface)
+        ; new_eps_fam_insts <- mapM tcIfaceFamInst (mi_fam_insts iface)
+        ; new_eps_rules     <- tcIfaceRules ignore_prags (mi_rules iface)
+        ; new_eps_anns      <- tcIfaceAnnotations (mi_anns iface)
+        ; new_eps_vect_info <- tcIfaceVectInfo mod (mkNameEnv new_eps_decls)
                                                (mi_vect_info iface)
 
hunk ./compiler/iface/LoadIface.lhs 250
-	; let {	final_iface = iface {	
-			        mi_decls     = panic "No mi_decls in PIT",
-				mi_insts     = panic "No mi_insts in PIT",
-				mi_fam_insts = panic "No mi_fam_insts in PIT",
-				mi_rules     = panic "No mi_rules in PIT",
-				mi_anns      = panic "No mi_anns in PIT"
+        ; let { final_iface = iface {
+                                mi_decls     = panic "No mi_decls in PIT",
+                                mi_insts     = panic "No mi_insts in PIT",
+                                mi_fam_insts = panic "No mi_fam_insts in PIT",
+                                mi_rules     = panic "No mi_rules in PIT",
+                                mi_anns      = panic "No mi_anns in PIT"
                               }
                }
 
hunk ./compiler/iface/LoadIface.lhs 259
-	; updateEps_  $ \ eps -> 
+        ; updateEps_  $ \ eps ->
            if elemModuleEnv mod (eps_PIT eps) then eps else
hunk ./compiler/iface/LoadIface.lhs 261
-	    eps { 
-	      eps_PIT          = extendModuleEnv (eps_PIT eps) mod final_iface,
-	      eps_PTE          = addDeclsToPTE   (eps_PTE eps) new_eps_decls,
-	      eps_rule_base    = extendRuleBaseList (eps_rule_base eps) 
-						    new_eps_rules,
-	      eps_inst_env     = extendInstEnvList (eps_inst_env eps)  
-						   new_eps_insts,
-	      eps_fam_inst_env = extendFamInstEnvList (eps_fam_inst_env eps)
-						      new_eps_fam_insts,
-              eps_vect_info    = plusVectInfo (eps_vect_info eps) 
+            eps {
+              eps_PIT          = extendModuleEnv (eps_PIT eps) mod final_iface,
+              eps_PTE          = addDeclsToPTE   (eps_PTE eps) new_eps_decls,
+              eps_rule_base    = extendRuleBaseList (eps_rule_base eps)
+                                                    new_eps_rules,
+              eps_inst_env     = extendInstEnvList (eps_inst_env eps)
+                                                   new_eps_insts,
+              eps_fam_inst_env = extendFamInstEnvList (eps_fam_inst_env eps)
+                                                      new_eps_fam_insts,
+              eps_vect_info    = plusVectInfo (eps_vect_info eps)
                                               new_eps_vect_info,
               eps_ann_env      = extendAnnEnvList (eps_ann_env eps)
                                                   new_eps_anns,
hunk ./compiler/iface/LoadIface.lhs 275
               eps_mod_fam_inst_env
-			       = let
-				   fam_inst_env = 
-				     extendFamInstEnvList emptyFamInstEnv
-							  new_eps_fam_insts
-				 in
-				 extendModuleEnv (eps_mod_fam_inst_env eps)
-						 mod
-						 fam_inst_env,
-	      eps_stats        = addEpsInStats (eps_stats eps) 
-					       (length new_eps_decls)
-					       (length new_eps_insts)
-					       (length new_eps_rules) }
+                               = let
+                                   fam_inst_env =
+                                     extendFamInstEnvList emptyFamInstEnv
+                                                          new_eps_fam_insts
+                                 in
+                                 extendModuleEnv (eps_mod_fam_inst_env eps)
+                                                 mod
+                                                 fam_inst_env,
+              eps_stats        = addEpsInStats (eps_stats eps)
+                                               (length new_eps_decls)
+                                               (length new_eps_insts)
+                                               (length new_eps_rules) }
 
hunk ./compiler/iface/LoadIface.lhs 288
-	; return (Succeeded final_iface)
+        ; return (Succeeded final_iface)
     }}}}
 
 wantHiBootFile :: DynFlags -> ExternalPackageState -> Module -> WhereFrom
hunk ./compiler/iface/LoadIface.lhs 292
-	       -> MaybeErr Message IsBootInterface
+               -> MaybeErr Message IsBootInterface
 -- Figure out whether we want Foo.hi or Foo.hi-boot
 wantHiBootFile dflags eps mod from
   = case from of
hunk ./compiler/iface/LoadIface.lhs 296
-       ImportByUser usr_boot 
+       ImportByUser usr_boot
           | usr_boot && not this_package
           -> Failed (badSourceImport mod)
           | otherwise -> Succeeded usr_boot
hunk ./compiler/iface/LoadIface.lhs 304
        ImportBySystem
           | not this_package   -- If the module to be imported is not from this package
           -> Succeeded False   -- don't look it up in eps_is_boot, because that is keyed
-                               -- on the ModuleName of *home-package* modules only. 
+                               -- on the ModuleName of *home-package* modules only.
                                -- We never import boot modules from other packages!
 
           | otherwise
hunk ./compiler/iface/LoadIface.lhs 309
           -> case lookupUFM (eps_is_boot eps) (moduleName mod) of
-		Just (_, is_boot) -> Succeeded is_boot
-                Nothing	          -> Succeeded False
-		     -- The boot-ness of the requested interface, 
-	      	     -- based on the dependencies in directly-imported modules
+                Just (_, is_boot) -> Succeeded is_boot
+                Nothing           -> Succeeded False
+                     -- The boot-ness of the requested interface,
+                     -- based on the dependencies in directly-imported modules
   where
     this_package = thisPackage dflags == modulePackageId mod
 
hunk ./compiler/iface/LoadIface.lhs 328
 review of this decision by SPJ - MCB 10/2008
 
 badDepMsg :: Module -> SDoc
-badDepMsg mod 
+badDepMsg mod
   = hang (ptext (sLit "Interface file inconsistency:"))
hunk ./compiler/iface/LoadIface.lhs 330
-       2 (sep [ptext (sLit "home-package module") <+> quotes (ppr mod) <+> ptext (sLit "is needed,"), 
-	       ptext (sLit "but is not listed in the dependencies of the interfaces directly imported by the module being compiled")])
+       2 (sep [ptext (sLit "home-package module") <+> quotes (ppr mod) <+> ptext (sLit "is needed,"),
+               ptext (sLit "but is not listed in the dependencies of the interfaces directly imported by the module being compiled")])
 -}
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 336
 -----------------------------------------------------
---	Loading type/class/value decls
+--      Loading type/class/value decls
 -- We pass the full Module name here, replete with
 -- its package info, so that we can build a Name for
 -- each binder with the right package info in it
hunk ./compiler/iface/LoadIface.lhs 352
 addDeclsToPTE pte things = extendNameEnvList pte things
 
 loadDecls :: Bool
-	  -> [(Fingerprint, IfaceDecl)]
-	  -> IfL [(Name,TyThing)]
+          -> [(Fingerprint, IfaceDecl)]
+          -> IfL [(Name,TyThing)]
 loadDecls ignore_prags ver_decls
    = do { mod <- getIfModule
hunk ./compiler/iface/LoadIface.lhs 356
- 	; thingss <- mapM (loadDecl ignore_prags mod) ver_decls
-	; return (concat thingss)
-	}
+        ; thingss <- mapM (loadDecl ignore_prags mod) ver_decls
+        ; return (concat thingss)
+        }
 
hunk ./compiler/iface/LoadIface.lhs 360
-loadDecl :: Bool		    -- Don't load pragmas into the decl pool
-	 -> Module
-	  -> (Fingerprint, IfaceDecl)
-	  -> IfL [(Name,TyThing)]   -- The list can be poked eagerly, but the
-				    -- TyThings are forkM'd thunks
+loadDecl :: Bool                    -- Don't load pragmas into the decl pool
+         -> Module
+          -> (Fingerprint, IfaceDecl)
+          -> IfL [(Name,TyThing)]   -- The list can be poked eagerly, but the
+                                    -- TyThings are forkM'd thunks
 loadDecl ignore_prags mod (_version, decl)
hunk ./compiler/iface/LoadIface.lhs 366
-  = do 	{ 	-- Populate the name cache with final versions of all 
-		-- the names associated with the decl
-	  main_name      <- lookupOrig mod (ifName decl)
+  = do  {       -- Populate the name cache with final versions of all
+                -- the names associated with the decl
+          main_name      <- lookupOrig mod (ifName decl)
 --        ; traceIf (text "Loading decl for " <> ppr main_name)
hunk ./compiler/iface/LoadIface.lhs 370
-	; implicit_names <- mapM (lookupOrig mod) (ifaceDeclSubBndrs decl)
+        ; implicit_names <- mapM (lookupOrig mod) (ifaceDeclSubBndrs decl)
 
hunk ./compiler/iface/LoadIface.lhs 372
-	-- Typecheck the thing, lazily
-	-- NB. Firstly, the laziness is there in case we never need the
-	-- declaration (in one-shot mode), and secondly it is there so that 
-	-- we don't look up the occurrence of a name before calling mk_new_bndr
-	-- on the binder.  This is important because we must get the right name
-	-- which includes its nameParent.
+        -- Typecheck the thing, lazily
+        -- NB. Firstly, the laziness is there in case we never need the
+        -- declaration (in one-shot mode), and secondly it is there so that
+        -- we don't look up the occurrence of a name before calling mk_new_bndr
+        -- on the binder.  This is important because we must get the right name
+        -- which includes its nameParent.
 
hunk ./compiler/iface/LoadIface.lhs 379
-	; thing <- forkM doc $ do { bumpDeclStats main_name
-				  ; tcIfaceDecl ignore_prags decl }
+        ; thing <- forkM doc $ do { bumpDeclStats main_name
+                                  ; tcIfaceDecl ignore_prags decl }
 
         -- Populate the type environment with the implicitTyThings too.
hunk ./compiler/iface/LoadIface.lhs 383
-        -- 
+        --
         -- Note [Tricky iface loop]
         -- ~~~~~~~~~~~~~~~~~~~~~~~~
         -- Summary: The delicate point here is that 'mini-env' must be
hunk ./compiler/iface/LoadIface.lhs 391
         -- 'forkM'd by tcIfaceDecl.
         --
         -- In more detail: Consider the example
-        -- 	data T a = MkT { x :: T a }
+        --      data T a = MkT { x :: T a }
         -- The implicitTyThings of T are:  [ <datacon MkT>, <selector x>]
         -- (plus their workers, wrappers, coercions etc etc)
hunk ./compiler/iface/LoadIface.lhs 394
-        -- 
-        -- We want to return an environment 
-        --	[ "MkT" -> <datacon MkT>, "x" -> <selector x>, ... ]
+        --
+        -- We want to return an environment
+        --      [ "MkT" -> <datacon MkT>, "x" -> <selector x>, ... ]
         -- (where the "MkT" is the *Name* associated with MkT, etc.)
         --
         -- We do this by mapping the implict_names to the associated
hunk ./compiler/iface/LoadIface.lhs 411
         --
         -- However, there is a subtlety: due to how type checking needs
         -- to be staged, we can't poke on the forkM'd thunks inside the
-        -- implictTyThings while building this mini-env.  
+        -- implictTyThings while building this mini-env.
         -- If we poke these thunks too early, two problems could happen:
         --    (1) When processing mutually recursive modules across
         --        hs-boot boundaries, poking too early will do the
hunk ./compiler/iface/LoadIface.lhs 419
         --        so things will be type-checked in the wrong
         --        environment, and necessary variables won't be in
         --        scope.
-        --        
+        --
         --    (2) Looking up one OccName in the mini_env will cause
         --        others to be looked up, which might cause that
         --        original one to be looked up again, and hence loop.
hunk ./compiler/iface/LoadIface.lhs 437
 
         -- This mini-env and lookup function mediates between the
         --'Name's n and the map from 'OccName's to the implicit TyThings
-	; let mini_env = mkOccEnv [(getOccName t, t) | t <- implicitTyThings thing]
-	      lookup n = case lookupOccEnv mini_env (getOccName n) of
-			   Just thing -> thing
-			   Nothing    -> 
-			     pprPanic "loadDecl" (ppr main_name <+> ppr n $$ ppr (decl))
+        ; let mini_env = mkOccEnv [(getOccName t, t) | t <- implicitTyThings thing]
+              lookup n = case lookupOccEnv mini_env (getOccName n) of
+                           Just thing -> thing
+                           Nothing    ->
+                             pprPanic "loadDecl" (ppr main_name <+> ppr n $$ ppr (decl))
 
hunk ./compiler/iface/LoadIface.lhs 443
-	; return $ (main_name, thing) :
+        ; return $ (main_name, thing) :
                       -- uses the invariant that implicit_names and
                       -- implictTyThings are bijective
                       [(n, lookup n) | n <- implicit_names]
hunk ./compiler/iface/LoadIface.lhs 447
-	}
+        }
   where
     doc = ptext (sLit "Declaration for") <+> ppr (ifName decl)
 
hunk ./compiler/iface/LoadIface.lhs 451
-bumpDeclStats :: Name -> IfL ()		-- Record that one more declaration has actually been used
+bumpDeclStats :: Name -> IfL ()         -- Record that one more declaration has actually been used
 bumpDeclStats name
hunk ./compiler/iface/LoadIface.lhs 453
-  = do	{ traceIf (text "Loading decl for" <+> ppr name)
-	; updateEps_ (\eps -> let stats = eps_stats eps
-			      in eps { eps_stats = stats { n_decls_out = n_decls_out stats + 1 } })
-	}
+  = do  { traceIf (text "Loading decl for" <+> ppr name)
+        ; updateEps_ (\eps -> let stats = eps_stats eps
+                              in eps { eps_stats = stats { n_decls_out = n_decls_out stats + 1 } })
+        }
 \end{code}
 
 
hunk ./compiler/iface/LoadIface.lhs 461
 %*********************************************************
-%*							*
+%*                                                      *
 \subsection{Reading an interface file}
hunk ./compiler/iface/LoadIface.lhs 463
-%*							*
+%*                                                      *
 %*********************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 468
 findAndReadIface :: SDoc -> Module
-		 -> IsBootInterface	-- True  <=> Look for a .hi-boot file
-					-- False <=> Look for .hi file
-		 -> TcRnIf gbl lcl (MaybeErr Message (ModIface, FilePath))
-	-- Nothing <=> file not found, or unreadable, or illegible
-	-- Just x  <=> successfully found and parsed 
+                 -> IsBootInterface     -- True  <=> Look for a .hi-boot file
+                                        -- False <=> Look for .hi file
+                 -> TcRnIf gbl lcl (MaybeErr Message (ModIface, FilePath))
+        -- Nothing <=> file not found, or unreadable, or illegible
+        -- Just x  <=> successfully found and parsed
 
hunk ./compiler/iface/LoadIface.lhs 474
-	-- It *doesn't* add an error to the monad, because 
-	-- sometimes it's ok to fail... see notes with loadInterface
+        -- It *doesn't* add an error to the monad, because
+        -- sometimes it's ok to fail... see notes with loadInterface
 
 findAndReadIface doc_str mod hi_boot_file
hunk ./compiler/iface/LoadIface.lhs 478
-  = do	{ traceIf (sep [hsep [ptext (sLit "Reading"), 
-			      if hi_boot_file 
-				then ptext (sLit "[boot]") 
-				else empty,
-			      ptext (sLit "interface for"), 
-			      ppr mod <> semi],
-		        nest 4 (ptext (sLit "reason:") <+> doc_str)])
+  = do  { traceIf (sep [hsep [ptext (sLit "Reading"),
+                              if hi_boot_file
+                                then ptext (sLit "[boot]")
+                                else empty,
+                              ptext (sLit "interface for"),
+                              ppr mod <> semi],
+                        nest 4 (ptext (sLit "reason:") <+> doc_str)])
 
hunk ./compiler/iface/LoadIface.lhs 486
-	-- Check for GHC.Prim, and return its static interface
-	; dflags <- getDOpts
-	; if mod == gHC_PRIM
-	  then return (Succeeded (ghcPrimIface,
-				   "<built in interface for GHC.Prim>"))
-	  else do
+        -- Check for GHC.Prim, and return its static interface
+        ; dflags <- getDOpts
+        ; if mod == gHC_PRIM
+          then return (Succeeded (ghcPrimIface,
+                                   "<built in interface for GHC.Prim>"))
+          else do
 
hunk ./compiler/iface/LoadIface.lhs 493
-	-- Look for the file
-	; hsc_env <- getTopEnv
-	; mb_found <- liftIO (findExactModule hsc_env mod)
-	; case mb_found of {
-              
-	      Found loc mod -> do 
+        -- Look for the file
+        ; hsc_env <- getTopEnv
+        ; mb_found <- liftIO (findExactModule hsc_env mod)
+        ; case mb_found of {
 
hunk ./compiler/iface/LoadIface.lhs 498
-	-- Found file, so read it
-	{ let { file_path = addBootSuffix_maybe hi_boot_file (ml_hi_file loc) }
+              Found loc mod -> do
+
+        -- Found file, so read it
+        { let { file_path = addBootSuffix_maybe hi_boot_file (ml_hi_file loc) }
 
         -- If the interface is in the current package then if we could
         -- load it would already be in the HPT and we assume that our
hunk ./compiler/iface/LoadIface.lhs 512
             else do {
 
         ; traceIf (ptext (sLit "readIFace") <+> text file_path)
-	; read_result <- readIface mod file_path hi_boot_file
-	; case read_result of
-	    Failed err -> return (Failed (badIfaceFile file_path err))
-	    Succeeded iface 
-		| mi_module iface /= mod ->
-		  return (Failed (wrongIfaceModErr iface mod file_path))
-		| otherwise ->
-		  return (Succeeded (iface, file_path))
-			-- Don't forget to fill in the package name...
-	}}
-	    ; err -> do
-		{ traceIf (ptext (sLit "...not found"))
-		; dflags <- getDOpts
-		; return (Failed (cannotFindInterface dflags 
-					(moduleName mod) err)) }
+        ; read_result <- readIface mod file_path hi_boot_file
+        ; case read_result of
+            Failed err -> return (Failed (badIfaceFile file_path err))
+            Succeeded iface
+                | mi_module iface /= mod ->
+                  return (Failed (wrongIfaceModErr iface mod file_path))
+                | otherwise ->
+                  return (Succeeded (iface, file_path))
+                        -- Don't forget to fill in the package name...
+        }}
+            ; err -> do
+                { traceIf (ptext (sLit "...not found"))
+                ; dflags <- getDOpts
+                ; return (Failed (cannotFindInterface dflags
+                                        (moduleName mod) err)) }
         }
         }
 \end{code}
hunk ./compiler/iface/LoadIface.lhs 534
 @readIface@ tries just the one file.
 
 \begin{code}
-readIface :: Module -> FilePath -> IsBootInterface 
-	  -> TcRnIf gbl lcl (MaybeErr Message ModIface)
-	-- Failed err    <=> file not found, or unreadable, or illegible
-	-- Succeeded iface <=> successfully found and parsed 
+readIface :: Module -> FilePath -> IsBootInterface
+          -> TcRnIf gbl lcl (MaybeErr Message ModIface)
+        -- Failed err    <=> file not found, or unreadable, or illegible
+        -- Succeeded iface <=> successfully found and parsed
 
 readIface wanted_mod file_path _
hunk ./compiler/iface/LoadIface.lhs 540
-  = do	{ res <- tryMostM $
+  = do  { res <- tryMostM $
                  readBinIface CheckHiWay QuietBinIFaceReading file_path
hunk ./compiler/iface/LoadIface.lhs 542
-	; case res of
-	    Right iface 
-		| wanted_mod == actual_mod -> return (Succeeded iface)
-		| otherwise	  	   -> return (Failed err)
-		where
-		  actual_mod = mi_module iface
-		  err = hiModuleNameMismatchWarn wanted_mod actual_mod
+        ; case res of
+            Right iface
+                | wanted_mod == actual_mod -> return (Succeeded iface)
+                | otherwise                -> return (Failed err)
+                where
+                  actual_mod = mi_module iface
+                  err = hiModuleNameMismatchWarn wanted_mod actual_mod
 
hunk ./compiler/iface/LoadIface.lhs 550
-	    Left exn    -> return (Failed (text (showException exn)))
+            Left exn    -> return (Failed (text (showException exn)))
     }
 \end{code}
 
hunk ./compiler/iface/LoadIface.lhs 556
 
 %*********************************************************
-%*						 	 *
-	Wired-in interface for GHC.Prim
-%*							 *
+%*                                                       *
+        Wired-in interface for GHC.Prim
+%*                                                       *
 %*********************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 564
 initExternalPackageState :: ExternalPackageState
 initExternalPackageState
-  = EPS { 
+  = EPS {
       eps_is_boot      = emptyUFM,
       eps_PIT          = emptyPackageIfaceTable,
       eps_PTE          = emptyTypeEnv,
hunk ./compiler/iface/LoadIface.lhs 571
       eps_inst_env     = emptyInstEnv,
       eps_fam_inst_env = emptyFamInstEnv,
       eps_rule_base    = mkRuleBase builtinRules,
-	-- Initialise the EPS rule pool with the built-in rules
+        -- Initialise the EPS rule pool with the built-in rules
       eps_mod_fam_inst_env
                        = emptyModuleEnv,
       eps_vect_info    = noVectInfo,
hunk ./compiler/iface/LoadIface.lhs 577
       eps_ann_env      = emptyAnnEnv,
       eps_stats = EpsStats { n_ifaces_in = 0, n_decls_in = 0, n_decls_out = 0
-			   , n_insts_in = 0, n_insts_out = 0
-			   , n_rules_in = length builtinRules, n_rules_out = 0 }
+                           , n_insts_in = 0, n_insts_out = 0
+                           , n_rules_in = length builtinRules, n_rules_out = 0 }
     }
 \end{code}
 
hunk ./compiler/iface/LoadIface.lhs 584
 
 %*********************************************************
-%*						 	 *
-	Wired-in interface for GHC.Prim
-%*							 *
+%*                                                       *
+        Wired-in interface for GHC.Prim
+%*                                                       *
 %*********************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 593
 ghcPrimIface :: ModIface
 ghcPrimIface
   = (emptyModIface gHC_PRIM) {
-	mi_exports  = [(gHC_PRIM, ghcPrimExports)],
-	mi_decls    = [],
-	mi_fixities = fixities,
-	mi_fix_fn  = mkIfaceFixCache fixities
-    }		
+        mi_exports  = [(gHC_PRIM, ghcPrimExports)],
+        mi_decls    = [],
+        mi_fixities = fixities,
+        mi_fix_fn  = mkIfaceFixCache fixities
+    }
   where
     fixities = [(getOccName seqId, Fixity 0 InfixR)]
hunk ./compiler/iface/LoadIface.lhs 600
-			-- seq is infixr 0
+                        -- seq is infixr 0
 \end{code}
 
 %*********************************************************
hunk ./compiler/iface/LoadIface.lhs 604
-%*							*
+%*                                                      *
 \subsection{Statistics}
hunk ./compiler/iface/LoadIface.lhs 606
-%*							*
+%*                                                      *
 %*********************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 611
 ifaceStats :: ExternalPackageState -> SDoc
-ifaceStats eps 
+ifaceStats eps
   = hcat [text "Renamer stats: ", msg]
   where
     stats = eps_stats eps
hunk ./compiler/iface/LoadIface.lhs 615
-    msg = vcat 
-    	[int (n_ifaces_in stats) <+> text "interfaces read",
-    	 hsep [ int (n_decls_out stats), text "type/class/variable imported, out of", 
-    	        int (n_decls_in stats), text "read"],
-    	 hsep [ int (n_insts_out stats), text "instance decls imported, out of",  
-    	        int (n_insts_in stats), text "read"],
-    	 hsep [ int (n_rules_out stats), text "rule decls imported, out of",  
-    	        int (n_rules_in stats), text "read"]
-	]
+    msg = vcat
+        [int (n_ifaces_in stats) <+> text "interfaces read",
+         hsep [ int (n_decls_out stats), text "type/class/variable imported, out of",
+                int (n_decls_in stats), text "read"],
+         hsep [ int (n_insts_out stats), text "instance decls imported, out of",
+                int (n_insts_in stats), text "read"],
+         hsep [ int (n_rules_out stats), text "rule decls imported, out of",
+                int (n_rules_in stats), text "read"]
+        ]
 \end{code}
 
 
hunk ./compiler/iface/LoadIface.lhs 628
 %************************************************************************
-%*				 					*
-		Printing interfaces
-%*				 					*
+%*                                                                      *
+                Printing interfaces
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 649
 -- Show a ModIface
 pprModIface iface
  = vcat [ ptext (sLit "interface")
-		<+> ppr (mi_module iface) <+> pp_boot
-		<+> (if mi_orphan iface then ptext (sLit "[orphan module]") else empty)
-		<+> (if mi_finsts iface then ptext (sLit "[family instance module]") else empty)
-		<+> (if mi_hpc    iface then ptext (sLit "[hpc]") else empty)
-		<+> integer opt_HiVersion
+                <+> ppr (mi_module iface) <+> pp_boot
+                <+> (if mi_orphan iface then ptext (sLit "[orphan module]") else empty)
+                <+> (if mi_finsts iface then ptext (sLit "[family instance module]") else empty)
+                <+> (if mi_hpc    iface then ptext (sLit "[hpc]") else empty)
+                <+> integer opt_HiVersion
         , nest 2 (text "interface hash:" <+> ppr (mi_iface_hash iface))
         , nest 2 (text "ABI hash:" <+> ppr (mi_mod_hash iface))
         , nest 2 (text "export-list hash:" <+> ppr (mi_exp_hash iface))
hunk ./compiler/iface/LoadIface.lhs 659
         , nest 2 (text "orphan hash:" <+> ppr (mi_orphan_hash iface))
         , nest 2 (ptext (sLit "where"))
-	, vcat (map pprExport (mi_exports iface))
-	, pprDeps (mi_deps iface)
-	, vcat (map pprUsage (mi_usages iface))
-	, vcat (map pprIfaceAnnotation (mi_anns iface))
-	, pprFixities (mi_fixities iface)
-	, vcat (map pprIfaceDecl (mi_decls iface))
-	, vcat (map ppr (mi_insts iface))
-	, vcat (map ppr (mi_fam_insts iface))
-	, vcat (map ppr (mi_rules iface))
+        , vcat (map pprExport (mi_exports iface))
+        , pprDeps (mi_deps iface)
+        , vcat (map pprUsage (mi_usages iface))
+        , vcat (map pprIfaceAnnotation (mi_anns iface))
+        , pprFixities (mi_fixities iface)
+        , vcat (map pprIfaceDecl (mi_decls iface))
+        , vcat (map ppr (mi_insts iface))
+        , vcat (map ppr (mi_fam_insts iface))
+        , vcat (map ppr (mi_rules iface))
         , pprVectInfo (mi_vect_info iface)
         , pprVectInfo (mi_vect_info iface)
hunk ./compiler/iface/LoadIface.lhs 670
-	, ppr (mi_warns iface)
-	, pprTrustInfo (mi_trust iface)
- 	]
+        , ppr (mi_warns iface)
+        , pprTrustInfo (mi_trust iface)
+        ]
   where
     pp_boot | mi_boot iface = ptext (sLit "[boot]")
hunk ./compiler/iface/LoadIface.lhs 675
-	    | otherwise     = empty
+            | otherwise     = empty
 \end{code}
 
 When printing export lists, we print like this:
hunk ./compiler/iface/LoadIface.lhs 679
-	Avail   f		f
-	AvailTC C [C, x, y]	C(x,y)
-	AvailTC C [x, y]	C!(x,y)		-- Exporting x, y but not C
+        Avail   f               f
+        AvailTC C [C, x, y]     C(x,y)
+        AvailTC C [x, y]        C!(x,y)         -- Exporting x, y but not C
 
 \begin{code}
 pprExport :: IfaceExport -> SDoc
hunk ./compiler/iface/LoadIface.lhs 691
     pp_avail :: GenAvailInfo OccName -> SDoc
     pp_avail (Avail occ)    = ppr occ
     pp_avail (AvailTC _ []) = empty
-    pp_avail (AvailTC n (n':ns)) 
-	| n==n'     = ppr n <> pp_export ns
- 	| otherwise = ppr n <> char '|' <> pp_export (n':ns)
-    
+    pp_avail (AvailTC n (n':ns))
+        | n==n'     = ppr n <> pp_export ns
+        | otherwise = ppr n <> char '|' <> pp_export (n':ns)
+
     pp_export []    = empty
     pp_export names = braces (hsep (map ppr names))
 
hunk ./compiler/iface/LoadIface.lhs 704
 pprUsage usage@UsageHomeModule{}
   = pprUsageImport usage usg_mod_name $$
     nest 2 (
-	maybe empty (\v -> text "exports: " <> ppr v) (usg_exports usage) $$
+        maybe empty (\v -> text "exports: " <> ppr v) (usg_exports usage) $$
         vcat [ ppr n <+> ppr v | (n,v) <- usg_entities usage ]
         )
 
hunk ./compiler/iface/LoadIface.lhs 718
 
 pprDeps :: Dependencies -> SDoc
 pprDeps (Deps { dep_mods = mods, dep_pkgs = pkgs, dep_orphs = orphs,
-		dep_finsts = finsts })
+                dep_finsts = finsts })
   = vcat [ptext (sLit "module dependencies:") <+> fsep (map ppr_mod mods),
hunk ./compiler/iface/LoadIface.lhs 720
-	  ptext (sLit "package dependencies:") <+> fsep (map ppr pkgs), 
-	  ptext (sLit "orphans:") <+> fsep (map ppr orphs),
-	  ptext (sLit "family instance modules:") <+> fsep (map ppr finsts)
-	]
+          ptext (sLit "package dependencies:") <+> fsep (map ppr pkgs),
+          ptext (sLit "orphans:") <+> fsep (map ppr orphs),
+          ptext (sLit "family instance modules:") <+> fsep (map ppr finsts)
+        ]
   where
     ppr_mod (mod_name, boot) = ppr mod_name <+> ppr_boot boot
     ppr_boot True  = text "[boot]"
hunk ./compiler/iface/LoadIface.lhs 736
 pprFixities :: [(OccName, Fixity)] -> SDoc
 pprFixities []    = empty
 pprFixities fixes = ptext (sLit "fixities") <+> pprWithCommas pprFix fixes
-		  where
-		    pprFix (occ,fix) = ppr fix <+> ppr occ 
+                  where
+                    pprFix (occ,fix) = ppr fix <+> ppr occ
 
 pprVectInfo :: IfaceVectInfo -> SDoc
 pprVectInfo (IfaceVectInfo { ifaceVectInfoVar        = vars
hunk ./compiler/iface/LoadIface.lhs 743
                            , ifaceVectInfoTyCon      = tycons
                            , ifaceVectInfoTyConReuse = tyconsReuse
-                           }) = 
-  vcat 
+                           }) =
+  vcat
   [ ptext (sLit "vectorised variables:") <+> hsep (map ppr vars)
   , ptext (sLit "vectorised tycons:") <+> hsep (map ppr tycons)
   , ptext (sLit "vectorised reused tycons:") <+> hsep (map ppr tyconsReuse)
hunk ./compiler/iface/LoadIface.lhs 757
     ppr = pprWarns
 
 pprWarns :: Warnings -> SDoc
-pprWarns NoWarnings	    = empty
+pprWarns NoWarnings         = empty
 pprWarns (WarnAll txt)  = ptext (sLit "Warn all") <+> ppr txt
 pprWarns (WarnSome prs) = ptext (sLit "Warnings")
                         <+> vcat (map pprWarning prs)
hunk ./compiler/iface/LoadIface.lhs 770
 
 
 %*********************************************************
-%*						 	 *
+%*                                                       *
 \subsection{Errors}
hunk ./compiler/iface/LoadIface.lhs 772
-%*							 *
+%*                                                       *
 %*********************************************************
 
 \begin{code}
hunk ./compiler/iface/LoadIface.lhs 778
 badIfaceFile :: String -> SDoc -> SDoc
 badIfaceFile file err
-  = vcat [ptext (sLit "Bad interface file:") <+> text file, 
-	  nest 4 err]
+  = vcat [ptext (sLit "Bad interface file:") <+> text file,
+          nest 4 err]
 
 hiModuleNameMismatchWarn :: Module -> Module -> Message
hunk ./compiler/iface/LoadIface.lhs 782
-hiModuleNameMismatchWarn requested_mod read_mod = 
+hiModuleNameMismatchWarn requested_mod read_mod =
   withPprStyle defaultUserStyle $
     -- we want the Modules below to be qualified with package names,
     -- so reset the PrintUnqualified setting.
hunk ./compiler/iface/LoadIface.lhs 787
     hsep [ ptext (sLit "Something is amiss; requested module ")
-	 , ppr requested_mod
-	 , ptext (sLit "differs from name found in the interface file")
-   	 , ppr read_mod
-  	 ]
+         , ppr requested_mod
+         , ptext (sLit "differs from name found in the interface file")
+         , ppr read_mod
+         ]
 
 wrongIfaceModErr :: ModIface -> Module -> String -> SDoc
hunk ./compiler/iface/LoadIface.lhs 793
-wrongIfaceModErr iface mod_name file_path 
+wrongIfaceModErr iface mod_name file_path
   = sep [ptext (sLit "Interface file") <+> iface_file,
          ptext (sLit "contains module") <+> quotes (ppr (mi_module iface)) <> comma,
          ptext (sLit "but we were expecting module") <+> quotes (ppr mod_name),
hunk ./compiler/iface/LoadIface.lhs 797
-	 sep [ptext (sLit "Probable cause: the source code which generated"),
-	     nest 2 iface_file,
-	     ptext (sLit "has an incompatible module name")
-	    ]
-	]
+         sep [ptext (sLit "Probable cause: the source code which generated"),
+             nest 2 iface_file,
+             ptext (sLit "has an incompatible module name")
+            ]
+        ]
   where iface_file = doubleQuotes (text file_path)
 
 homeModError :: Module -> ModLocation -> SDoc
hunk ./compiler/iface/MkIface.lhs 7
 %
 
 \begin{code}
-module MkIface ( 
+module MkIface (
         mkUsedNames,
         mkDependencies,
hunk ./compiler/iface/MkIface.lhs 10
-        mkIface,        -- Build a ModIface from a ModGuts, 
+        mkIface,        -- Build a ModIface from a ModGuts,
                         -- including computing version information
 
         mkIfaceTc,
hunk ./compiler/iface/MkIface.lhs 36
 Please read the above page for a top-down description of how this all
 works.  Notes below cover specific issues related to the implementation.
 
-Basic idea: 
+Basic idea:
 
hunk ./compiler/iface/MkIface.lhs 38
-  * In the mi_usages information in an interface, we record the 
+  * In the mi_usages information in an interface, we record the
     fingerprint of each free variable of the module
 
   * In mkIface, we compute the fingerprint of each exported thing A.f.
hunk ./compiler/iface/MkIface.lhs 125
                                 --          to write it
 
 mkIface hsc_env maybe_old_fingerprint mod_details
-         ModGuts{     mg_module    = this_mod,
-		      mg_boot      = is_boot,
-		      mg_used_names = used_names,
-		      mg_deps      = deps,
-                      mg_dir_imps  = dir_imp_mods,
-		      mg_rdr_env   = rdr_env,
-		      mg_fix_env   = fix_env,
-		      mg_warns   = warns,
-	              mg_hpc_info  = hpc_info }
+         ModGuts{     mg_module     = this_mod,
+                      mg_boot       = is_boot,
+                      mg_used_names = used_names,
+                      mg_deps       = deps,
+                      mg_dir_imps   = dir_imp_mods,
+                      mg_rdr_env    = rdr_env,
+                      mg_fix_env    = fix_env,
+                      mg_warns      = warns,
+                      mg_hpc_info   = hpc_info }
         = mkIface_ hsc_env maybe_old_fingerprint
hunk ./compiler/iface/MkIface.lhs 135
-                   this_mod is_boot used_names deps rdr_env 
+                   this_mod is_boot used_names deps rdr_env
                    fix_env warns hpc_info dir_imp_mods mod_details
 
 -- | make an interface from the results of typechecking only.  Useful
hunk ./compiler/iface/MkIface.lhs 142
 -- for non-optimising compilation, or where we aren't generating any
 -- object code at all ('HscNothing').
 mkIfaceTc :: HscEnv
-          -> Maybe Fingerprint	-- The old fingerprint, if we have it
-          -> ModDetails		-- gotten from mkBootModDetails, probably
-          -> TcGblEnv		-- Usages, deprecations, etc
-	  -> IO (Messages, Maybe (ModIface, Bool))
+          -> Maybe Fingerprint -- The old fingerprint, if we have it
+          -> ModDetails        -- gotten from mkBootModDetails, probably
+          -> TcGblEnv          -- Usages, deprecations, etc
+          -> IO (Messages, Maybe (ModIface, Bool))
 mkIfaceTc hsc_env maybe_old_fingerprint mod_details
hunk ./compiler/iface/MkIface.lhs 147
-  tc_result@TcGblEnv{ tcg_mod = this_mod,
-                      tcg_src = hsc_src,
+  tc_result@TcGblEnv{ tcg_mod     = this_mod,
+                      tcg_src     = hsc_src,
                       tcg_imports = imports,
                       tcg_rdr_env = rdr_env,
                       tcg_fix_env = fix_env,
hunk ./compiler/iface/MkIface.lhs 152
-                      tcg_warns = warns,
-                      tcg_hpc = other_hpc_info
-                    }
+                      tcg_warns   = warns,
+                      tcg_hpc     = other_hpc_info }
   = do
hunk ./compiler/iface/MkIface.lhs 155
-          let used_names = mkUsedNames tc_result
-          deps <- mkDependencies tc_result
-          let hpc_info = emptyHpcInfo other_hpc_info
-          mkIface_ hsc_env maybe_old_fingerprint
-                   this_mod (isHsBoot hsc_src) used_names deps rdr_env 
-                   fix_env warns hpc_info (imp_mods imports) mod_details
-        
+      let used_names = mkUsedNames tc_result
+      deps <- mkDependencies tc_result
+      let hpc_info = emptyHpcInfo other_hpc_info
+      mkIface_ hsc_env maybe_old_fingerprint
+               this_mod (isHsBoot hsc_src) used_names deps rdr_env
+               fix_env warns hpc_info (imp_mods imports) mod_details
+
 
 mkUsedNames :: TcGblEnv -> NameSet
 mkUsedNames TcGblEnv{ tcg_dus = dus } = allUses dus
hunk ./compiler/iface/MkIface.lhs 165
-        
+
 mkDependencies :: TcGblEnv -> IO Dependencies
 mkDependencies
hunk ./compiler/iface/MkIface.lhs 168
-          TcGblEnv{ tcg_mod = mod,
+          TcGblEnv{ tcg_mod     = mod,
                     tcg_imports = imports,
hunk ./compiler/iface/MkIface.lhs 170
-                    tcg_th_used = th_var
-                  }
- = do 
-      th_used   <- readIORef th_var                     -- Whether TH is used
+                    tcg_th_used = th_var }
+ = do
+      th_used   <- readIORef th_var -- Whether TH is used
       let
         dep_mods = eltsUFM (delFromUFM (imp_dep_mods imports) (moduleName mod))
                 -- M.hi-boot can be in the imp_dep_mods, but we must remove
hunk ./compiler/iface/MkIface.lhs 177
                 -- it before recording the modules on which this one depends!
-                -- (We want to retain M.hi-boot in imp_dep_mods so that 
-                --  loadHiBootInterface can see if M's direct imports depend 
-                --  on M.hi-boot, and hence that we should do the hi-boot consistency 
+                -- (We want to retain M.hi-boot in imp_dep_mods so that
+                --  loadHiBootInterface can see if M's direct imports depend
+                --  on M.hi-boot, and hence that we should do the hi-boot consistency
                 --  check.)
 
         pkgs | th_used   = insertList thPackageId (imp_dep_pkgs imports)
hunk ./compiler/iface/MkIface.lhs 185
              | otherwise = imp_dep_pkgs imports
 
-      return Deps { dep_mods   = sortBy (stableModuleNameCmp `on` fst) dep_mods,
-                    dep_pkgs   = sortBy stablePackageIdCmp pkgs,
-                    dep_orphs  = sortBy stableModuleCmp (imp_orphs  imports),
-                    dep_finsts = sortBy stableModuleCmp (imp_finsts imports) }
+      return Deps{ dep_mods   = sortBy (stableModuleNameCmp `on` fst) dep_mods,
+                   dep_pkgs   = sortBy stablePackageIdCmp pkgs,
+                   dep_orphs  = sortBy stableModuleCmp (imp_orphs  imports),
+                   dep_finsts = sortBy stableModuleCmp (imp_finsts imports) }
                 -- sort to get into canonical order
                 -- NB. remember to use lexicographic ordering
 
hunk ./compiler/iface/MkIface.lhs 197
          -> NameEnv FixItem -> Warnings -> HpcInfo
          -> ImportedMods
          -> ModDetails
-	 -> IO (Messages, Maybe (ModIface, Bool))
-mkIface_ hsc_env maybe_old_fingerprint 
+         -> IO (Messages, Maybe (ModIface, Bool))
+mkIface_ hsc_env maybe_old_fingerprint
          this_mod is_boot used_names deps rdr_env fix_env src_warns hpc_info
          dir_imp_mods
hunk ./compiler/iface/MkIface.lhs 201
-	 ModDetails{  md_insts 	   = insts, 
-		      md_fam_insts = fam_insts,
-		      md_rules 	   = rules,
-		      md_anns	   = anns,
+         ModDetails{  md_insts     = insts,
+                      md_fam_insts = fam_insts,
+                      md_rules     = rules,
+                      md_anns      = anns,
                       md_vect_info = vect_info,
hunk ./compiler/iface/MkIface.lhs 206
-		      md_types 	   = type_env,
-		      md_exports   = exports }
--- NB:	notice that mkIface does not look at the bindings
---	only at the TypeEnv.  The previous Tidy phase has
---	put exactly the info into the TypeEnv that we want
---	to expose in the interface
+                      md_types     = type_env,
+                      md_exports   = exports }
+-- NB:  notice that mkIface does not look at the bindings
+--      only at the TypeEnv.  The previous Tidy phase has
+--      put exactly the info into the TypeEnv that we want
+--      to expose in the interface
 
hunk ./compiler/iface/MkIface.lhs 213
-  = do	{ usages <- mkUsageInfo hsc_env this_mod dir_imp_mods used_names
+  = do  { usages <- mkUsageInfo hsc_env this_mod dir_imp_mods used_names
 
hunk ./compiler/iface/MkIface.lhs 215
-	; let	{ entities = typeEnvElts type_env ;
+        ; let   { entities = typeEnvElts type_env ;
                   decls  = [ tyThingToIfaceDecl entity
hunk ./compiler/iface/MkIface.lhs 217
-			   | entity <- entities,
-			     let name = getName entity,
+                           | entity <- entities,
+                             let name = getName entity,
                              not (isImplicitTyThing entity),
hunk ./compiler/iface/MkIface.lhs 220
-	                        -- No implicit Ids and class tycons in the interface file
-			     not (isWiredInName name),
-	                        -- Nor wired-in things; the compiler knows about them anyhow
-			     nameIsLocalOrFrom this_mod name  ]
-				-- Sigh: see Note [Root-main Id] in TcRnDriver
+                                -- No implicit Ids and class tycons in the interface file
+                             not (isWiredInName name),
+                                -- Nor wired-in things; the compiler knows about them anyhow
+                             nameIsLocalOrFrom this_mod name  ]
+                                -- Sigh: see Note [Root-main Id] in TcRnDriver
 
hunk ./compiler/iface/MkIface.lhs 226
-		; fixities    = [(occ,fix) | FixItem occ fix <- nameEnvElts fix_env]
-		; warns     = src_warns
-		; iface_rules = map (coreRuleToIfaceRule this_mod) rules
-		; iface_insts = map instanceToIfaceInst insts
-		; iface_fam_insts = map famInstToIfaceFamInst fam_insts
+                ; fixities    = [(occ,fix) | FixItem occ fix <- nameEnvElts fix_env]
+                ; warns       = src_warns
+                ; iface_rules = map (coreRuleToIfaceRule this_mod) rules
+                ; iface_insts = map instanceToIfaceInst insts
+                ; iface_fam_insts = map famInstToIfaceFamInst fam_insts
                 ; iface_vect_info = flattenVectInfo vect_info
hunk ./compiler/iface/MkIface.lhs 232
-                ; trust_info = (setSafeMode . safeHaskell . hsc_dflags) hsc_env
+                ; trust_info  = (setSafeMode . safeHaskell . hsc_dflags) hsc_env
+
+                ; intermediate_iface = ModIface {
+                        mi_module  = this_mod,
+                        mi_boot    = is_boot,
+                        mi_deps    = deps,
+                        mi_usages  = usages,
+                        mi_exports = mkIfaceExports exports,
 
hunk ./compiler/iface/MkIface.lhs 241
-	        ; intermediate_iface = ModIface { 
-			mi_module   = this_mod,
-			mi_boot     = is_boot,
-			mi_deps     = deps,
-			mi_usages   = usages,
-			mi_exports  = mkIfaceExports exports,
-	
-			-- Sort these lexicographically, so that
-			-- the result is stable across compilations
-			mi_insts    = sortLe le_inst iface_insts,
-			mi_fam_insts= sortLe le_fam_inst iface_fam_insts,
-			mi_rules    = sortLe le_rule iface_rules,
+                        -- Sort these lexicographically, so that
+                        -- the result is stable across compilations
+                        mi_insts     = sortLe le_inst iface_insts,
+                        mi_fam_insts = sortLe le_fam_inst iface_fam_insts,
+                        mi_rules     = sortLe le_rule iface_rules,
 
                         mi_vect_info = iface_vect_info,
 
hunk ./compiler/iface/MkIface.lhs 249
-			mi_fixities = fixities,
-			mi_warns  = warns,
-			mi_anns     = mkIfaceAnnotations anns,
-			mi_globals  = Just rdr_env,
+                        mi_fixities = fixities,
+                        mi_warns    = warns,
+                        mi_anns     = mkIfaceAnnotations anns,
+                        mi_globals  = Just rdr_env,
 
hunk ./compiler/iface/MkIface.lhs 254
-			-- Left out deliberately: filled in by addVersionInfo
-			mi_iface_hash = fingerprint0,
-			mi_mod_hash  = fingerprint0,
- 			mi_exp_hash  = fingerprint0,
- 			mi_orphan_hash = fingerprint0,
-			mi_orphan    = False,	-- Always set by addVersionInfo, but
-						-- it's a strict field, so we can't omit it.
-                        mi_finsts    = False,   -- Ditto
-			mi_decls     = deliberatelyOmitted "decls",
-			mi_hash_fn   = deliberatelyOmitted "hash_fn",
-			mi_hpc       = isHpcUsed hpc_info,
-			mi_trust     = trust_info,
+                        -- Left out deliberately: filled in by addVersionInfo
+                        mi_iface_hash  = fingerprint0,
+                        mi_mod_hash    = fingerprint0,
+                        mi_exp_hash    = fingerprint0,
+                        mi_orphan_hash = fingerprint0,
+                        mi_orphan      = False, -- Always set by addVersionInfo, but
+                                                -- it's a strict field, so we can't omit it.
+                        mi_finsts      = False, -- Ditto
+                        mi_decls       = deliberatelyOmitted "decls",
+                        mi_hash_fn     = deliberatelyOmitted "hash_fn",
+                        mi_hpc         = isHpcUsed hpc_info,
+                        mi_trust       = trust_info,
 
hunk ./compiler/iface/MkIface.lhs 267
-			-- And build the cached values
-			mi_warn_fn = mkIfaceWarnCache warns,
-			mi_fix_fn = mkIfaceFixCache fixities }
-		}
+                        -- And build the cached values
+                        mi_warn_fn = mkIfaceWarnCache warns,
+                        mi_fix_fn  = mkIfaceFixCache fixities }
+                }
 
hunk ./compiler/iface/MkIface.lhs 272
-        ; (new_iface, no_change_at_all) 
-	        <- {-# SCC "versioninfo" #-}
-			 addFingerprints hsc_env maybe_old_fingerprint
+        ; (new_iface, no_change_at_all)
+                <- {-# SCC "versioninfo" #-}
+                         addFingerprints hsc_env maybe_old_fingerprint
                                          intermediate_iface decls
 
hunk ./compiler/iface/MkIface.lhs 277
-		-- Warn about orphans
-	; let warn_orphs      = dopt Opt_WarnOrphans dflags
+                -- Warn about orphans
+        ; let warn_orphs      = dopt Opt_WarnOrphans dflags
               warn_auto_orphs = dopt Opt_WarnAutoOrphans dflags
               orph_warnings   --- Laziness means no work done unless -fwarn-orphans
hunk ./compiler/iface/MkIface.lhs 281
-	        | warn_orphs || warn_auto_orphs = rule_warns `unionBags` inst_warns
-	        | otherwise 	       	        = emptyBag
-	      errs_and_warns = (orph_warnings, emptyBag)
-	      unqual = mkPrintUnqualified dflags rdr_env
-	      inst_warns = listToBag [ instOrphWarn unqual d 
-	      		   	     | (d,i) <- insts `zip` iface_insts
-	      		   	     , isNothing (ifInstOrph i) ]
-	      rule_warns = listToBag [ ruleOrphWarn unqual this_mod r 
-	      		    	     | r <- iface_rules
-	      		   	     , isNothing (ifRuleOrph r)
+                | warn_orphs || warn_auto_orphs = rule_warns `unionBags` inst_warns
+                | otherwise                     = emptyBag
+              errs_and_warns = (orph_warnings, emptyBag)
+              unqual = mkPrintUnqualified dflags rdr_env
+              inst_warns = listToBag [ instOrphWarn unqual d
+                                     | (d,i) <- insts `zip` iface_insts
+                                     , isNothing (ifInstOrph i) ]
+              rule_warns = listToBag [ ruleOrphWarn unqual this_mod r
+                                     | r <- iface_rules
+                                     , isNothing (ifRuleOrph r)
                                      , if ifRuleAuto r then warn_auto_orphs
                                                        else warn_orphs ]
 
hunk ./compiler/iface/MkIface.lhs 294
-	; if errorsFound dflags errs_and_warns
+        ; if errorsFound dflags errs_and_warns
             then return ( errs_and_warns, Nothing )
             else do {
 
hunk ./compiler/iface/MkIface.lhs 298
--- XXX	; when (dopt Opt_D_dump_hi_diffs dflags) (printDump pp_diffs)
-   
-	   	-- Debug printing
-	; dumpIfSet_dyn dflags Opt_D_dump_hi "FINAL INTERFACE" 
-			(pprModIface new_iface)
+-- XXX  ; when (dopt Opt_D_dump_hi_diffs dflags) (printDump pp_diffs)
+
+                -- Debug printing
+        ; dumpIfSet_dyn dflags Opt_D_dump_hi "FINAL INTERFACE"
+                        (pprModIface new_iface)
 
                 -- bug #1617: on reload we weren't updating the PrintUnqualified
                 -- correctly.  This stems from the fact that the interface had
hunk ./compiler/iface/MkIface.lhs 310
                 -- with the old GlobalRdrEnv (mi_globals).
         ; let final_iface = new_iface{ mi_globals = Just rdr_env }
 
-	; return (errs_and_warns, Just (final_iface, no_change_at_all)) }}
+        ; return (errs_and_warns, Just (final_iface, no_change_at_all)) }}
   where
      r1 `le_rule`     r2 = ifRuleName      r1    <=    ifRuleName      r2
hunk ./compiler/iface/MkIface.lhs 313
-     i1 `le_inst`     i2 = ifDFun          i1 `le_occ` ifDFun          i2  
+     i1 `le_inst`     i2 = ifDFun          i1 `le_occ` ifDFun          i2
      i1 `le_fam_inst` i2 = ifFamInstTcName i1 `le_occ` ifFamInstTcName i2
 
      le_occ :: Name -> Name -> Bool
hunk ./compiler/iface/MkIface.lhs 317
-	-- Compare lexicographically by OccName, *not* by unique, because 
-	-- the latter is not stable across compilations
+        -- Compare lexicographically by OccName, *not* by unique, because
+        -- the latter is not stable across compilations
      le_occ n1 n2 = nameOccName n1 <= nameOccName n2
 
      dflags = hsc_dflags hsc_env
hunk ./compiler/iface/MkIface.lhs 330
 
      flattenVectInfo (VectInfo { vectInfoVar   = vVar
                                , vectInfoTyCon = vTyCon
-                               }) = 
-       IfaceVectInfo { 
-         ifaceVectInfoVar        = [ Var.varName v 
+                               }) =
+       IfaceVectInfo{
+         ifaceVectInfoVar        = [ Var.varName v
                                    | (v, _) <- varEnvElts vVar],
hunk ./compiler/iface/MkIface.lhs 334
-         ifaceVectInfoTyCon      = [ tyConName t 
+         ifaceVectInfoTyCon      = [ tyConName t
                                    | (t, t_v) <- nameEnvElts vTyCon
                                    , t /= t_v],
          ifaceVectInfoTyConReuse = [ tyConName t
hunk ./compiler/iface/MkIface.lhs 339
                                    | (t, t_v) <- nameEnvElts vTyCon
-                                   , t == t_v]
-       } 
+                                   , t == t_v] }
 
 -----------------------------
 writeIfaceFile :: DynFlags -> ModLocation -> ModIface -> IO ()
hunk ./compiler/iface/MkIface.lhs 361
         -> ExternalPackageState         -- ditto
         -> (Name -> Fingerprint)
 mkHashFun hsc_env eps
-  = \name -> 
-      let 
+  = \name ->
+      let
         mod = ASSERT2( isExternalName name, ppr name ) nameModule name
         occ = nameOccName name
hunk ./compiler/iface/MkIface.lhs 365
-        iface = lookupIfaceByModule (hsc_dflags hsc_env) hpt pit mod `orElse` 
+        iface = lookupIfaceByModule (hsc_dflags hsc_env) hpt pit mod `orElse`
                    pprPanic "lookupVers2" (ppr mod <+> ppr occ)
hunk ./compiler/iface/MkIface.lhs 367
-      in  
-        snd (mi_hash_fn iface occ `orElse` 
+      in
+        snd (mi_hash_fn iface occ `orElse`
                   pprPanic "lookupVers1" (ppr mod <+> ppr occ))
   where
       hpt = hsc_HPT hsc_env
hunk ./compiler/iface/MkIface.lhs 380
 addFingerprints
         :: HscEnv
         -> Maybe Fingerprint -- the old fingerprint, if any
-        -> ModIface	     -- The new interface (lacking decls)
+        -> ModIface          -- The new interface (lacking decls)
         -> [IfaceDecl]       -- The new decls
         -> IO (ModIface,     -- Updated interface
hunk ./compiler/iface/MkIface.lhs 383
-               Bool)	     -- True <=> no changes at all; 
+               Bool)         -- True <=> no changes at all;
                              -- no need to write Iface
 
 addFingerprints hsc_env mb_old_fingerprint iface0 new_decls
hunk ./compiler/iface/MkIface.lhs 393
         -- The ABI of a declaration represents everything that is made
         -- visible about the declaration that a client can depend on.
         -- see IfaceDeclABI below.
-       declABI :: IfaceDecl -> IfaceDeclABI 
+       declABI :: IfaceDecl -> IfaceDeclABI
        declABI decl = (this_mod, decl, extras)
         where extras = declExtras fix_fn non_orph_rules non_orph_insts decl
 
hunk ./compiler/iface/MkIface.lhs 399
        edges :: [(IfaceDeclABI, Unique, [Unique])]
        edges = [ (abi, getUnique (ifName decl), out)
-	       | decl <- new_decls
+               | decl <- new_decls
                , let abi = declABI decl
hunk ./compiler/iface/MkIface.lhs 401
-	       , let out = localOccs $ freeNamesDeclABI abi
+               , let out = localOccs $ freeNamesDeclABI abi
                ]
 
        name_module n = ASSERT2( isExternalName n, ppr n ) nameModule n
hunk ./compiler/iface/MkIface.lhs 405
-       localOccs = map (getUnique . getParent . getOccName) 
+       localOccs = map (getUnique . getParent . getOccName)
                         . filter ((== this_mod) . name_module)
                         . nameSetToList
           where getParent occ = lookupOccEnv parent_map occ `orElse` occ
hunk ./compiler/iface/MkIface.lhs 415
         -- to the TyCon for the purposes of calculating dependencies.
        parent_map :: OccEnv OccName
        parent_map = foldr extend emptyOccEnv new_decls
-          where extend d env = 
+          where extend d env =
                   extendOccEnvList env [ (b,n) | b <- ifaceDeclSubBndrs d ]
                   where n = ifName d
 
hunk ./compiler/iface/MkIface.lhs 433
        mk_put_name :: (OccEnv (OccName,Fingerprint))
                    -> BinHandle -> Name -> IO  ()
        mk_put_name local_env bh name
-          | isWiredInName name  =  putNameLiterally bh name 
+          | isWiredInName name  =  putNameLiterally bh name
            -- wired-in names don't have fingerprints
           | otherwise
           = ASSERT2( isExternalName name, ppr name )
hunk ./compiler/iface/MkIface.lhs 437
-	    let hash | nameModule name /= this_mod =  global_hash_fn name
-                     | otherwise = 
+            let hash | nameModule name /= this_mod =  global_hash_fn name
+                     | otherwise =
                         snd (lookupOccEnv local_env (getOccName name)
hunk ./compiler/iface/MkIface.lhs 440
-                           `orElse` pprPanic "urk! lookup local fingerprint" 
+                           `orElse` pprPanic "urk! lookup local fingerprint"
                                        (ppr name)) -- (undefined,fingerprint0))
                 -- This panic indicates that we got the dependency
                 -- analysis wrong, because we needed a fingerprint for
hunk ./compiler/iface/MkIface.lhs 449
                 -- pprTraces below, run the compile again, and inspect
                 -- the output and the generated .hi file with
                 -- --show-iface.
-            in 
+            in
             put_ bh hash
 
         -- take a strongly-connected group of declarations and compute
hunk ./compiler/iface/MkIface.lhs 455
         -- its fingerprint.
 
-       fingerprint_group :: (OccEnv (OccName,Fingerprint), 
+       fingerprint_group :: (OccEnv (OccName,Fingerprint),
                              [(Fingerprint,IfaceDecl)])
                          -> SCC IfaceDeclABI
hunk ./compiler/iface/MkIface.lhs 458
-                         -> IO (OccEnv (OccName,Fingerprint), 
+                         -> IO (OccEnv (OccName,Fingerprint),
                                 [(Fingerprint,IfaceDecl)])
 
        fingerprint_group (local_env, decls_w_hashes) (AcyclicSCC abi)
hunk ./compiler/iface/MkIface.lhs 471
 
        fingerprint_group (local_env, decls_w_hashes) (CyclicSCC abis)
           = do let decls = map abiDecl abis
-                   local_env' = foldr extend_hash_env local_env 
+                   local_env' = foldr extend_hash_env local_env
                                    (zip (repeat fingerprint0) decls)
                    hash_fn = mk_put_name local_env'
                -- pprTrace "fingerprinting" (ppr (map ifName decls) ) $ do
hunk ./compiler/iface/MkIface.lhs 491
           item = (decl_name, hash)
           env1 = extendOccEnv env0 decl_name item
           add_imp bndr env = extendOccEnv env bndr item
-            
+
    --
hunk ./compiler/iface/MkIface.lhs 493
-   (local_env, decls_w_hashes) <- 
+   (local_env, decls_w_hashes) <-
        foldM fingerprint_group (emptyOccEnv, []) groups
 
    -- when calculating fingerprints, we always need to use canonical
hunk ./compiler/iface/MkIface.lhs 516
 
    -- the export list hash doesn't depend on the fingerprints of
    -- the Names it mentions, only the Names themselves, hence putNameLiterally.
-   export_hash <- computeFingerprint dflags putNameLiterally 
+   export_hash <- computeFingerprint dflags putNameLiterally
                       (mi_exports iface0,
                        orphan_hash,
                        dep_orphan_hashes,
hunk ./compiler/iface/MkIface.lhs 546
    --    - deps
    --    - hpc
    iface_hash <- computeFingerprint dflags putNameLiterally
-                      (mod_hash, 
+                      (mod_hash,
                        mi_usages iface0,
                        sorted_deps,
                        mi_hpc iface0)
hunk ./compiler/iface/MkIface.lhs 581
 getOrphanHashes :: HscEnv -> [Module] -> IO [Fingerprint]
 getOrphanHashes hsc_env mods = do
   eps <- hscEPS hsc_env
-  let 
+  let
     hpt        = hsc_HPT hsc_env
     pit        = eps_PIT eps
     dflags     = hsc_dflags hsc_env
hunk ./compiler/iface/MkIface.lhs 585
-    get_orph_hash mod = 
+    get_orph_hash mod =
           case lookupIfaceByModule dflags hpt pit mod of
             Nothing    -> pprPanic "moduleOrphanHash" (ppr mod)
             Just iface -> mi_orphan_hash iface
hunk ./compiler/iface/MkIface.lhs 603
 
 
 %************************************************************************
-%*		                					*
-          The ABI of an IfaceDecl       									
-%*	       	     							*
+%*                                                                      *
+          The ABI of an IfaceDecl
+%*                                                                      *
 %************************************************************************
 
 Note [The ABI of an IfaceDecl]
hunk ./compiler/iface/MkIface.lhs 633
 \begin{code}
 type IfaceDeclABI = (Module, IfaceDecl, IfaceDeclExtras)
 
-data IfaceDeclExtras 
+data IfaceDeclExtras
   = IfaceIdExtras    Fixity [IfaceRule]
   | IfaceDataExtras  Fixity [IfaceInstABI] [(Fixity,[IfaceRule])]
   | IfaceClassExtras Fixity [IfaceInstABI] [(Fixity,[IfaceRule])]
hunk ./compiler/iface/MkIface.lhs 644
 abiDecl (_, decl, _) = decl
 
 cmp_abiNames :: IfaceDeclABI -> IfaceDeclABI -> Ordering
-cmp_abiNames abi1 abi2 = ifName (abiDecl abi1) `compare` 
+cmp_abiNames abi1 abi2 = ifName (abiDecl abi1) `compare`
                          ifName (abiDecl abi2)
 
 freeNamesDeclABI :: IfaceDeclABI -> NameSet
hunk ./compiler/iface/MkIface.lhs 706
 
 declExtras fix_fn rule_env inst_env decl
   = case decl of
-      IfaceId{} -> IfaceIdExtras (fix_fn n) 
+      IfaceId{} -> IfaceIdExtras (fix_fn n)
                         (lookupOccEnvL rule_env n)
hunk ./compiler/iface/MkIface.lhs 708
-      IfaceData{ifCons=cons} -> 
+      IfaceData{ifCons=cons} ->
                      IfaceDataExtras (fix_fn n)
                         (map ifDFun $ lookupOccEnvL inst_env n)
                         (map (id_extras . ifConOcc) (visibleIfConDecls cons))
hunk ./compiler/iface/MkIface.lhs 712
-      IfaceClass{ifSigs=sigs} -> 
+      IfaceClass{ifSigs=sigs} ->
                      IfaceClassExtras (fix_fn n)
                         (map ifDFun $ lookupOccEnvL inst_env n)
                         [id_extras op | IfaceClassOp op _ _ <- sigs]
hunk ./compiler/iface/MkIface.lhs 734
 -- used when we want to fingerprint a structure without depending on the
 -- fingerprints of external Names that it refers to.
 putNameLiterally :: BinHandle -> Name -> IO ()
-putNameLiterally bh name = ASSERT( isExternalName name ) 
+putNameLiterally bh name = ASSERT( isExternalName name )
   do { put_ bh $! nameModule name
      ; put_ bh $! nameOccName name }
 
hunk ./compiler/iface/MkIface.lhs 739
 computeFingerprint :: Binary a
-                   => DynFlags 
+                   => DynFlags
                    -> (BinHandle -> Name -> IO ())
                    -> a
                    -> IO Fingerprint
hunk ./compiler/iface/MkIface.lhs 787
 
 ----------------------
 -- mkOrphMap partitions instance decls or rules into
--- 	(a) an OccEnv for ones that are not orphans, 
---	    mapping the local OccName to a list of its decls
---	(b) a list of orphan decls
-mkOrphMap :: (decl -> Maybe OccName)	-- (Just occ) for a non-orphan decl, keyed by occ
-					-- Nothing for an orphan decl
-	  -> [decl] 			-- Sorted into canonical order
-	  -> (OccEnv [decl],	 	-- Non-orphan decls associated with their key;
-					--	each sublist in canonical order
-	      [decl])			-- Orphan decls; in canonical order
+--      (a) an OccEnv for ones that are not orphans,
+--          mapping the local OccName to a list of its decls
+--      (b) a list of orphan decls
+mkOrphMap :: (decl -> Maybe OccName)    -- (Just occ) for a non-orphan decl, keyed by occ
+                                        -- Nothing for an orphan decl
+          -> [decl]                     -- Sorted into canonical order
+          -> (OccEnv [decl],            -- Non-orphan decls associated with their key;
+                                        --      each sublist in canonical order
+              [decl])                   -- Orphan decls; in canonical order
 mkOrphMap get_key decls
   = foldl go (emptyOccEnv, []) decls
   where
hunk ./compiler/iface/MkIface.lhs 800
     go (non_orphs, orphs) d
-	| Just occ <- get_key d
-	= (extendOccEnv_Acc (:) singleton non_orphs occ d, orphs)
-	| otherwise = (non_orphs, d:orphs)
+        | Just occ <- get_key d
+        = (extendOccEnv_Acc (:) singleton non_orphs occ d, orphs)
+        | otherwise = (non_orphs, d:orphs)
 \end{code}
 
 
hunk ./compiler/iface/MkIface.lhs 807
 %************************************************************************
-%*		                					*
+%*                                                                      *
        Keeping track of what we've slurped, and fingerprints
hunk ./compiler/iface/MkIface.lhs 809
-%*	       	     							*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/iface/MkIface.lhs 815
 mkUsageInfo :: HscEnv -> Module -> ImportedMods -> NameSet -> IO [Usage]
 mkUsageInfo hsc_env this_mod dir_imp_mods used_names
-  = do	{ eps <- hscEPS hsc_env
-	; let usages = mk_usage_info (eps_PIT eps) hsc_env this_mod
-				     dir_imp_mods used_names
-	; usages `seqList`  return usages }
-	 -- seq the list of Usages returned: occasionally these
-	 -- don't get evaluated for a while and we can end up hanging on to
-	 -- the entire collection of Ifaces.
+  = do  { eps <- hscEPS hsc_env
+        ; let usages = mk_usage_info (eps_PIT eps) hsc_env this_mod
+                                     dir_imp_mods used_names
+        ; usages `seqList`  return usages }
+         -- seq the list of Usages returned: occasionally these
+         -- don't get evaluated for a while and we can end up hanging on to
+         -- the entire collection of Ifaces.
 
 mk_usage_info :: PackageIfaceTable
               -> HscEnv
hunk ./compiler/iface/MkIface.lhs 857
                          -- specialised (++); originally came about to
                          -- avoid quadratic behaviour (trac #2680)
                          extendModuleEnvWith (\_ xs -> occ:xs) mv_map mod [occ]
-    		   where occ = nameOccName name
-    
-    -- We want to create a Usage for a home module if 
-    --	a) we used something from it; has something in used_names
-    --	b) we imported it, even if we used nothing from it
-    --	   (need to recompile if its export list changes: export_fprint)
+                   where occ = nameOccName name
+
+    -- We want to create a Usage for a home module if
+    --  a) we used something from it; has something in used_names
+    --  b) we imported it, even if we used nothing from it
+    --     (need to recompile if its export list changes: export_fprint)
     mkUsage :: Module -> Maybe Usage
     mkUsage mod
hunk ./compiler/iface/MkIface.lhs 865
-      | isNothing maybe_iface		-- We can't depend on it if we didn't
-                        		-- load its interface.
+      | isNothing maybe_iface           -- We can't depend on it if we didn't
+                                        -- load its interface.
       || mod == this_mod                -- We don't care about usages of
                                         -- things in *this* module
       = Nothing
hunk ./compiler/iface/MkIface.lhs 878
         -- for package modules, we record the module hash only
 
       | (null used_occs
-	  && isNothing export_hash
+          && isNothing export_hash
           && not is_direct_import
hunk ./compiler/iface/MkIface.lhs 880
-	  && not finsts_mod)
-      = Nothing			-- Record no usage info
+          && not finsts_mod)
+      = Nothing              -- Record no usage info
         -- for directly-imported modules, we always want to record a usage
         -- on the orphan hash.  This is what triggers a recompilation if
         -- an orphan is added or removed somewhere below us in the future.
hunk ./compiler/iface/MkIface.lhs 885
-    
-      | otherwise	
-      = Just UsageHomeModule { 
+
+      | otherwise
+      = Just UsageHomeModule {
                       usg_mod_name = moduleName mod,
                       usg_mod_hash = mod_hash,
                       usg_exports  = export_hash,
hunk ./compiler/iface/MkIface.lhs 899
                 -- modules accumulate in the PIT not HPT.  Sigh.
 
         Just iface   = maybe_iface
-	finsts_mod   = mi_finsts    iface
+        finsts_mod   = mi_finsts    iface
         hash_env     = mi_hash_fn   iface
         mod_hash     = mi_mod_hash  iface
         export_hash | depend_on_exports = Just (mi_exp_hash iface)
hunk ./compiler/iface/MkIface.lhs 910
                 Just ((_,_,_,safe):xs) -> (True, safe)
                 Just _                 -> pprPanic "mkUsage: empty direct import" empty
                 Nothing                -> (False, False)
-    
+
         used_occs = lookupModuleEnv ent_map mod `orElse` []
 
hunk ./compiler/iface/MkIface.lhs 913
-    	-- Making a Map here ensures that (a) we remove duplicates
+        -- Making a Map here ensures that (a) we remove duplicates
         -- when we have usages on several subordinates of a single parent,
         -- and (b) that the usages emerge in a canonical order, which
         -- is why we use Map rather than OccEnv: Map works
hunk ./compiler/iface/MkIface.lhs 918
         -- using Ord on the OccNames, which is a lexicographic ordering.
-	ent_hashs :: Map OccName Fingerprint
+        ent_hashs :: Map OccName Fingerprint
         ent_hashs = Map.fromList (map lookup_occ used_occs)
hunk ./compiler/iface/MkIface.lhs 920
-        
-        lookup_occ occ = 
+
+        lookup_occ occ =
             case hash_env occ of
                 Nothing -> pprPanic "mkUsage" (ppr mod <+> ppr occ <+> ppr used_names)
                 Just r  -> r
hunk ./compiler/iface/MkIface.lhs 948
 mkIfaceAnnotations = map mkIfaceAnnotation
 
 mkIfaceAnnotation :: Annotation -> IfaceAnnotation
-mkIfaceAnnotation (Annotation { ann_target = target, ann_value = serialized }) = IfaceAnnotation { 
+mkIfaceAnnotation (Annotation { ann_target = target, ann_value = serialized }) = IfaceAnnotation {
         ifAnnotatedTarget = fmap nameOccName target,
         ifAnnotatedValue = serialized
     }
hunk ./compiler/iface/MkIface.lhs 968
                        -- using the stable Module ordering.
     ]
   where
-	-- Group by the module where the exported entities are defined
-	-- (which may not be the same for all Names in an Avail)
-	-- Deliberately use Map rather than UniqFM so we
-	-- get a canonical ordering
+        -- Group by the module where the exported entities are defined
+        -- (which may not be the same for all Names in an Avail)
+        -- Deliberately use Map rather than UniqFM so we
+        -- get a canonical ordering
     groupFM :: ModuleEnv (Map FastString (GenAvailInfo OccName))
     groupFM = foldl add emptyModuleEnv exports
 
hunk ./compiler/iface/MkIface.lhs 976
     add_one :: ModuleEnv (Map FastString (GenAvailInfo OccName))
-	    -> Module -> GenAvailInfo OccName
-	    -> ModuleEnv (Map FastString (GenAvailInfo OccName))
-    add_one env mod avail 
+            -> Module -> GenAvailInfo OccName
+            -> ModuleEnv (Map FastString (GenAvailInfo OccName))
+    add_one env mod avail
       -- XXX Is there a need to flip Map.union here?
hunk ./compiler/iface/MkIface.lhs 980
-      =  extendModuleEnvWith (flip Map.union) env mod 
-		(Map.singleton (occNameFS (availName avail)) avail)
+      =  extendModuleEnvWith (flip Map.union) env mod
+                (Map.singleton (occNameFS (availName avail)) avail)
 
hunk ./compiler/iface/MkIface.lhs 983
-	-- NB: we should not get T(X) and T(Y) in the export list
-	--     else the Map.union will simply discard one!  They
-	--     should have been combined by now.
+        -- NB: we should not get T(X) and T(Y) in the export list
+        --     else the Map.union will simply discard one!  They
+        --     should have been combined by now.
     add env (Avail n)
hunk ./compiler/iface/MkIface.lhs 987
-      = ASSERT( isExternalName n ) 
+      = ASSERT( isExternalName n )
         add_one env (nameModule n) (Avail (nameOccName n))
 
     add env (AvailTC tc ns)
hunk ./compiler/iface/MkIface.lhs 991
-      = ASSERT( all isExternalName ns ) 
-	foldl add_for_mod env mods
+      = ASSERT( all isExternalName ns )
+        foldl add_for_mod env mods
       where
hunk ./compiler/iface/MkIface.lhs 994
-	tc_occ = nameOccName tc
-	mods   = nub (map nameModule ns)
-		-- Usually just one, but see Note [Original module]
+        tc_occ = nameOccName tc
+        mods   = nub (map nameModule ns)
+                -- Usually just one, but see Note [Original module]
 
hunk ./compiler/iface/MkIface.lhs 998
-	add_for_mod env mod
-	    = add_one env mod (AvailTC tc_occ (sort names_from_mod))
+        add_for_mod env mod
+            = add_one env mod (AvailTC tc_occ (sort names_from_mod))
               -- NB. sort the children, we need a canonical order
hunk ./compiler/iface/MkIface.lhs 1001
-	    where
-	      names_from_mod = [nameOccName n | n <- ns, nameModule n == mod]
+            where
+              names_from_mod = [nameOccName n | n <- ns, nameModule n == mod]
 \end{code}
 
 Note [Orignal module]
hunk ./compiler/iface/MkIface.lhs 1008
 ~~~~~~~~~~~~~~~~~~~~~
 Consider this:
-	module X where { data family T }
-	module Y( T(..) ) where { import X; data instance T Int = MkT Int }
+        module X where { data family T }
+        module Y( T(..) ) where { import X; data instance T Int = MkT Int }
 The exported Avail from Y will look like
hunk ./compiler/iface/MkIface.lhs 1011
-	X.T{X.T, Y.MkT}
-That is, in Y, 
+        X.T{X.T, Y.MkT}
+That is, in Y,
   - only MkT is brought into scope by the data instance;
   - but the parent (used for grouping and naming in T(..) exports) is X.T
   - and in this case we export X.T too
hunk ./compiler/iface/MkIface.lhs 1022
 
 
 %************************************************************************
-%*									*
-	Load the old interface file for this module (unless
-	we have it aleady), and check whether it is up to date
-	
-%*									*
+%*                                                                      *
+        Load the old interface file for this module (unless
+        we have it aleady), and check whether it is up to date
+
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/iface/MkIface.lhs 1031
 checkOldIface :: HscEnv
-	      -> ModSummary
-	      -> Bool 			-- Source unchanged
-	      -> Maybe ModIface 	-- Old interface from compilation manager, if any
-	      -> IO (RecompileRequired, Maybe ModIface)
+              -> ModSummary
+              -> Bool                   -- Source unchanged
+              -> Maybe ModIface         -- Old interface from compilation manager, if any
+              -> IO (RecompileRequired, Maybe ModIface)
 
 checkOldIface hsc_env mod_summary source_unchanged maybe_iface
   = do  showPass (hsc_dflags hsc_env) $
hunk ./compiler/iface/MkIface.lhs 1091
 \begin{code}
 type RecompileRequired = Bool
 upToDate, outOfDate :: Bool
-upToDate  = False	-- Recompile not required
-outOfDate = True	-- Recompile required
+upToDate  = False       -- Recompile not required
+outOfDate = True        -- Recompile required
 
 -- | Check the safe haskell flags haven't changed
 --   (e.g different flag on command line now)
hunk ./compiler/iface/MkIface.lhs 1101
   = (getSafeMode $ mi_trust iface) /= (safeHaskell $ hsc_dflags hsc_env)
 
 checkVersions :: HscEnv
-	      -> Bool		-- True <=> source unchanged
+              -> Bool           -- True <=> source unchanged
               -> ModSummary
hunk ./compiler/iface/MkIface.lhs 1103
-	      -> ModIface 	-- Old interface
-	      -> IfG (RecompileRequired, Maybe ModIface)
+              -> ModIface       -- Old interface
+              -> IfG (RecompileRequired, Maybe ModIface)
 checkVersions hsc_env source_unchanged mod_summary iface
   | not source_unchanged
   = return (outOfDate, Just iface)
hunk ./compiler/iface/MkIface.lhs 1109
   | otherwise
-  = do  { traceHiDiffs (text "Considering whether compilation is required for" <+> 
+  = do  { traceHiDiffs (text "Considering whether compilation is required for" <+>
                         ppr (mi_module iface) <> colon)
 
         ; recomp <- checkDependencies hsc_env mod_summary iface
hunk ./compiler/iface/MkIface.lhs 1116
         ; if recomp then return (outOfDate, Just iface) else do {
         ; if trust_dif then return (outOfDate, Nothing) else do {
 
-        -- Source code unchanged and no errors yet... carry on 
+        -- Source code unchanged and no errors yet... carry on
         --
         -- First put the dependent-module info, read from the old
         -- interface, into the envt, so that when we look for
hunk ./compiler/iface/MkIface.lhs 1121
         -- interfaces we look for the right one (.hi or .hi-boot)
-        -- 
-        -- It's just temporary because either the usage check will succeed 
+        --
+        -- It's just temporary because either the usage check will succeed
         -- (in which case we are done with this module) or it'll fail (in which
         -- case we'll compile the module from scratch anyhow).
hunk ./compiler/iface/MkIface.lhs 1125
-        -- 
+        --
         -- We do this regardless of compilation mode, although in --make mode
         -- all the dependent modules should be in the HPT already, so it's
         -- quite redundant
hunk ./compiler/iface/MkIface.lhs 1191
 needInterface :: Module -> (ModIface -> IfG RecompileRequired)
               -> IfG RecompileRequired
 needInterface mod continue
-  = do	-- Load the imported interface if possible
+  = do  -- Load the imported interface if possible
     let doc_str = sep [ptext (sLit "need version info for"), ppr mod]
     traceHiDiffs (text "Checking usages for module" <+> ppr mod)
 
hunk ./compiler/iface/MkIface.lhs 1196
     mb_iface <- loadInterface doc_str mod ImportBySystem
-	-- Load the interface, but don't complain on failure;
-	-- Instead, get an Either back which we can test
+        -- Load the interface, but don't complain on failure;
+        -- Instead, get an Either back which we can test
 
     case mb_iface of
       Failed _ ->  (out_of_date (sep [ptext (sLit "Couldn't load interface for module"),
hunk ./compiler/iface/MkIface.lhs 1224
         -- recompile.  This is safe but may entail more recompilation when
         -- a dependent package has changed.
 
-checkModUsage this_pkg UsageHomeModule{ 
-                                usg_mod_name = mod_name, 
+checkModUsage this_pkg UsageHomeModule{
+                                usg_mod_name = mod_name,
                                 usg_mod_hash = old_mod_hash,
hunk ./compiler/iface/MkIface.lhs 1227
-		       		usg_exports = maybe_old_export_hash,
-		       		usg_entities = old_decl_hash }
+                                usg_exports = maybe_old_export_hash,
+                                usg_entities = old_decl_hash }
   = do
     let mod = mkModule this_pkg mod_name
     needInterface mod $ \iface -> do
hunk ./compiler/iface/MkIface.lhs 1234
 
     let
-	new_mod_hash    = mi_mod_hash    iface
-	new_decl_hash 	= mi_hash_fn     iface
-	new_export_hash = mi_exp_hash    iface
+        new_mod_hash    = mi_mod_hash    iface
+        new_decl_hash   = mi_hash_fn     iface
+        new_export_hash = mi_exp_hash    iface
 
hunk ./compiler/iface/MkIface.lhs 1238
-	-- CHECK MODULE
+        -- CHECK MODULE
     recompile <- checkModuleFingerprint old_mod_hash new_mod_hash
     if not recompile then return upToDate else do
hunk ./compiler/iface/MkIface.lhs 1241
-				 
-	-- CHECK EXPORT LIST
+
+        -- CHECK EXPORT LIST
     checkMaybeHash maybe_old_export_hash new_export_hash
         (ptext (sLit "  Export list changed")) $ do
 
hunk ./compiler/iface/MkIface.lhs 1246
-	-- CHECK ITEMS ONE BY ONE
-    recompile <- checkList [ checkEntityUsage new_decl_hash u 
+        -- CHECK ITEMS ONE BY ONE
+    recompile <- checkList [ checkEntityUsage new_decl_hash u
                            | u <- old_decl_hash]
hunk ./compiler/iface/MkIface.lhs 1249
-    if recompile 
-      then return outOfDate	-- This one failed, so just bail out now
+    if recompile
+      then return outOfDate     -- This one failed, so just bail out now
       else up_to_date (ptext (sLit "  Great!  The bits I use are up to date"))
 
 ------------------------
hunk ./compiler/iface/MkIface.lhs 1261
 
   | otherwise
   = out_of_date_hash (ptext (sLit "  Module fingerprint has changed"))
-		     old_mod_hash new_mod_hash
+                     old_mod_hash new_mod_hash
 
 ------------------------
 checkMaybeHash :: Maybe Fingerprint -> Fingerprint -> SDoc
hunk ./compiler/iface/MkIface.lhs 1279
 checkEntityUsage new_hash (name,old_hash)
   = case new_hash name of
 
-	Nothing       -> 	-- We used it before, but it ain't there now
-			  out_of_date (sep [ptext (sLit "No longer exported:"), ppr name])
+        Nothing       ->        -- We used it before, but it ain't there now
+                          out_of_date (sep [ptext (sLit "No longer exported:"), ppr name])
 
hunk ./compiler/iface/MkIface.lhs 1282
-	Just (_, new_hash) 	-- It's there, but is it up to date?
-	  | new_hash == old_hash -> do traceHiDiffs (text "  Up to date" <+> ppr name <+> parens (ppr new_hash))
-			  	       return upToDate
-	  | otherwise	 	 -> out_of_date_hash (ptext (sLit "  Out of date:") <+> ppr name)
-						     old_hash new_hash
+        Just (_, new_hash)      -- It's there, but is it up to date?
+          | new_hash == old_hash -> do traceHiDiffs (text "  Up to date" <+> ppr name <+> parens (ppr new_hash))
+                                       return upToDate
+          | otherwise            -> out_of_date_hash (ptext (sLit "  Out of date:") <+> ppr name)
+                                                     old_hash new_hash
 
 up_to_date, out_of_date :: SDoc -> IfG Bool
 up_to_date  msg = traceHiDiffs msg >> return upToDate
hunk ./compiler/iface/MkIface.lhs 1293
 out_of_date msg = traceHiDiffs msg >> return outOfDate
 
 out_of_date_hash :: SDoc -> Fingerprint -> Fingerprint -> IfG Bool
-out_of_date_hash msg old_hash new_hash 
+out_of_date_hash msg old_hash new_hash
   = out_of_date (hsep [msg, ppr old_hash, ptext (sLit "->"), ppr new_hash])
 
 ----------------------
hunk ./compiler/iface/MkIface.lhs 1299
 checkList :: [IfG RecompileRequired] -> IfG RecompileRequired
 -- This helper is used in two places
-checkList []		 = return upToDate
+checkList []             = return upToDate
 checkList (check:checks) = do recompile <- check
                               if recompile
                                 then return outOfDate
hunk ./compiler/iface/MkIface.lhs 1307
 \end{code}
 
 %************************************************************************
-%*				 					*
-		Converting things to their Iface equivalents
-%*				 					*
+%*                                                                      *
+                Converting things to their Iface equivalents
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/iface/MkIface.lhs 1315
 tyThingToIfaceDecl :: TyThing -> IfaceDecl
 -- Assumption: the thing is already tidied, so that locally-bound names
--- 	       (lambdas, for-alls) already have non-clashing OccNames
+--             (lambdas, for-alls) already have non-clashing OccNames
 -- Reason: Iface stuff uses OccNames, and the conversion here does
hunk ./compiler/iface/MkIface.lhs 1317
---	   not do tidying on the way
+--         not do tidying on the way
 tyThingToIfaceDecl (AnId id)
   = IfaceId { ifName      = getOccName id,
hunk ./compiler/iface/MkIface.lhs 1320
-	      ifType      = toIfaceType (idType id),
-	      ifIdDetails = toIfaceIdDetails (idDetails id),
-	      ifIdInfo    = toIfaceIdInfo (idInfo id) }
+              ifType      = toIfaceType (idType id),
+              ifIdDetails = toIfaceIdDetails (idDetails id),
+              ifIdInfo    = toIfaceIdInfo (idInfo id) }
 
 tyThingToIfaceDecl (AClass clas)
hunk ./compiler/iface/MkIface.lhs 1325
-  = IfaceClass { ifCtxt	  = toIfaceContext sc_theta,
-		 ifName	  = getOccName clas,
-		 ifTyVars = toIfaceTvBndrs clas_tyvars,
-		 ifFDs    = map toIfaceFD clas_fds,
-		 ifATs	  = map (tyThingToIfaceDecl . ATyCon) clas_ats,
-		 ifSigs	  = map toIfaceClassOp op_stuff,
-	  	 ifRec    = boolToRecFlag (isRecursiveTyCon tycon) }
+  = IfaceClass { ifCtxt   = toIfaceContext sc_theta,
+                 ifName   = getOccName clas,
+                 ifTyVars = toIfaceTvBndrs clas_tyvars,
+                 ifFDs    = map toIfaceFD clas_fds,
+                 ifATs    = map (tyThingToIfaceDecl . ATyCon) clas_ats,
+                 ifSigs   = map toIfaceClassOp op_stuff,
+                 ifRec    = boolToRecFlag (isRecursiveTyCon tycon) }
   where
hunk ./compiler/iface/MkIface.lhs 1333
-    (clas_tyvars, clas_fds, sc_theta, _, clas_ats, op_stuff) 
+    (clas_tyvars, clas_fds, sc_theta, _, clas_ats, op_stuff)
       = classExtraBigSig clas
     tycon = classTyCon clas
 
hunk ./compiler/iface/MkIface.lhs 1338
     toIfaceClassOp (sel_id, def_meth)
-	= ASSERT(sel_tyvars == clas_tyvars)
-	  IfaceClassOp (getOccName sel_id) (toDmSpec def_meth) (toIfaceType op_ty)
-	where
-		-- Be careful when splitting the type, because of things
-		-- like  	class Foo a where
-		--		  op :: (?x :: String) => a -> a
-		-- and  	class Baz a where
-		--		  op :: (Ord a) => a -> a
-	  (sel_tyvars, rho_ty) = splitForAllTys (idType sel_id)
-	  op_ty		       = funResultTy rho_ty
+        = ASSERT(sel_tyvars == clas_tyvars)
+          IfaceClassOp (getOccName sel_id) (toDmSpec def_meth) (toIfaceType op_ty)
+        where
+                -- Be careful when splitting the type, because of things
+                -- like         class Foo a where
+                --                op :: (?x :: String) => a -> a
+                -- and          class Baz a where
+                --                op :: (Ord a) => a -> a
+          (sel_tyvars, rho_ty) = splitForAllTys (idType sel_id)
+          op_ty                = funResultTy rho_ty
 
     toDmSpec NoDefMeth   = NoDM
     toDmSpec GenDefMeth  = GenericDM
hunk ./compiler/iface/MkIface.lhs 1357
 
 tyThingToIfaceDecl (ATyCon tycon)
   | isSynTyCon tycon
-  = IfaceSyn {	ifName    = getOccName tycon,
-		ifTyVars  = toIfaceTvBndrs tyvars,
-		ifSynRhs  = syn_rhs,
-	  	ifSynKind = syn_ki,
+  = IfaceSyn {  ifName    = getOccName tycon,
+                ifTyVars  = toIfaceTvBndrs tyvars,
+                ifSynRhs  = syn_rhs,
+                ifSynKind = syn_ki,
                 ifFamInst = famInstToIface (tyConFamInst_maybe tycon)
              }
 
hunk ./compiler/iface/MkIface.lhs 1365
   | isAlgTyCon tycon
-  = IfaceData {	ifName    = getOccName tycon,
-		ifTyVars  = toIfaceTvBndrs tyvars,
-		ifCtxt    = toIfaceContext (tyConStupidTheta tycon),
-		ifCons    = ifaceConDecls (algTyConRhs tycon),
-	  	ifRec     = boolToRecFlag (isRecursiveTyCon tycon),
-		ifGadtSyntax = isGadtSyntaxTyCon tycon,
-		ifGeneric = tyConHasGenerics tycon,
-		ifFamInst = famInstToIface (tyConFamInst_maybe tycon)}
+  = IfaceData { ifName    = getOccName tycon,
+                ifTyVars  = toIfaceTvBndrs tyvars,
+                ifCtxt    = toIfaceContext (tyConStupidTheta tycon),
+                ifCons    = ifaceConDecls (algTyConRhs tycon),
+                ifRec     = boolToRecFlag (isRecursiveTyCon tycon),
+                ifGadtSyntax = isGadtSyntaxTyCon tycon,
+                ifGeneric = tyConHasGenerics tycon,
+                ifFamInst = famInstToIface (tyConFamInst_maybe tycon)}
 
   | isForeignTyCon tycon
   = IfaceForeign { ifName    = getOccName tycon,
hunk ./compiler/iface/MkIface.lhs 1376
-	    	   ifExtName = tyConExtName tycon }
+                   ifExtName = tyConExtName tycon }
 
   | otherwise = pprPanic "toIfaceDecl" (ppr tycon)
   where
hunk ./compiler/iface/MkIface.lhs 1381
     tyvars = tyConTyVars tycon
-    (syn_rhs, syn_ki) 
+    (syn_rhs, syn_ki)
        = case synTyConRhs tycon of
hunk ./compiler/iface/MkIface.lhs 1383
-	    SynFamilyTyCon  -> (Nothing,               toIfaceType (synTyConResKind tycon))
-	    SynonymTyCon ty -> (Just (toIfaceType ty), toIfaceType (typeKind ty))
+            SynFamilyTyCon  -> (Nothing,               toIfaceType (synTyConResKind tycon))
+            SynonymTyCon ty -> (Just (toIfaceType ty), toIfaceType (typeKind ty))
 
hunk ./compiler/iface/MkIface.lhs 1386
-    ifaceConDecls (NewTyCon { data_con = con })     = 
+    ifaceConDecls (NewTyCon { data_con = con })     =
       IfNewTyCon  (ifaceConDecl con)
hunk ./compiler/iface/MkIface.lhs 1388
-    ifaceConDecls (DataTyCon { data_cons = cons })  = 
+    ifaceConDecls (DataTyCon { data_cons = cons })  =
       IfDataTyCon (map ifaceConDecl cons)
     ifaceConDecls DataFamilyTyCon {}                = IfOpenDataTyCon
hunk ./compiler/iface/MkIface.lhs 1391
-    ifaceConDecls AbstractTyCon			    = IfAbstractTyCon
-	-- The last case happens when a TyCon has been trimmed during tidying
-	-- Furthermore, tyThingToIfaceDecl is also used
-	-- in TcRnDriver for GHCi, when browsing a module, in which case the
-	-- AbstractTyCon case is perfectly sensible.
+    ifaceConDecls AbstractTyCon                     = IfAbstractTyCon
+        -- The last case happens when a TyCon has been trimmed during tidying
+        -- Furthermore, tyThingToIfaceDecl is also used
+        -- in TcRnDriver for GHCi, when browsing a module, in which case the
+        -- AbstractTyCon case is perfectly sensible.
 
hunk ./compiler/iface/MkIface.lhs 1397
-    ifaceConDecl data_con 
-	= IfCon   { ifConOcc   	 = getOccName (dataConName data_con),
-		    ifConInfix 	 = dataConIsInfix data_con,
-		    ifConWrapper = isJust (dataConWrapId_maybe data_con),
-		    ifConUnivTvs = toIfaceTvBndrs (dataConUnivTyVars data_con),
-		    ifConExTvs   = toIfaceTvBndrs (dataConExTyVars data_con),
-		    ifConEqSpec  = to_eq_spec (dataConEqSpec data_con),
-		    ifConCtxt    = toIfaceContext (dataConEqTheta data_con ++ dataConDictTheta data_con),
-		    ifConArgTys  = map toIfaceType (dataConOrigArgTys data_con),
-		    ifConFields  = map getOccName 
-				       (dataConFieldLabels data_con),
-		    ifConStricts = dataConStrictMarks data_con }
+    ifaceConDecl data_con
+        = IfCon   { ifConOcc     = getOccName (dataConName data_con),
+                    ifConInfix   = dataConIsInfix data_con,
+                    ifConWrapper = isJust (dataConWrapId_maybe data_con),
+                    ifConUnivTvs = toIfaceTvBndrs (dataConUnivTyVars data_con),
+                    ifConExTvs   = toIfaceTvBndrs (dataConExTyVars data_con),
+                    ifConEqSpec  = to_eq_spec (dataConEqSpec data_con),
+                    ifConCtxt    = toIfaceContext (dataConEqTheta data_con ++ dataConDictTheta data_con),
+                    ifConArgTys  = map toIfaceType (dataConOrigArgTys data_con),
+                    ifConFields  = map getOccName
+                                       (dataConFieldLabels data_con),
+                    ifConStricts = dataConStrictMarks data_con }
 
     to_eq_spec spec = [(getOccName tv, toIfaceType ty) | (tv,ty) <- spec]
 
hunk ./compiler/iface/MkIface.lhs 1413
     famInstToIface Nothing                    = Nothing
-    famInstToIface (Just (famTyCon, instTys)) = 
+    famInstToIface (Just (famTyCon, instTys)) =
       Just (toIfaceTyCon famTyCon, map toIfaceType instTys)
 
 tyThingToIfaceDecl (ADataCon dc)
hunk ./compiler/iface/MkIface.lhs 1417
- = pprPanic "toIfaceDecl" (ppr dc)	-- Should be trimmed out earlier
+ = pprPanic "toIfaceDecl" (ppr dc)      -- Should be trimmed out earlier
 
 
 getFS :: NamedThing a => a -> FastString
hunk ./compiler/iface/MkIface.lhs 1429
                                 is_cls = cls_name, is_tcs = mb_tcs })
   = ASSERT( cls_name == className cls )
     IfaceInst { ifDFun    = dfun_name,
-		ifOFlag   = oflag,
-		ifInstCls = cls_name,
-		ifInstTys = map do_rough mb_tcs,
-		ifInstOrph = orph }
+                ifOFlag   = oflag,
+                ifInstCls = cls_name,
+                ifInstTys = map do_rough mb_tcs,
+                ifInstOrph = orph }
   where
     do_rough Nothing  = Nothing
     do_rough (Just n) = Just (toIfaceTyCon_name n)
hunk ./compiler/iface/MkIface.lhs 1441
     mod       = ASSERT( isExternalName dfun_name ) nameModule dfun_name
     is_local name = nameIsLocalOrFrom mod name
 
-	-- Compute orphanhood.  See Note [Orphans] in IfaceSyn
+        -- Compute orphanhood.  See Note [Orphans] in IfaceSyn
     (_, _, cls, tys) = tcSplitDFunTy (idType dfun_id)
hunk ./compiler/iface/MkIface.lhs 1443
-		-- Slightly awkward: we need the Class to get the fundeps
+                -- Slightly awkward: we need the Class to get the fundeps
     (tvs, fds) = classTvsFds cls
     arg_names = [filterNameSet is_local (orphNamesOfType ty) | ty <- tys]
     orph | is_local cls_name = Just (nameOccName cls_name)
hunk ./compiler/iface/MkIface.lhs 1447
-	 | all isJust mb_ns  = ASSERT( not (null mb_ns) ) head mb_ns
-	 | otherwise	     = Nothing
-    
-    mb_ns :: [Maybe OccName]	-- One for each fundep; a locally-defined name
-				-- that is not in the "determined" arguments
+         | all isJust mb_ns  = ASSERT( not (null mb_ns) ) head mb_ns
+         | otherwise         = Nothing
+
+    mb_ns :: [Maybe OccName]    -- One for each fundep; a locally-defined name
+                                -- that is not in the "determined" arguments
     mb_ns | null fds   = [choose_one arg_names]
hunk ./compiler/iface/MkIface.lhs 1453
-	  | otherwise  = map do_one fds
+          | otherwise  = map do_one fds
     do_one (_ltvs, rtvs) = choose_one [ns | (tv,ns) <- tvs `zip` arg_names
                                           , not (tv `elem` rtvs)]
 
hunk ./compiler/iface/MkIface.lhs 1459
     choose_one :: [NameSet] -> Maybe OccName
     choose_one nss = case nameSetToList (unionManyNameSets nss) of
-			[]      -> Nothing
-			(n : _) -> Just (nameOccName n)
+                        []      -> Nothing
+                        (n : _) -> Just (nameOccName n)
 
 --------------------------
 famInstToIfaceFamInst :: FamInst -> IfaceFamInst
hunk ./compiler/iface/MkIface.lhs 1468
                                  fi_fam = fam,
                                  fi_tcs = mb_tcs })
   = IfaceFamInst { ifFamInstTyCon  = toIfaceTyCon tycon
-		 , ifFamInstFam    = fam
-		 , ifFamInstTys    = map do_rough mb_tcs }
+                 , ifFamInstFam    = fam
+                 , ifFamInstTys    = map do_rough mb_tcs }
   where
     do_rough Nothing  = Nothing
     do_rough (Just n) = Just (toIfaceTyCon_name n)
hunk ./compiler/iface/MkIface.lhs 1477
 --------------------------
 toIfaceLetBndr :: Id -> IfaceLetBndr
 toIfaceLetBndr id  = IfLetBndr (occNameFS (getOccName id))
-			       (toIfaceType (idType id)) 
-			       (toIfaceIdInfo (idInfo id))
-  -- Put into the interface file any IdInfo that CoreTidy.tidyLetBndr 
+                               (toIfaceType (idType id))
+                               (toIfaceIdInfo (idInfo id))
+  -- Put into the interface file any IdInfo that CoreTidy.tidyLetBndr
   -- has left on the Id.  See Note [IdInfo on nested let-bindings] in IfaceSyn
 
 --------------------------
hunk ./compiler/iface/MkIface.lhs 1484
 toIfaceIdDetails :: IdDetails -> IfaceIdDetails
-toIfaceIdDetails VanillaId 		        = IfVanillaId
+toIfaceIdDetails VanillaId                      = IfVanillaId
 toIfaceIdDetails (DFunId ns _)                  = IfDFunId ns
 toIfaceIdDetails (RecSelId { sel_naughty = n
hunk ./compiler/iface/MkIface.lhs 1487
-		 	   , sel_tycon = tc })  = IfRecSelId (toIfaceTyCon tc) n
-toIfaceIdDetails other	     		        = pprTrace "toIfaceIdDetails" (ppr other) 
+                           , sel_tycon = tc })  = IfRecSelId (toIfaceTyCon tc) n
+toIfaceIdDetails other                          = pprTrace "toIfaceIdDetails" (ppr other)
                                                   IfVanillaId   -- Unexpected
 
 toIfaceIdInfo :: IdInfo -> IfaceIdInfo
hunk ./compiler/iface/MkIface.lhs 1493
 toIfaceIdInfo id_info
-  = case catMaybes [arity_hsinfo, caf_hsinfo, strict_hsinfo, 
-	            inline_hsinfo,  unfold_hsinfo] of
+  = case catMaybes [arity_hsinfo, caf_hsinfo, strict_hsinfo,
+                    inline_hsinfo,  unfold_hsinfo] of
        []    -> NoInfo
        infos -> HasInfo infos
hunk ./compiler/iface/MkIface.lhs 1497
-	       -- NB: strictness must appear in the list before unfolding
-	       -- See TcIface.tcUnfolding
+               -- NB: strictness must appear in the list before unfolding
+               -- See TcIface.tcUnfolding
   where
     ------------  Arity  --------------
     arity_info = arityInfo id_info
hunk ./compiler/iface/MkIface.lhs 1503
     arity_hsinfo | arity_info == 0 = Nothing
-		 | otherwise       = Just (HsArity arity_info)
+                 | otherwise       = Just (HsArity arity_info)
 
     ------------ Caf Info --------------
     caf_info   = cafInfo id_info
hunk ./compiler/iface/MkIface.lhs 1508
     caf_hsinfo = case caf_info of
-		   NoCafRefs -> Just HsNoCafRefs
-		   _other    -> Nothing
+                   NoCafRefs -> Just HsNoCafRefs
+                   _other    -> Nothing
 
     ------------  Strictness  --------------
hunk ./compiler/iface/MkIface.lhs 1512
-	-- No point in explicitly exporting TopSig
+        -- No point in explicitly exporting TopSig
     strict_hsinfo = case strictnessInfo id_info of
hunk ./compiler/iface/MkIface.lhs 1514
-			Just sig | not (isTopSig sig) -> Just (HsStrictness sig)
-			_other			      -> Nothing
+                        Just sig | not (isTopSig sig) -> Just (HsStrictness sig)
+                        _other                        -> Nothing
 
     ------------  Unfolding  --------------
hunk ./compiler/iface/MkIface.lhs 1518
-    unfold_hsinfo = toIfUnfolding loop_breaker (unfoldingInfo id_info) 
+    unfold_hsinfo = toIfUnfolding loop_breaker (unfoldingInfo id_info)
     loop_breaker  = isNonRuleLoopBreaker (occInfo id_info)
hunk ./compiler/iface/MkIface.lhs 1520
-					
+
     ------------  Inline prag  --------------
     inline_prag = inlinePragInfo id_info
     inline_hsinfo | isDefaultInlinePragma inline_prag = Nothing
hunk ./compiler/iface/MkIface.lhs 1532
                                 , uf_src = src, uf_guidance = guidance })
   = Just $ HsUnfold lb $
     case src of
-	InlineStable
+        InlineStable
           -> case guidance of
                UnfWhen unsat_ok boring_ok -> IfInlineRule arity unsat_ok boring_ok if_rhs
                _other                     -> IfCoreUnfold True if_rhs
hunk ./compiler/iface/MkIface.lhs 1536
-	InlineWrapper w | isExternalName n -> IfExtWrapper arity n
-	                | otherwise        -> IfLclWrapper arity (getFS n)
-			where
+        InlineWrapper w | isExternalName n -> IfExtWrapper arity n
+                        | otherwise        -> IfLclWrapper arity (getFS n)
+                        where
                           n = idName w
         InlineCompulsory -> IfCompulsory if_rhs
         InlineRhs        -> IfCoreUnfold False if_rhs
hunk ./compiler/iface/MkIface.lhs 1542
-	-- Yes, even if guidance is UnfNever, expose the unfolding
-	-- If we didn't want to expose the unfolding, TidyPgm would
-	-- have stuck in NoUnfolding.  For supercompilation we want 
-	-- to see that unfolding!
+        -- Yes, even if guidance is UnfNever, expose the unfolding
+        -- If we didn't want to expose the unfolding, TidyPgm would
+        -- have stuck in NoUnfolding.  For supercompilation we want
+        -- to see that unfolding!
   where
     if_rhs = toIfaceExpr rhs
 
hunk ./compiler/iface/MkIface.lhs 1551
 toIfUnfolding lb (DFunUnfolding _ar _con ops)
   = Just (HsUnfold lb (IfDFunUnfold (map (fmap toIfaceExpr) ops)))
-      -- No need to serialise the data constructor; 
+      -- No need to serialise the data constructor;
       -- we can recover it from the type of the dfun
 
 toIfUnfolding _ _
hunk ./compiler/iface/MkIface.lhs 1563
   = pprTrace "toHsRule: builtin" (ppr fn) $
     bogusIfaceRule fn
 
-coreRuleToIfaceRule mod rule@(Rule { ru_name = name, ru_fn = fn, 
+coreRuleToIfaceRule mod rule@(Rule { ru_name = name, ru_fn = fn,
                                      ru_act = act, ru_bndrs = bndrs,
hunk ./compiler/iface/MkIface.lhs 1565
-	                             ru_args = args, ru_rhs = rhs, 
+                                     ru_args = args, ru_rhs = rhs,
                                      ru_auto = auto })
hunk ./compiler/iface/MkIface.lhs 1567
-  = IfaceRule { ifRuleName  = name, ifActivation = act, 
-		ifRuleBndrs = map toIfaceBndr bndrs,
-		ifRuleHead  = fn, 
-		ifRuleArgs  = map do_arg args,
-		ifRuleRhs   = toIfaceExpr rhs,
+  = IfaceRule { ifRuleName  = name, ifActivation = act,
+                ifRuleBndrs = map toIfaceBndr bndrs,
+                ifRuleHead  = fn,
+                ifRuleArgs  = map do_arg args,
+                ifRuleRhs   = toIfaceExpr rhs,
                 ifRuleAuto  = auto,
hunk ./compiler/iface/MkIface.lhs 1573
-		ifRuleOrph  = orph }
+                ifRuleOrph  = orph }
   where
hunk ./compiler/iface/MkIface.lhs 1575
-	-- For type args we must remove synonyms from the outermost
-	-- level.  Reason: so that when we read it back in we'll
-	-- construct the same ru_rough field as we have right now;
-	-- see tcIfaceRule
+        -- For type args we must remove synonyms from the outermost
+        -- level.  Reason: so that when we read it back in we'll
+        -- construct the same ru_rough field as we have right now;
+        -- see tcIfaceRule
     do_arg (Type ty) = IfaceType (toIfaceType (deNoteType ty))
     do_arg arg       = toIfaceExpr arg
 
hunk ./compiler/iface/MkIface.lhs 1582
-	-- Compute orphanhood.  See Note [Orphans] in IfaceSyn
-	-- A rule is an orphan only if none of the variables
-	-- mentioned on its left-hand side are locally defined
+        -- Compute orphanhood.  See Note [Orphans] in IfaceSyn
+        -- A rule is an orphan only if none of the variables
+        -- mentioned on its left-hand side are locally defined
     lhs_names = nameSetToList (ruleLhsOrphNames rule)
 
     orph = case filter (nameIsLocalOrFrom mod) lhs_names of
hunk ./compiler/iface/MkIface.lhs 1588
-			(n : _) -> Just (nameOccName n)
-			[]      -> Nothing
+                        (n : _) -> Just (nameOccName n)
+                        []      -> Nothing
 
 bogusIfaceRule :: Name -> IfaceRule
 bogusIfaceRule id_name
hunk ./compiler/iface/MkIface.lhs 1593
-  = IfaceRule { ifRuleName = fsLit "bogus", ifActivation = NeverActive,  
-	ifRuleBndrs = [], ifRuleHead = id_name, ifRuleArgs = [], 
-	ifRuleRhs = IfaceExt id_name, ifRuleOrph = Nothing, ifRuleAuto = True }
+  = IfaceRule { ifRuleName = fsLit "bogus", ifActivation = NeverActive,
+        ifRuleBndrs = [], ifRuleHead = id_name, ifRuleArgs = [],
+        ifRuleRhs = IfaceExt id_name, ifRuleOrph = Nothing, ifRuleAuto = True }
 
 ---------------------
 toIfaceExpr :: CoreExpr -> IfaceExpr
hunk ./compiler/iface/MkIface.lhs 1627
 ---------------------
 toIfaceCon :: AltCon -> IfaceConAlt
 toIfaceCon (DataAlt dc) | isTupleTyCon tc = IfaceTupleAlt (tupleTyConBoxity tc)
-	   		| otherwise       = IfaceDataAlt (getName dc)
-	   		where
-	   		  tc = dataConTyCon dc
-	   
+                        | otherwise       = IfaceDataAlt (getName dc)
+                        where
+                          tc = dataConTyCon dc
+
 toIfaceCon (LitAlt l) = IfaceLitAlt l
 toIfaceCon DEFAULT    = IfaceDefault
 
hunk ./compiler/iface/MkIface.lhs 1639
 toIfaceApp (App f a) as = toIfaceApp f (a:as)
 toIfaceApp (Var v) as
   = case isDataConWorkId_maybe v of
-	-- We convert the *worker* for tuples into IfaceTuples
-	Just dc |  isTupleTyCon tc && saturated 
-		-> IfaceTuple (tupleTyConBoxity tc) tup_args
-	  where
-	    val_args  = dropWhile isTypeArg as
-	    saturated = val_args `lengthIs` idArity v
-	    tup_args  = map toIfaceExpr val_args
-	    tc	      = dataConTyCon dc
+        -- We convert the *worker* for tuples into IfaceTuples
+        Just dc |  isTupleTyCon tc && saturated
+                -> IfaceTuple (tupleTyConBoxity tc) tup_args
+          where
+            val_args  = dropWhile isTypeArg as
+            saturated = val_args `lengthIs` idArity v
+            tup_args  = map toIfaceExpr val_args
+            tc        = dataConTyCon dc
 
         _ -> mkIfaceApps (toIfaceVar v) as
 
hunk ./compiler/iface/MkIface.lhs 1657
 
 ---------------------
 toIfaceVar :: Id -> IfaceExpr
-toIfaceVar v 
+toIfaceVar v
   | Just fcall <- isFCallId_maybe v = IfaceFCall fcall (toIfaceType (idType v))
hunk ./compiler/iface/MkIface.lhs 1659
-	  -- Foreign calls have special syntax
-  | isExternalName name		    = IfaceExt name
+          -- Foreign calls have special syntax
+  | isExternalName name             = IfaceExt name
   | Just (TickBox m ix) <- isTickBoxOp_maybe v
hunk ./compiler/iface/MkIface.lhs 1662
-				    = IfaceTick m ix
-  | otherwise			    = IfaceLcl (getFS name)
+                                    = IfaceTick m ix
+  | otherwise                       = IfaceLcl (getFS name)
   where
     name = idName v
 \end{code}
hunk ./compiler/main/HeaderInfo.hs 21
 
 import RdrName
 import HscTypes
-import Parser		( parseHeader )
+import Parser           ( parseHeader )
 import Lexer
 import FastString
 import HsSyn
hunk ./compiler/main/HeaderInfo.hs 35
 import Outputable
 import Pretty           ()
 import Maybes
-import Bag		( emptyBag, listToBag, unitBag )
+import Bag              ( emptyBag, listToBag, unitBag )
 import MonadUtils
 import Exception
 
hunk ./compiler/main/HeaderInfo.hs 70
       if errorsFound dflags ms
         then throwIO $ mkSrcErr errs
         else
-	  case rdr_module of
-	    L _ (HsModule mb_mod _ imps _ _ _) ->
-	      let
+          case rdr_module of
+            L _ (HsModule mb_mod _ imps _ _ _) ->
+              let
                 main_loc = mkSrcLoc (mkFastString source_filename) 1 1
hunk ./compiler/main/HeaderInfo.hs 74
-		mod = mb_mod `orElse` L (srcLocSpan main_loc) mAIN_NAME
-	        (src_idecls, ord_idecls) = partition (ideclSource.unLoc) imps
+                mod = mb_mod `orElse` L (srcLocSpan main_loc) mAIN_NAME
+                (src_idecls, ord_idecls) = partition (ideclSource.unLoc) imps
 
hunk ./compiler/main/HeaderInfo.hs 77
-		     -- GHC.Prim doesn't exist physically, so don't go looking for it.
-		ordinary_imps = filter ((/= moduleName gHC_PRIM) . unLoc . ideclName . unLoc) 
-					ord_idecls
+                     -- GHC.Prim doesn't exist physically, so don't go looking for it.
+                ordinary_imps = filter ((/= moduleName gHC_PRIM) . unLoc . ideclName . unLoc)
+                                        ord_idecls
 
                 implicit_prelude = xopt Opt_ImplicitPrelude dflags
                 implicit_imports = mkPrelImports (unLoc mod) implicit_prelude imps
hunk ./compiler/main/HeaderInfo.hs 83
-	      in
-	      return (src_idecls, implicit_imports ++ ordinary_imps, mod)
+              in
+              return (src_idecls, implicit_imports ++ ordinary_imps, mod)
 
 mkPrelImports :: ModuleName -> Bool -> [LImportDecl RdrName]
               -> [LImportDecl RdrName]
hunk ./compiler/main/HeaderInfo.hs 102
   where
       explicit_prelude_import
        = notNull [ () | L _ (ImportDecl mod Nothing _ _ _ _ _) <- import_decls,
-	           unLoc mod == pRELUDE_NAME ]
+                   unLoc mod == pRELUDE_NAME ]
 
       preludeImportDecl :: LImportDecl RdrName
       preludeImportDecl
hunk ./compiler/main/HeaderInfo.hs 107
         = L loc $
-	  ImportDecl (L loc pRELUDE_NAME)
-               Nothing {- no specific package -}
-	       False {- Not a boot interface -}
-	       False {- Not a safe interface -}
-	       False	{- Not qualified -}
-	       Nothing	{- No "as" -}
-	       Nothing	{- No import list -}
+          ImportDecl (L loc pRELUDE_NAME)
+               Nothing  {- No specific package -}
+               False    {- Not a boot interface -}
+               False    {- Not a safe interface -}
+               False    {- Not qualified -}
+               Nothing  {- No "as" -}
+               Nothing  {- No import list -}
 
       loc = mkGeneralSrcSpan (fsLit "Implicit import declaration")
 
hunk ./compiler/main/HeaderInfo.hs 132
                    -> IO [Located String] -- ^ Parsed options, if any.
 getOptionsFromFile dflags filename
     = Exception.bracket
-	      (openBinaryFile filename ReadMode)
+              (openBinaryFile filename ReadMode)
               (hClose)
               (\handle -> do
                   opts <- fmap getOptions' $ lazyGetToks dflags filename handle
hunk ./compiler/main/HeaderInfo.hs 205
             -> [Located String]     -- Options.
 getOptions' toks
     = parseToks toks
-    where 
+    where
           getToken (L _loc tok) = tok
           getLoc (L loc _tok) = loc
 
hunk ./compiler/main/HeaderInfo.hs 295
 optionsErrorMsgs :: [String] -> [Located String] -> FilePath -> Messages
 optionsErrorMsgs unhandled_flags flags_lines _filename
   = (emptyBag, listToBag (map mkMsg unhandled_flags_lines))
-  where	unhandled_flags_lines = [ L l f | f <- unhandled_flags, 
-					  L l f' <- flags_lines, f == f' ]
-        mkMsg (L flagSpan flag) = 
+  where unhandled_flags_lines = [ L l f | f <- unhandled_flags,
+                                          L l f' <- flags_lines, f == f' ]
+        mkMsg (L flagSpan flag) =
             ErrUtils.mkPlainErrMsg flagSpan $
                     text "unknown flag in  {-# OPTIONS_GHC #-} pragma:" <+> text flag
 
hunk ./compiler/main/HscTypes.lhs 8
 
 \begin{code}
 -- | Types for the per-module compiler
-module HscTypes ( 
-	-- * compilation state
+module HscTypes (
+        -- * compilation state
         HscEnv(..), hscEPS,
hunk ./compiler/main/HscTypes.lhs 11
-	FinderCache, FindResult(..), ModLocationCache,
-	Target(..), TargetId(..), pprTarget, pprTargetId,
-	ModuleGraph, emptyMG,
+        FinderCache, FindResult(..), ModLocationCache,
+        Target(..), TargetId(..), pprTarget, pprTargetId,
+        ModuleGraph, emptyMG,
 
         -- * Information about modules
hunk ./compiler/main/HscTypes.lhs 16
-	ModDetails(..),	emptyModDetails,
-	ModGuts(..), CgGuts(..), ForeignStubs(..),
+        ModDetails(..), emptyModDetails,
+        ModGuts(..), CgGuts(..), ForeignStubs(..),
         ImportedMods,
 
hunk ./compiler/main/HscTypes.lhs 20
-	ModSummary(..), ms_mod_name, showModMsg, isBootSummary,
-	msHsFilePath, msHiFilePath, msObjFilePath,
+        ModSummary(..), ms_mod_name, showModMsg, isBootSummary,
+        msHsFilePath, msHiFilePath, msObjFilePath,
 
         -- * Information about the module being compiled
hunk ./compiler/main/HscTypes.lhs 24
-	HscSource(..), isHsBoot, hscSourceString,	-- Re-exported from DriverPhases
-	
-	-- * State relating to modules in this package
-	HomePackageTable, HomeModInfo(..), emptyHomePackageTable,
-	hptInstances, hptRules, hptVectInfo,
-	
-	-- * State relating to known packages
-	ExternalPackageState(..), EpsStats(..), addEpsInStats,
-	PackageTypeEnv, PackageIfaceTable, emptyPackageIfaceTable,
-	lookupIfaceByModule, emptyModIface,
-	
-	PackageInstEnv, PackageRuleBase,
+        HscSource(..), isHsBoot, hscSourceString,       -- Re-exported from DriverPhases
 
hunk ./compiler/main/HscTypes.lhs 26
+        -- * State relating to modules in this package
+        HomePackageTable, HomeModInfo(..), emptyHomePackageTable,
+        hptInstances, hptRules, hptVectInfo,
+
+        -- * State relating to known packages
+        ExternalPackageState(..), EpsStats(..), addEpsInStats,
+        PackageTypeEnv, PackageIfaceTable, emptyPackageIfaceTable,
+        lookupIfaceByModule, emptyModIface,
+
+        PackageInstEnv, PackageRuleBase,
 
         -- * Annotations
         prepareAnnotations,
hunk ./compiler/main/HscTypes.lhs 41
 
         -- * Interactive context
-	InteractiveContext(..), emptyInteractiveContext, 
-	icPrintUnqual, extendInteractiveContext,
+        InteractiveContext(..), emptyInteractiveContext,
+        icPrintUnqual, extendInteractiveContext,
         substInteractiveContext,
         mkPrintUnqualified, pprModulePrefix,
 
hunk ./compiler/main/HscTypes.lhs 46
-	-- * Interfaces
-	ModIface(..), mkIfaceWarnCache, mkIfaceHashCache, mkIfaceFixCache,
-	emptyIfaceWarnCache,
+        -- * Interfaces
+        ModIface(..), mkIfaceWarnCache, mkIfaceHashCache, mkIfaceFixCache,
+        emptyIfaceWarnCache,
 
         -- * Fixity
hunk ./compiler/main/HscTypes.lhs 51
-	FixityEnv, FixItem(..), lookupFixity, emptyFixityEnv,
+        FixityEnv, FixItem(..), lookupFixity, emptyFixityEnv,
 
         -- * TyThings and type environments
hunk ./compiler/main/HscTypes.lhs 54
-	TyThing(..),
-	tyThingClass, tyThingTyCon, tyThingDataCon, tyThingId,
-	implicitTyThings, isImplicitTyThing,
-	
-	TypeEnv, lookupType, lookupTypeHscEnv, mkTypeEnv, emptyTypeEnv,
-	extendTypeEnv, extendTypeEnvList, extendTypeEnvWithIds, lookupTypeEnv,
-	typeEnvElts, typeEnvClasses, typeEnvTyCons, typeEnvIds,
-	typeEnvDataCons,
+        TyThing(..),
+        tyThingClass, tyThingTyCon, tyThingDataCon, tyThingId,
+        implicitTyThings, isImplicitTyThing,
+
+        TypeEnv, lookupType, lookupTypeHscEnv, mkTypeEnv, emptyTypeEnv,
+        extendTypeEnv, extendTypeEnvList, extendTypeEnvWithIds, lookupTypeEnv,
+        typeEnvElts, typeEnvClasses, typeEnvTyCons, typeEnvIds,
+        typeEnvDataCons,
 
         -- * MonadThings
         MonadThings(..),
hunk ./compiler/main/HscTypes.lhs 67
 
         -- * Information on imports and exports
-	WhetherHasOrphans, IsBootInterface, Usage(..), 
-	Dependencies(..), noDependencies,
-	NameCache(..), OrigNameCache, OrigIParamCache,
-	Avails, availsToNameSet, availsToNameEnv, availName, availNames,
-	GenAvailInfo(..), AvailInfo, RdrAvailInfo, 
-	IfaceExport,
+        WhetherHasOrphans, IsBootInterface, Usage(..),
+        Dependencies(..), noDependencies,
+        NameCache(..), OrigNameCache, OrigIParamCache,
+        Avails, availsToNameSet, availsToNameEnv, availName, availNames,
+        GenAvailInfo(..), AvailInfo, RdrAvailInfo,
+        IfaceExport,
+
+        -- * Warnings
+        Warnings(..), WarningTxt(..), plusWarns,
 
hunk ./compiler/main/HscTypes.lhs 77
-	-- * Warnings
-	Warnings(..), WarningTxt(..), plusWarns,
+        -- * Linker stuff
+        Linkable(..), isObjectLinkable,
+        Unlinked(..), CompiledByteCode,
+        isObject, nameOfObject, isInterpretable, byteCodeOfObject,
 
hunk ./compiler/main/HscTypes.lhs 82
-	-- * Linker stuff
-	Linkable(..), isObjectLinkable,
-	Unlinked(..), CompiledByteCode,
-	isObject, nameOfObject, isInterpretable, byteCodeOfObject,
-        
         -- * Program coverage
         HpcInfo(..), emptyHpcInfo, isHpcUsed, AnyHpcUsage,
 
hunk ./compiler/main/HscTypes.lhs 89
         ModBreaks (..), BreakIndex, emptyModBreaks,
 
         -- * Vectorisation information
-        VectInfo(..), IfaceVectInfo(..), noVectInfo, plusVectInfo, 
+        VectInfo(..), IfaceVectInfo(..), noVectInfo, plusVectInfo,
         noIfaceVectInfo,
 
         -- * Safe Haskell information
hunk ./compiler/main/HscTypes.lhs 105
 #include "HsVersions.h"
 
 #ifdef GHCI
-import ByteCodeAsm	( CompiledByteCode )
+import ByteCodeAsm      ( CompiledByteCode )
 import {-# SOURCE #-}  InteractiveEval ( Resume )
 #endif
 
hunk ./compiler/main/HscTypes.lhs 113
 import RdrName
 import Name
 import NameEnv
-import NameSet	
+import NameSet
 import Module
hunk ./compiler/main/HscTypes.lhs 115
-import InstEnv		( InstEnv, Instance )
-import FamInstEnv	( FamInstEnv, FamInst )
-import Rules		( RuleBase )
-import CoreSyn		( CoreBind )
+import InstEnv          ( InstEnv, Instance )
+import FamInstEnv       ( FamInstEnv, FamInst )
+import Rules            ( RuleBase )
+import CoreSyn          ( CoreBind )
 import VarEnv
 import Var
 import Id
hunk ./compiler/main/HscTypes.lhs 122
-import Type		
+import Type
 
 import Annotations
hunk ./compiler/main/HscTypes.lhs 125
-import Class		( Class, classAllSelIds, classATs, classTyCon )
+import Class            ( Class, classAllSelIds, classATs, classTyCon )
 import TyCon
hunk ./compiler/main/HscTypes.lhs 127
-import DataCon		( DataCon, dataConImplicitIds, dataConWrapId )
-import PrelNames	( gHC_PRIM )
+import DataCon          ( DataCon, dataConImplicitIds, dataConWrapId )
+import PrelNames        ( gHC_PRIM )
 import Packages hiding ( Version(..) )
hunk ./compiler/main/HscTypes.lhs 130
-import DynFlags		( DynFlags(..), isOneShot, HscTarget (..), dopt,
+import DynFlags         ( DynFlags(..), isOneShot, HscTarget (..), dopt,
                           DynFlag(..), SafeHaskellMode(..) )
hunk ./compiler/main/HscTypes.lhs 132
-import DriverPhases	( HscSource(..), isHsBoot, hscSourceString, Phase )
-import BasicTypes	( IPName, defaultFixity, WarningTxt(..) )
-import OptimizationFuel	( OptFuelState )
+import DriverPhases     ( HscSource(..), isHsBoot, hscSourceString, Phase )
+import BasicTypes       ( IPName, defaultFixity, WarningTxt(..) )
+import OptimizationFuel ( OptFuelState )
 import IfaceSyn
hunk ./compiler/main/HscTypes.lhs 136
-import CoreSyn		( CoreRule )
-import Maybes		( orElse, expectJust, catMaybes )
+import CoreSyn          ( CoreRule )
+import Maybes           ( orElse, expectJust, catMaybes )
 import Outputable
 import BreakArray
hunk ./compiler/main/HscTypes.lhs 140
-import SrcLoc		( SrcSpan, Located(..) )
-import UniqFM		( lookupUFM, eltsUFM, emptyUFM )
-import UniqSupply	( UniqSupply )
+import SrcLoc           ( SrcSpan, Located(..) )
+import UniqFM           ( lookupUFM, eltsUFM, emptyUFM )
+import UniqSupply       ( UniqSupply )
 import FastString
hunk ./compiler/main/HscTypes.lhs 144
-import StringBuffer	( StringBuffer )
+import StringBuffer     ( StringBuffer )
 import Fingerprint
 import MonadUtils
 import Data.Dynamic     ( Typeable )
hunk ./compiler/main/HscTypes.lhs 153
 import ErrUtils
 
 import System.FilePath
-import System.Time	( ClockTime )
+import System.Time      ( ClockTime )
 import Data.IORef
 import Data.Array       ( Array, array )
 import Data.List
hunk ./compiler/main/HscTypes.lhs 249
  = when (dopt Opt_WarnDeprecatedFlags dflags) $ do
         -- It would be nicer if warns :: [Located Message], but that
         -- has circular import problems.
-      let bag = listToBag [ mkPlainWarnMsg loc (text warn) 
+      let bag = listToBag [ mkPlainWarnMsg loc (text warn)
                           | L loc warn <- warns ]
 
       printOrThrowWarnings dflags bag
hunk ./compiler/main/HscTypes.lhs 266
 -- module, the driver would invoke hsc on the source code... so nowadays
 -- we think of hsc as the layer of the compiler that deals with compiling
 -- a single module.
-data HscEnv 
-  = HscEnv { 
-	hsc_dflags :: DynFlags,
-		-- ^ The dynamic flag settings
+data HscEnv
+  = HscEnv {
+        hsc_dflags :: DynFlags,
+                -- ^ The dynamic flag settings
 
hunk ./compiler/main/HscTypes.lhs 271
-	hsc_targets :: [Target],
-		-- ^ The targets (or roots) of the current session
+        hsc_targets :: [Target],
+                -- ^ The targets (or roots) of the current session
 
hunk ./compiler/main/HscTypes.lhs 274
-	hsc_mod_graph :: ModuleGraph,
-		-- ^ The module graph of the current session
+        hsc_mod_graph :: ModuleGraph,
+                -- ^ The module graph of the current session
 
hunk ./compiler/main/HscTypes.lhs 277
-	hsc_IC :: InteractiveContext,
-		-- ^ The context for evaluating interactive statements
+        hsc_IC :: InteractiveContext,
+                -- ^ The context for evaluating interactive statements
 
hunk ./compiler/main/HscTypes.lhs 280
-	hsc_HPT    :: HomePackageTable,
-		-- ^ The home package table describes already-compiled
-		-- home-package modules, /excluding/ the module we 
-		-- are compiling right now.
-		-- (In one-shot mode the current module is the only
-		--  home-package module, so hsc_HPT is empty.  All other
-		--  modules count as \"external-package\" modules.
-		--  However, even in GHCi mode, hi-boot interfaces are
-		--  demand-loaded into the external-package table.)
-		--
-		-- 'hsc_HPT' is not mutable because we only demand-load 
-		-- external packages; the home package is eagerly 
-		-- loaded, module by module, by the compilation manager.
-		--	
-		-- The HPT may contain modules compiled earlier by @--make@
-		-- but not actually below the current module in the dependency
-		-- graph.
+        hsc_HPT    :: HomePackageTable,
+                -- ^ The home package table describes already-compiled
+                -- home-package modules, /excluding/ the module we
+                -- are compiling right now.
+                -- (In one-shot mode the current module is the only
+                --  home-package module, so hsc_HPT is empty.  All other
+                --  modules count as \"external-package\" modules.
+                --  However, even in GHCi mode, hi-boot interfaces are
+                --  demand-loaded into the external-package table.)
+                --
+                -- 'hsc_HPT' is not mutable because we only demand-load
+                -- external packages; the home package is eagerly
+                -- loaded, module by module, by the compilation manager.
+                --
+                -- The HPT may contain modules compiled earlier by @--make@
+                -- but not actually below the current module in the dependency
+                -- graph.
 
hunk ./compiler/main/HscTypes.lhs 298
-		-- (This changes a previous invariant: changed Jan 05.)
-	
-	hsc_EPS	:: {-# UNPACK #-} !(IORef ExternalPackageState),
-	        -- ^ Information about the currently loaded external packages.
-	        -- This is mutable because packages will be demand-loaded during
-	        -- a compilation run as required.
-	
-	hsc_NC	:: {-# UNPACK #-} !(IORef NameCache),
-		-- ^ As with 'hsc_EPS', this is side-effected by compiling to
-		-- reflect sucking in interface files.  They cache the state of
-		-- external interface files, in effect.
+                -- (This changes a previous invariant: changed Jan 05.)
 
hunk ./compiler/main/HscTypes.lhs 300
-	hsc_FC   :: {-# UNPACK #-} !(IORef FinderCache),
-	        -- ^ The cached result of performing finding in the file system
-	hsc_MLC  :: {-# UNPACK #-} !(IORef ModLocationCache),
-		-- ^ This caches the location of modules, so we don't have to 
-		-- search the filesystem multiple times. See also 'hsc_FC'.
+        hsc_EPS :: {-# UNPACK #-} !(IORef ExternalPackageState),
+                -- ^ Information about the currently loaded external packages.
+                -- This is mutable because packages will be demand-loaded during
+                -- a compilation run as required.
+
+        hsc_NC  :: {-# UNPACK #-} !(IORef NameCache),
+                -- ^ As with 'hsc_EPS', this is side-effected by compiling to
+                -- reflect sucking in interface files.  They cache the state of
+                -- external interface files, in effect.
+
+        hsc_FC   :: {-# UNPACK #-} !(IORef FinderCache),
+                -- ^ The cached result of performing finding in the file system
+        hsc_MLC  :: {-# UNPACK #-} !(IORef ModLocationCache),
+                -- ^ This caches the location of modules, so we don't have to
+                -- search the filesystem multiple times. See also 'hsc_FC'.
 
         hsc_OptFuel :: OptFuelState,
                 -- ^ Settings to control the use of \"optimization fuel\":
hunk ./compiler/main/HscTypes.lhs 323
 
         hsc_type_env_var :: Maybe (Module, IORef TypeEnv)
                 -- ^ Used for one-shot compilation only, to initialise
-                -- the 'IfGblEnv'. See 'TcRnTypes.tcg_type_env_var' for 
+                -- the 'IfGblEnv'. See 'TcRnTypes.tcg_type_env_var' for
                 -- 'TcRunTypes.TcGblEnv'
  }
 
hunk ./compiler/main/HscTypes.lhs 345
 
 data TargetId
   = TargetModule ModuleName
-	-- ^ A module name: search for the file
+        -- ^ A module name: search for the file
   | TargetFile FilePath (Maybe Phase)
hunk ./compiler/main/HscTypes.lhs 347
-	-- ^ A filename: preprocess & parse it to find the module name.
-	-- If specified, the Phase indicates how to compile this file
-	-- (which phase to start from).  Nothing indicates the starting phase
-	-- should be determined from the suffix of the filename.
+        -- ^ A filename: preprocess & parse it to find the module name.
+        -- If specified, the Phase indicates how to compile this file
+        -- (which phase to start from).  Nothing indicates the starting phase
+        -- should be determined from the suffix of the filename.
   deriving Eq
 
 pprTarget :: Target -> SDoc
hunk ./compiler/main/HscTypes.lhs 354
-pprTarget (Target id obj _) = 
+pprTarget (Target id obj _) =
    (if obj then char '*' else empty) <> pprTargetId id
 
 instance Outputable Target where
hunk ./compiler/main/HscTypes.lhs 369
 
 -- | Helps us find information about modules in the home package
 type HomePackageTable  = ModuleNameEnv HomeModInfo
-	-- Domain = modules in the home package that have been fully compiled
-	-- "home" package name cached here for convenience
+        -- Domain = modules in the home package that have been fully compiled
+        -- "home" package name cached here for convenience
 
 -- | Helps us find information about modules in the imported packages
 type PackageIfaceTable = ModuleEnv ModIface
hunk ./compiler/main/HscTypes.lhs 374
-	-- Domain = modules in the imported packages
+        -- Domain = modules in the imported packages
 
 emptyHomePackageTable :: HomePackageTable
 emptyHomePackageTable  = emptyUFM
hunk ./compiler/main/HscTypes.lhs 383
 emptyPackageIfaceTable = emptyModuleEnv
 
 -- | Information about modules in the package being compiled
-data HomeModInfo 
+data HomeModInfo
   = HomeModInfo {
       hm_iface    :: !ModIface,
         -- ^ The basic loaded interface file: every loaded module has one of
hunk ./compiler/main/HscTypes.lhs 390
         -- these, even if it is imported from another package
       hm_details  :: !ModDetails,
         -- ^ Extra information that has been created from the 'ModIface' for
-	-- the module, typically during typechecking
+        -- the module, typically during typechecking
       hm_linkable :: !(Maybe Linkable)
         -- ^ The actual artifact we would like to link to access things in
hunk ./compiler/main/HscTypes.lhs 393
-	-- this module.
-	--
-	-- 'hm_linkable' might be Nothing:
-	--
-	--   1. If this is an .hs-boot module
-	--
-	--   2. Temporarily during compilation if we pruned away
-	--      the old linkable because it was out of date.
-	--
-	-- After a complete compilation ('GHC.load'), all 'hm_linkable' fields
-	-- in the 'HomePackageTable' will be @Just@.
-	--
-	-- When re-linking a module ('HscMain.HscNoRecomp'), we construct the
-	-- 'HomeModInfo' by building a new 'ModDetails' from the old
-	-- 'ModIface' (only).
+        -- this module.
+        --
+        -- 'hm_linkable' might be Nothing:
+        --
+        --   1. If this is an .hs-boot module
+        --
+        --   2. Temporarily during compilation if we pruned away
+        --      the old linkable because it was out of date.
+        --
+        -- After a complete compilation ('GHC.load'), all 'hm_linkable' fields
+        -- in the 'HomePackageTable' will be @Just@.
+        --
+        -- When re-linking a module ('HscMain.HscNoRecomp'), we construct the
+        -- 'HomeModInfo' by building a new 'ModDetails' from the old
+        -- 'ModIface' (only).
     }
 
 -- | Find the 'ModIface' for a 'Module', searching in both the loaded home
hunk ./compiler/main/HscTypes.lhs 413
 -- and external package module information
 lookupIfaceByModule
-	:: DynFlags
-	-> HomePackageTable
-	-> PackageIfaceTable
-	-> Module
-	-> Maybe ModIface
+        :: DynFlags
+        -> HomePackageTable
+        -> PackageIfaceTable
+        -> Module
+        -> Maybe ModIface
 lookupIfaceByModule dflags hpt pit mod
   | modulePackageId mod == thisPackage dflags
hunk ./compiler/main/HscTypes.lhs 420
-  = 	-- The module comes from the home package, so look first
-	-- in the HPT.  If it's not from the home package it's wrong to look
-	-- in the HPT, because the HPT is indexed by *ModuleName* not Module
-    fmap hm_iface (lookupUFM hpt (moduleName mod)) 
+  =     -- The module comes from the home package, so look first
+        -- in the HPT.  If it's not from the home package it's wrong to look
+        -- in the HPT, because the HPT is indexed by *ModuleName* not Module
+    fmap hm_iface (lookupUFM hpt (moduleName mod))
     `mplus` lookupModuleEnv pit mod
 
hunk ./compiler/main/HscTypes.lhs 426
-  | otherwise = lookupModuleEnv pit mod		-- Look in PIT only 
+  | otherwise = lookupModuleEnv pit mod         -- Look in PIT only
 
 -- If the module does come from the home package, why do we look in the PIT as well?
 -- (a) In OneShot mode, even home-package modules accumulate in the PIT
hunk ./compiler/main/HscTypes.lhs 453
 hptVectInfo :: HscEnv -> VectInfo
 -- ^ Get the combined VectInfo of all modules in the home package table.  In
 -- contrast to instances and rules, we don't care whether the modules are
--- \"below\" us in the dependency sense.  The VectInfo of those modules not \"below\" 
+-- \"below\" us in the dependency sense.  The VectInfo of those modules not \"below\"
 -- us does not affect the compilation of the current module.
 hptVectInfo = concatVectInfo . hptAllThings ((: []) . md_vect_info . hm_details)
 
hunk ./compiler/main/HscTypes.lhs 476
 hptSomeThingsBelowUs extract include_hi_boot hsc_env deps
  | isOneShot (ghcMode (hsc_dflags hsc_env)) = []
   | otherwise
-  = let 
-	hpt = hsc_HPT hsc_env
+  = let
+        hpt = hsc_HPT hsc_env
     in
     [ thing
hunk ./compiler/main/HscTypes.lhs 480
-    |	-- Find each non-hi-boot module below me
+    |   -- Find each non-hi-boot module below me
       (mod, is_boot_mod) <- deps
     , include_hi_boot || not is_boot_mod
 
hunk ./compiler/main/HscTypes.lhs 484
-	-- unsavoury: when compiling the base package with --make, we
-	-- sometimes try to look up RULES etc for GHC.Prim.  GHC.Prim won't
-	-- be in the HPT, because we never compile it; it's in the EPT
-	-- instead.  ToDo: clean up, and remove this slightly bogus
-	-- filter:
+        -- unsavoury: when compiling the base package with --make, we
+        -- sometimes try to look up RULES etc for GHC.Prim.  GHC.Prim won't
+        -- be in the HPT, because we never compile it; it's in the EPT
+        -- instead.  ToDo: clean up, and remove this slightly bogus
+        -- filter:
     , mod /= moduleName gHC_PRIM
 
hunk ./compiler/main/HscTypes.lhs 491
-	-- Look it up in the HPT
+        -- Look it up in the HPT
     , let things = case lookupUFM hpt mod of
hunk ./compiler/main/HscTypes.lhs 493
-		    Just info -> extract info
-		    Nothing -> pprTrace "WARNING in hptSomeThingsBelowUs" msg [] 
-	  msg = vcat [ptext (sLit "missing module") <+> ppr mod,
-		      ptext (sLit "Probable cause: out-of-date interface files")]
-			-- This really shouldn't happen, but see Trac #962
+                    Just info -> extract info
+                    Nothing -> pprTrace "WARNING in hptSomeThingsBelowUs" msg []
+          msg = vcat [ptext (sLit "missing module") <+> ppr mod,
+                      ptext (sLit "Probable cause: out-of-date interface files")]
+                        -- This really shouldn't happen, but see Trac #962
 
hunk ./compiler/main/HscTypes.lhs 499
-	-- And get its dfuns
+        -- And get its dfuns
     , thing <- things ]
 \end{code}
 
hunk ./compiler/main/HscTypes.lhs 504
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Dealing with Annotations}
hunk ./compiler/main/HscTypes.lhs 506
-%*									*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 511
 prepareAnnotations :: HscEnv -> Maybe ModGuts -> IO AnnEnv
--- ^ Deal with gathering annotations in from all possible places 
+-- ^ Deal with gathering annotations in from all possible places
 --   and combining them into a single 'AnnEnv'
 prepareAnnotations hsc_env mb_guts
   = do { eps <- hscEPS hsc_env
hunk ./compiler/main/HscTypes.lhs 522
         -- entries regardless of dependency ordering.
             home_pkg_anns  = (mkAnnEnv . hptAnns hsc_env) $ fmap (dep_mods . mg_deps) mb_guts
             other_pkg_anns = eps_ann_env eps
-            ann_env        = foldl1' plusAnnEnv $ catMaybes [mb_this_module_anns, 
-                                                             Just home_pkg_anns, 
+            ann_env        = foldl1' plusAnnEnv $ catMaybes [mb_this_module_anns,
+                                                             Just home_pkg_anns,
                                                              Just other_pkg_anns]
 
        ; return ann_env }
hunk ./compiler/main/HscTypes.lhs 530
 \end{code}
 
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{The Finder cache}
hunk ./compiler/main/HscTypes.lhs 532
-%*									*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 549
 -- | The result of searching for an imported module.
 data FindResult
   = Found ModLocation Module
-	-- ^ The module was found
+        -- ^ The module was found
   | NoPackage PackageId
hunk ./compiler/main/HscTypes.lhs 551
-	-- ^ The requested package was not found
+        -- ^ The requested package was not found
   | FoundMultiple [PackageId]
hunk ./compiler/main/HscTypes.lhs 553
-	-- ^ _Error_: both in multiple packages
+        -- ^ _Error_: both in multiple packages
 
   | NotFound          -- Not found
       { fr_paths       :: [FilePath]       -- Places where I looked
hunk ./compiler/main/HscTypes.lhs 578
 \end{code}
 
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Symbol tables and Module details}
hunk ./compiler/main/HscTypes.lhs 580
-%*									*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 584
--- | A 'ModIface' plus a 'ModDetails' summarises everything we know 
+-- | A 'ModIface' plus a 'ModDetails' summarises everything we know
 -- about a compiled module.  The 'ModIface' is the stuff *before* linking,
hunk ./compiler/main/HscTypes.lhs 586
--- and can be written out to an interface file. The 'ModDetails is after 
+-- and can be written out to an interface file. The 'ModDetails is after
 -- linking and can be completely recovered from just the 'ModIface'.
hunk ./compiler/main/HscTypes.lhs 588
--- 
+--
 -- When we read an interface file, we also construct a 'ModIface' from it,
 -- except that we explicitly make the 'mi_decls' and a few other fields empty;
 -- as when reading we consolidate the declarations etc. into a number of indexed
hunk ./compiler/main/HscTypes.lhs 593
 -- maps and environments in the 'ExternalPackageState'.
-data ModIface 
+data ModIface
    = ModIface {
         mi_module   :: !Module,             -- ^ Name of the module we are for
         mi_iface_hash :: !Fingerprint,      -- ^ Hash of the whole interface
hunk ./compiler/main/HscTypes.lhs 597
-        mi_mod_hash :: !Fingerprint,	    -- ^ Hash of the ABI only
+        mi_mod_hash :: !Fingerprint,        -- ^ Hash of the ABI only
 
         mi_orphan   :: !WhetherHasOrphans,  -- ^ Whether this module has orphans
         mi_finsts   :: !WhetherHasFamInst,  -- ^ Whether this module has family instances
hunk ./compiler/main/HscTypes.lhs 601
-	mi_boot	    :: !IsBootInterface,    -- ^ Read from an hi-boot file?
+        mi_boot     :: !IsBootInterface,    -- ^ Read from an hi-boot file?
 
hunk ./compiler/main/HscTypes.lhs 603
-	mi_deps	    :: Dependencies,
-	        -- ^ The dependencies of the module.  This is
-		-- consulted for directly-imported modules, but not
-		-- for anything else (hence lazy)
+        mi_deps     :: Dependencies,
+                -- ^ The dependencies of the module.  This is
+                -- consulted for directly-imported modules, but not
+                -- for anything else (hence lazy)
 
         mi_usages   :: [Usage],
                 -- ^ Usages; kept sorted so that it's easy to decide
hunk ./compiler/main/HscTypes.lhs 610
-		-- whether to write a new iface file (changing usages
-		-- doesn't affect the hash of this module)
-        
-		-- NOT STRICT!  we read this field lazily from the interface file
-		-- It is *only* consulted by the recompilation checker
+                -- whether to write a new iface file (changing usages
+                -- doesn't affect the hash of this module)
 
hunk ./compiler/main/HscTypes.lhs 613
-		-- Exports
-		-- Kept sorted by (mod,occ), to make version comparisons easier
+                -- NOT STRICT!  we read this field lazily from the interface file
+                -- It is *only* consulted by the recompilation checker
+
+                -- Exports
+                -- Kept sorted by (mod,occ), to make version comparisons easier
         mi_exports  :: ![IfaceExport],
                 -- ^ Records the modules that are the declaration points for things
                 -- exported by this module, and the 'OccName's of those things
hunk ./compiler/main/HscTypes.lhs 621
-        
-        mi_exp_hash :: !Fingerprint,	-- ^ Hash of export list
+
+        mi_exp_hash :: !Fingerprint,    -- ^ Hash of export list
 
         mi_fixities :: [(OccName,Fixity)],
                 -- ^ Fixities
hunk ./compiler/main/HscTypes.lhs 626
-        
-		-- NOT STRICT!  we read this field lazily from the interface file
 
hunk ./compiler/main/HscTypes.lhs 627
-	mi_warns  :: Warnings,
-		-- ^ Warnings
-		
-		-- NOT STRICT!  we read this field lazily from the interface file
+                -- NOT STRICT!  we read this field lazily from the interface file
+
+        mi_warns  :: Warnings,
+                -- ^ Warnings
 
hunk ./compiler/main/HscTypes.lhs 632
-	mi_anns  :: [IfaceAnnotation],
-	        -- ^ Annotations
-	
-		-- NOT STRICT!  we read this field lazily from the interface file
+                -- NOT STRICT!  we read this field lazily from the interface file
 
hunk ./compiler/main/HscTypes.lhs 634
-		-- Type, class and variable declarations
-		-- The hash of an Id changes if its fixity or deprecations change
-		--	(as well as its type of course)
-		-- Ditto data constructors, class operations, except that 
-		-- the hash of the parent class/tycon changes
-	mi_decls :: [(Fingerprint,IfaceDecl)],	-- ^ Sorted type, variable, class etc. declarations
+        mi_anns  :: [IfaceAnnotation],
+                -- ^ Annotations
+
+                -- NOT STRICT!  we read this field lazily from the interface file
+
+                -- Type, class and variable declarations
+                -- The hash of an Id changes if its fixity or deprecations change
+                --      (as well as its type of course)
+                -- Ditto data constructors, class operations, except that
+                -- the hash of the parent class/tycon changes
+        mi_decls :: [(Fingerprint,IfaceDecl)],  -- ^ Sorted type, variable, class etc. declarations
 
         mi_globals  :: !(Maybe GlobalRdrEnv),
hunk ./compiler/main/HscTypes.lhs 647
-		-- ^ Binds all the things defined at the top level in
-		-- the /original source/ code for this module. which
-		-- is NOT the same as mi_exports, nor mi_decls (which
-		-- may contains declarations for things not actually
-		-- defined by the user).  Used for GHCi and for inspecting
-		-- the contents of modules via the GHC API only.
-		--
-		-- (We need the source file to figure out the
-		-- top-level environment, if we didn't compile this module
-		-- from source then this field contains @Nothing@).
-		--
-		-- Strictly speaking this field should live in the
-		-- 'HomeModInfo', but that leads to more plumbing.
+                -- ^ Binds all the things defined at the top level in
+                -- the /original source/ code for this module. which
+                -- is NOT the same as mi_exports, nor mi_decls (which
+                -- may contains declarations for things not actually
+                -- defined by the user).  Used for GHCi and for inspecting
+                -- the contents of modules via the GHC API only.
+                --
+                -- (We need the source file to figure out the
+                -- top-level environment, if we didn't compile this module
+                -- from source then this field contains @Nothing@).
+                --
+                -- Strictly speaking this field should live in the
+                -- 'HomeModInfo', but that leads to more plumbing.
 
hunk ./compiler/main/HscTypes.lhs 661
-		-- Instance declarations and rules
-	mi_insts     :: [IfaceInst],			-- ^ Sorted class instance
-	mi_fam_insts :: [IfaceFamInst],			-- ^ Sorted family instances
-	mi_rules     :: [IfaceRule],			-- ^ Sorted rules
-	mi_orphan_hash :: !Fingerprint,	-- ^ Hash for orphan rules and 
-					-- class and family instances
-					-- combined
+                -- Instance declarations and rules
+        mi_insts     :: [IfaceInst],                    -- ^ Sorted class instance
+        mi_fam_insts :: [IfaceFamInst],                 -- ^ Sorted family instances
+        mi_rules     :: [IfaceRule],                    -- ^ Sorted rules
+        mi_orphan_hash :: !Fingerprint, -- ^ Hash for orphan rules and
+                                        -- class and family instances
+                                        -- combined
 
         mi_vect_info :: !IfaceVectInfo, -- ^ Vectorisation information
 
hunk ./compiler/main/HscTypes.lhs 671
-		-- Cached environments for easy lookup
-		-- These are computed (lazily) from other fields
-		-- and are not put into the interface file
-	mi_warn_fn  :: Name -> Maybe WarningTxt,        -- ^ Cached lookup for 'mi_warns'
-	mi_fix_fn  :: OccName -> Fixity,	        -- ^ Cached lookup for 'mi_fixities'
-	mi_hash_fn :: OccName -> Maybe (OccName, Fingerprint),
+                -- Cached environments for easy lookup
+                -- These are computed (lazily) from other fields
+                -- and are not put into the interface file
+        mi_warn_fn  :: Name -> Maybe WarningTxt,        -- ^ Cached lookup for 'mi_warns'
+        mi_fix_fn  :: OccName -> Fixity,                -- ^ Cached lookup for 'mi_fixities'
+        mi_hash_fn :: OccName -> Maybe (OccName, Fingerprint),
                         -- ^ Cached lookup for 'mi_decls'.
hunk ./compiler/main/HscTypes.lhs 678
-			-- The @Nothing@ in 'mi_hash_fn' means that the thing
-			-- isn't in decls. It's useful to know that when
-			-- seeing if we are up to date wrt. the old interface.
+                        -- The @Nothing@ in 'mi_hash_fn' means that the thing
+                        -- isn't in decls. It's useful to know that when
+                        -- seeing if we are up to date wrt. the old interface.
                         -- The 'OccName' is the parent of the name, if it has one.
hunk ./compiler/main/HscTypes.lhs 682
-	mi_hpc    :: !AnyHpcUsage,
-	        -- ^ True if this program uses Hpc at any point in the program.
-	mi_trust  :: !IfaceTrustInfo
-	        -- ^ Safe Haskell Trust information for this module.
+        mi_hpc    :: !AnyHpcUsage,
+                -- ^ True if this program uses Hpc at any point in the program.
+        mi_trust  :: !IfaceTrustInfo
+                -- ^ Safe Haskell Trust information for this module.
      }
 
 -- | The 'ModDetails' is essentially a cache for information in the 'ModIface'
hunk ./compiler/main/HscTypes.lhs 693
 -- global environments in 'ExternalPackageState'.
 data ModDetails
    = ModDetails {
-	-- The next two fields are created by the typechecker
-	md_exports   :: [AvailInfo],
+        -- The next two fields are created by the typechecker
+        md_exports   :: [AvailInfo],
         md_types     :: !TypeEnv,       -- ^ Local type environment for this particular module
         md_insts     :: ![Instance],    -- ^ 'DFunId's for the instances in this module
         md_fam_insts :: ![FamInst],
hunk ./compiler/main/HscTypes.lhs 699
         md_rules     :: ![CoreRule],    -- ^ Domain may include 'Id's from other modules
-        md_anns      :: ![Annotation],  -- ^ Annotations present in this module: currently 
+        md_anns      :: ![Annotation],  -- ^ Annotations present in this module: currently
                                         -- they only annotate things also declared in this module
         md_vect_info :: !VectInfo       -- ^ Module vectorisation information
      }
hunk ./compiler/main/HscTypes.lhs 706
 
 emptyModDetails :: ModDetails
 emptyModDetails = ModDetails { md_types = emptyTypeEnv,
-			       md_exports = [],
-			       md_insts     = [],
-			       md_rules     = [],
-			       md_fam_insts = [],
+                               md_exports = [],
+                               md_insts     = [],
+                               md_rules     = [],
+                               md_fam_insts = [],
                                md_anns      = [],
                                md_vect_info = noVectInfo
hunk ./compiler/main/HscTypes.lhs 712
-                             } 
+                             }
 
 -- | Records the modules directly imported by a module for extracting e.g. usage information
 type ImportedMods = ModuleEnv [(ModuleName, Bool, SrcSpan, IsSafeImport)]
hunk ./compiler/main/HscTypes.lhs 721
 
 -- | A ModGuts is carried through the compiler, accumulating stuff as it goes
 -- There is only one ModGuts at any time, the one for the module
--- being compiled right now.  Once it is compiled, a 'ModIface' and 
+-- being compiled right now.  Once it is compiled, a 'ModIface' and
 -- 'ModDetails' are extracted and the ModGuts is discarded.
 data ModGuts
   = ModGuts {
hunk ./compiler/main/HscTypes.lhs 726
         mg_module    :: !Module,         -- ^ Module being compiled
-	mg_boot      :: IsBootInterface, -- ^ Whether it's an hs-boot module
-	mg_exports   :: ![AvailInfo],	 -- ^ What it exports
-	mg_deps	     :: !Dependencies,	 -- ^ What it depends on, directly or
-	                                 -- otherwise
-	mg_dir_imps  :: !ImportedMods,	 -- ^ Directly-imported modules; used to
-					 -- generate initialisation code
-	mg_used_names:: !NameSet,	 -- ^ What the module needed (used in 'MkIface.mkIface')
+        mg_boot      :: IsBootInterface, -- ^ Whether it's an hs-boot module
+        mg_exports   :: ![AvailInfo],    -- ^ What it exports
+        mg_deps      :: !Dependencies,   -- ^ What it depends on, directly or
+                                         -- otherwise
+        mg_dir_imps  :: !ImportedMods,   -- ^ Directly-imported modules; used to
+                                         -- generate initialisation code
+        mg_used_names:: !NameSet,        -- ^ What the module needed (used in 'MkIface.mkIface')
 
hunk ./compiler/main/HscTypes.lhs 734
-        mg_rdr_env   :: !GlobalRdrEnv,	 -- ^ Top-level lexical environment
+        mg_rdr_env   :: !GlobalRdrEnv,   -- ^ Top-level lexical environment
 
hunk ./compiler/main/HscTypes.lhs 736
-	-- These fields all describe the things **declared in this module**
-	mg_fix_env   :: !FixityEnv,	 -- ^ Fixities declared in this module
-	                                 -- TODO: I'm unconvinced this is actually used anywhere
-	mg_types     :: !TypeEnv,        -- ^ Types declared in this module
-	mg_insts     :: ![Instance],	 -- ^ Class instances declared in this module
-	mg_fam_insts :: ![FamInst],	 -- ^ Family instances declared in this module
-        mg_rules     :: ![CoreRule],	 -- ^ Before the core pipeline starts, contains 
-		     			 -- See Note [Overall plumbing for rules] in Rules.lhs
-	mg_binds     :: ![CoreBind],	 -- ^ Bindings for this module
-	mg_foreign   :: !ForeignStubs,   -- ^ Foreign exports declared in this module
-	mg_warns     :: !Warnings,	 -- ^ Warnings declared in the module
-	mg_anns      :: [Annotation],    -- ^ Annotations declared in this module
-	mg_hpc_info  :: !HpcInfo,        -- ^ Coverage tick boxes in the module
+        -- These fields all describe the things **declared in this module**
+        mg_fix_env   :: !FixityEnv,      -- ^ Fixities declared in this module
+                                         -- TODO: I'm unconvinced this is actually used anywhere
+        mg_types     :: !TypeEnv,        -- ^ Types declared in this module
+        mg_insts     :: ![Instance],     -- ^ Class instances declared in this module
+        mg_fam_insts :: ![FamInst],      -- ^ Family instances declared in this module
+        mg_rules     :: ![CoreRule],     -- ^ Before the core pipeline starts, contains
+                                         -- See Note [Overall plumbing for rules] in Rules.lhs
+        mg_binds     :: ![CoreBind],     -- ^ Bindings for this module
+        mg_foreign   :: !ForeignStubs,   -- ^ Foreign exports declared in this module
+        mg_warns     :: !Warnings,       -- ^ Warnings declared in the module
+        mg_anns      :: [Annotation],    -- ^ Annotations declared in this module
+        mg_hpc_info  :: !HpcInfo,        -- ^ Coverage tick boxes in the module
         mg_modBreaks :: !ModBreaks,      -- ^ Breakpoints for the module
         mg_vect_info :: !VectInfo,       -- ^ Pool of vectorised declarations in the module
 
hunk ./compiler/main/HscTypes.lhs 752
-	-- The next two fields are unusual, because they give instance
-	-- environments for *all* modules in the home package, including
-	-- this module, rather than for *just* this module.  
-	-- Reason: when looking up an instance we don't want to have to
-	--	  look at each module in the home package in turn
-	mg_inst_env     :: InstEnv,
+        -- The next two fields are unusual, because they give instance
+        -- environments for *all* modules in the home package, including
+        -- this module, rather than for *just* this module.
+        -- Reason: when looking up an instance we don't want to have to
+        --        look at each module in the home package in turn
+        mg_inst_env     :: InstEnv,
         -- ^ Class instance environment from /home-package/ modules (including
hunk ./compiler/main/HscTypes.lhs 759
-	-- this one); c.f. 'tcg_inst_env'
-	mg_fam_inst_env :: FamInstEnv
+        -- this one); c.f. 'tcg_inst_env'
+        mg_fam_inst_env :: FamInstEnv
         -- ^ Type-family instance enviroment for /home-package/ modules
hunk ./compiler/main/HscTypes.lhs 762
-	-- (including this one); c.f. 'tcg_fam_inst_env'
+        -- (including this one); c.f. 'tcg_fam_inst_env'
     }
 
 -- The ModGuts takes on several slightly different forms:
hunk ./compiler/main/HscTypes.lhs 768
 --
 -- After simplification, the following fields change slightly:
---	mg_rules	Orphan rules only (local ones now attached to binds)
---	mg_binds	With rules attached
+--      mg_rules        Orphan rules only (local ones now attached to binds)
+--      mg_binds        With rules attached
 
 -- The ModGuts takes on several slightly different forms:
 --
hunk ./compiler/main/HscTypes.lhs 774
 -- After simplification, the following fields change slightly:
---	mg_rules	Orphan rules only (local ones now attached to binds)
---	mg_binds	With rules attached
+--      mg_rules        Orphan rules only (local ones now attached to binds)
+--      mg_binds        With rules attached
 
 
 ---------------------------------------------------------
hunk ./compiler/main/HscTypes.lhs 779
--- The Tidy pass forks the information about this module: 
---	* one lot goes to interface file generation (ModIface)
---	  and later compilations (ModDetails)
---	* the other lot goes to code generation (CgGuts)
+-- The Tidy pass forks the information about this module:
+--      * one lot goes to interface file generation (ModIface)
+--        and later compilations (ModDetails)
+--      * the other lot goes to code generation (CgGuts)
 
 -- | A restricted form of 'ModGuts' for code generation purposes
hunk ./compiler/main/HscTypes.lhs 785
-data CgGuts 
+data CgGuts
   = CgGuts {
hunk ./compiler/main/HscTypes.lhs 787
-	cg_module   :: !Module, -- ^ Module being compiled
+        cg_module   :: !Module, -- ^ Module being compiled
 
hunk ./compiler/main/HscTypes.lhs 789
-	cg_tycons   :: [TyCon],
-		-- ^ Algebraic data types (including ones that started
-		-- life as classes); generate constructors and info
-		-- tables. Includes newtypes, just for the benefit of
-		-- External Core
+        cg_tycons   :: [TyCon],
+                -- ^ Algebraic data types (including ones that started
+                -- life as classes); generate constructors and info
+                -- tables. Includes newtypes, just for the benefit of
+                -- External Core
 
hunk ./compiler/main/HscTypes.lhs 795
-	cg_binds    :: [CoreBind],
-		-- ^ The tidied main bindings, including
-		-- previously-implicit bindings for record and class
-		-- selectors, and data construtor wrappers.  But *not*
-		-- data constructor workers; reason: we we regard them
-		-- as part of the code-gen of tycons
+        cg_binds    :: [CoreBind],
+                -- ^ The tidied main bindings, including
+                -- previously-implicit bindings for record and class
+                -- selectors, and data construtor wrappers.  But *not*
+                -- data constructor workers; reason: we we regard them
+                -- as part of the code-gen of tycons
 
hunk ./compiler/main/HscTypes.lhs 802
-	cg_dir_imps :: ![Module],
-		-- ^ Directly-imported modules; used to generate
-		-- initialisation code
+        cg_dir_imps :: ![Module],
+                -- ^ Directly-imported modules; used to generate
+                -- initialisation code
 
hunk ./compiler/main/HscTypes.lhs 806
-	cg_foreign  :: !ForeignStubs,	-- ^ Foreign export stubs
-	cg_dep_pkgs :: ![PackageId],	-- ^ Dependent packages, used to 
-	                                -- generate #includes for C code gen
+        cg_foreign  :: !ForeignStubs,   -- ^ Foreign export stubs
+        cg_dep_pkgs :: ![PackageId],    -- ^ Dependent packages, used to
+                                        -- generate #includes for C code gen
         cg_hpc_info :: !HpcInfo,        -- ^ Program coverage tick box information
         cg_modBreaks :: !ModBreaks      -- ^ Module breakpoints
     }
hunk ./compiler/main/HscTypes.lhs 816
 -----------------------------------
 -- | Foreign export stubs
 data ForeignStubs = NoStubs             -- ^ We don't have any stubs
-		  | ForeignStubs
-			SDoc 		
-			SDoc 		
-		   -- ^ There are some stubs. Parameters:
-		   --
-		   --  1) Header file prototypes for
+                  | ForeignStubs
+                        SDoc
+                        SDoc
+                   -- ^ There are some stubs. Parameters:
+                   --
+                   --  1) Header file prototypes for
                    --     "foreign exported" functions
                    --
                    --  2) C stubs to use when calling
hunk ./compiler/main/HscTypes.lhs 832
 emptyModIface :: Module -> ModIface
 emptyModIface mod
   = ModIface { mi_module   = mod,
-	       mi_iface_hash = fingerprint0,
-	       mi_mod_hash = fingerprint0,
-	       mi_orphan   = False,
-	       mi_finsts   = False,
-	       mi_boot	   = False,
-	       mi_deps     = noDependencies,
-	       mi_usages   = [],
-	       mi_exports  = [],
-	       mi_exp_hash = fingerprint0,
-	       mi_fixities = [],
-	       mi_warns    = NoWarnings,
-	       mi_anns     = [],
-	       mi_insts     = [],
-	       mi_fam_insts = [],
-	       mi_rules     = [],
-	       mi_decls     = [],
-	       mi_globals   = Nothing,
-	       mi_orphan_hash = fingerprint0,
+               mi_iface_hash = fingerprint0,
+               mi_mod_hash = fingerprint0,
+               mi_orphan   = False,
+               mi_finsts   = False,
+               mi_boot     = False,
+               mi_deps     = noDependencies,
+               mi_usages   = [],
+               mi_exports  = [],
+               mi_exp_hash = fingerprint0,
+               mi_fixities = [],
+               mi_warns    = NoWarnings,
+               mi_anns     = [],
+               mi_insts     = [],
+               mi_fam_insts = [],
+               mi_rules     = [],
+               mi_decls     = [],
+               mi_globals   = Nothing,
+               mi_orphan_hash = fingerprint0,
                mi_vect_info = noIfaceVectInfo,
hunk ./compiler/main/HscTypes.lhs 851
-	       mi_warn_fn    = emptyIfaceWarnCache,
-	       mi_fix_fn    = emptyIfaceFixCache,
-	       mi_hash_fn   = emptyIfaceHashCache,
-	       mi_hpc       = False,
-	       mi_trust     = noIfaceTrustInfo
-    }		
+               mi_warn_fn    = emptyIfaceWarnCache,
+               mi_fix_fn    = emptyIfaceFixCache,
+               mi_hash_fn   = emptyIfaceHashCache,
+               mi_hpc       = False,
+               mi_trust     = noIfaceTrustInfo
+    }
 \end{code}
 
 
hunk ./compiler/main/HscTypes.lhs 861
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{The interactive context}
hunk ./compiler/main/HscTypes.lhs 863
-%*									*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 868
 -- | Interactive context, recording information relevant to GHCi
-data InteractiveContext 
-  = InteractiveContext { 
+data InteractiveContext
+  = InteractiveContext {
           ic_toplev_scope :: [Module]   -- ^ The context includes the "top-level" scope of
hunk ./compiler/main/HscTypes.lhs 871
-					-- these modules
+                                        -- these modules
 
         , ic_exports :: [(Module, Maybe (ImportDecl RdrName))]    -- ^ The context includes just the exported parts of these
hunk ./compiler/main/HscTypes.lhs 874
-					-- modules
+                                        -- modules
 
         , ic_rn_gbl_env :: GlobalRdrEnv -- ^ The contexts' cached 'GlobalRdrEnv', built from
hunk ./compiler/main/HscTypes.lhs 877
-					-- 'ic_toplev_scope' and 'ic_exports'
+                                        -- 'ic_toplev_scope' and 'ic_exports'
 
         , ic_tmp_ids :: [Id]   -- ^ Names bound during interaction with the user.
                                -- Later Ids shadow earlier ones with the same OccName
hunk ./compiler/main/HscTypes.lhs 897
 emptyInteractiveContext :: InteractiveContext
 emptyInteractiveContext
   = InteractiveContext { ic_toplev_scope = [],
-			 ic_exports = [],
-			 ic_rn_gbl_env = emptyGlobalRdrEnv,
-			 ic_tmp_ids = []
+                         ic_exports = [],
+                         ic_rn_gbl_env = emptyGlobalRdrEnv,
+                         ic_tmp_ids = []
 #ifdef GHCI
                          , ic_resume = []
 #endif
hunk ./compiler/main/HscTypes.lhs 923
 
 substInteractiveContext :: InteractiveContext -> TvSubst -> InteractiveContext
 substInteractiveContext ictxt subst | isEmptyTvSubst subst = ictxt
-substInteractiveContext ictxt@InteractiveContext{ic_tmp_ids=ids} subst 
+substInteractiveContext ictxt@InteractiveContext{ic_tmp_ids=ids} subst
   = ictxt { ic_tmp_ids = map subst_ty ids }
   where
    subst_ty id = id `setIdType` substTy subst (idType id)
hunk ./compiler/main/HscTypes.lhs 930
 \end{code}
 
 %************************************************************************
-%*									*
-        Building a PrintUnqualified		
-%*									*
+%*                                                                      *
+        Building a PrintUnqualified
+%*                                                                      *
 %************************************************************************
 
 Note [Printing original names]
hunk ./compiler/main/HscTypes.lhs 947
 where it gets tricky.  Here are the cases:
 
  1. T uniquely maps to  P:M.T      --->  "T"      NameUnqual
- 2. There is an X for which X.T 
+ 2. There is an X for which X.T
        uniquely maps to  P:M.T     --->  "X.T"    NameQual X
  3. There is no binding for "M.T"  --->  "M.T"    NameNotInScope1
  4. Otherwise                      --->  "P:M.T"  NameNotInScope2
hunk ./compiler/main/HscTypes.lhs 971
 mkPrintUnqualified :: DynFlags -> GlobalRdrEnv -> PrintUnqualified
 mkPrintUnqualified dflags env = (qual_name, qual_mod)
   where
-  qual_name mod occ	-- The (mod,occ) pair is the original name of the thing
+  qual_name mod occ     -- The (mod,occ) pair is the original name of the thing
         | [gre] <- unqual_gres, right_name gre = NameUnqual
hunk ./compiler/main/HscTypes.lhs 973
-		-- If there's a unique entity that's in scope unqualified with 'occ'
-		-- AND that entity is the right one, then we can use the unqualified name
+                -- If there's a unique entity that's in scope unqualified with 'occ'
+                -- AND that entity is the right one, then we can use the unqualified name
 
         | [gre] <- qual_gres = NameQual (get_qual_mod (gre_prov gre))
 
hunk ./compiler/main/HscTypes.lhs 978
-        | null qual_gres = 
+        | null qual_gres =
               if null (lookupGRE_RdrName (mkRdrQual (moduleName mod) occ) env)
                    then NameNotInScope1
                    else NameNotInScope2
hunk ./compiler/main/HscTypes.lhs 983
 
-	| otherwise = panic "mkPrintUnqualified"
+        | otherwise = panic "mkPrintUnqualified"
       where
hunk ./compiler/main/HscTypes.lhs 985
-	right_name gre = nameModule_maybe (gre_name gre) == Just mod
+        right_name gre = nameModule_maybe (gre_name gre) == Just mod
 
         unqual_gres = lookupGRE_RdrName (mkRdrUnqual occ) env
         qual_gres   = filter right_name (lookupGlobalRdrEnv env occ)
hunk ./compiler/main/HscTypes.lhs 990
 
-	get_qual_mod LocalDef      = moduleName mod
-	get_qual_mod (Imported is) = ASSERT( not (null is) ) is_as (is_decl (head is))
+        get_qual_mod LocalDef      = moduleName mod
+        get_qual_mod (Imported is) = ASSERT( not (null is) ) is_as (is_decl (head is))
 
     -- we can mention a module P:M without the P: qualifier iff
     -- "import M" would resolve unambiguously to P:M.  (if P is the
hunk ./compiler/main/HscTypes.lhs 1000
   qual_mod mod
      | modulePackageId mod == thisPackage dflags = False
 
-     | [pkgconfig] <- [pkg | (pkg,exposed_module) <- lookup, 
+     | [pkgconfig] <- [pkg | (pkg,exposed_module) <- lookup,
                              exposed pkg && exposed_module],
        packageConfigId pkgconfig == modulePackageId mod
         -- this says: we are given a module P:M, is there just one exposed package
hunk ./compiler/main/HscTypes.lhs 1013
 
 
 %************************************************************************
-%*									*
-		TyThing
-%*									*
+%*                                                                      *
+                TyThing
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 1041
       -- for each data constructor in order,
       --   the contructor, worker, and (possibly) wrapper
     concatMap (extras_plus . ADataCon) (tyConDataCons tc)
-		     
-implicitTyThings (AClass cl) 
+
+implicitTyThings (AClass cl)
   = -- dictionary datatype:
     --    [extras_plus:]
hunk ./compiler/main/HscTypes.lhs 1045
-    --      type constructor 
+    --      type constructor
     --    [recursive call:]
     --      (possibly) newtype coercion; definitely no family coercion here
     --      data constructor
hunk ./compiler/main/HscTypes.lhs 1052
     --      worker
     --      (no wrapper by invariant)
     extras_plus (ATyCon (classTyCon cl)) ++
-    -- associated types 
+    -- associated types
     --    No extras_plus (recursive call) for the classATs, because they
     --    are only the family decls; they have no implicit things
     map ATyCon (classATs cl) ++
hunk ./compiler/main/HscTypes.lhs 1059
     -- superclass and operation selectors
     map AnId (classAllSelIds cl)
 
-implicitTyThings (ADataCon dc) = 
+implicitTyThings (ADataCon dc) =
     -- For data cons add the worker and (possibly) wrapper
     map AnId (dataConImplicitIds dc)
 
hunk ./compiler/main/HscTypes.lhs 1072
 -- For newtypes and indexed data types (and both),
 -- add the implicit coercion tycon
 implicitCoTyCon :: TyCon -> [TyThing]
-implicitCoTyCon tc 
+implicitCoTyCon tc
   = map ATyCon . catMaybes $ [-- Just if newtype, Nothing if not
hunk ./compiler/main/HscTypes.lhs 1074
-                              newTyConCo_maybe tc, 
+                              newTyConCo_maybe tc,
                               -- Just if family instance, Nothing if not
hunk ./compiler/main/HscTypes.lhs 1076
-			        tyConFamilyCoercion_maybe tc] 
+                                tyConFamilyCoercion_maybe tc]
 
 -- sortByOcc = sortBy (\ x -> \ y -> getOccName x < getOccName y)
 
hunk ./compiler/main/HscTypes.lhs 1097
 \end{code}
 
 %************************************************************************
-%*									*
-		TypeEnv
-%*									*
+%*                                                                      *
+                TypeEnv
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 1115
 typeEnvDataCons :: TypeEnv -> [DataCon]
 lookupTypeEnv   :: TypeEnv -> Name -> Maybe TyThing
 
-emptyTypeEnv 	    = emptyNameEnv
+emptyTypeEnv        = emptyNameEnv
 typeEnvElts     env = nameEnvElts env
 typeEnvClasses  env = [cl | AClass cl   <- typeEnvElts env]
hunk ./compiler/main/HscTypes.lhs 1118
-typeEnvTyCons   env = [tc | ATyCon tc   <- typeEnvElts env] 
-typeEnvIds      env = [id | AnId id     <- typeEnvElts env] 
-typeEnvDataCons env = [dc | ADataCon dc <- typeEnvElts env] 
+typeEnvTyCons   env = [tc | ATyCon tc   <- typeEnvElts env]
+typeEnvIds      env = [id | AnId id     <- typeEnvElts env]
+typeEnvDataCons env = [dc | ADataCon dc <- typeEnvElts env]
 
 mkTypeEnv :: [TyThing] -> TypeEnv
 mkTypeEnv things = extendTypeEnvList emptyTypeEnv things
hunk ./compiler/main/HscTypes.lhs 1124
-		
+
 lookupTypeEnv = lookupNameEnv
 
 -- Extend the type environment
hunk ./compiler/main/HscTypes.lhs 1129
 extendTypeEnv :: TypeEnv -> TyThing -> TypeEnv
-extendTypeEnv env thing = extendNameEnv env (getName thing) thing 
+extendTypeEnv env thing = extendNameEnv env (getName thing) thing
 
 extendTypeEnvList :: TypeEnv -> [TyThing] -> TypeEnv
 extendTypeEnvList env things = foldl extendTypeEnv env things
hunk ./compiler/main/HscTypes.lhs 1142
 -- that this does NOT look up the 'TyThing' in the module being compiled: you
 -- have to do that yourself, if desired
 lookupType :: DynFlags
-	   -> HomePackageTable
-	   -> PackageTypeEnv
-	   -> Name
-	   -> Maybe TyThing
+           -> HomePackageTable
+           -> PackageTypeEnv
+           -> Name
+           -> Maybe TyThing
 
 lookupType dflags hpt pte name
   -- in one-shot, we don't use the HPT
hunk ./compiler/main/HscTypes.lhs 1149
-  | not (isOneShot (ghcMode dflags)) && modulePackageId mod == this_pkg 
+  | not (isOneShot (ghcMode dflags)) && modulePackageId mod == this_pkg
   = do hm <- lookupUFM hpt (moduleName mod) -- Maybe monad
        lookupNameEnv (md_types (hm_details hm)) name
   | otherwise
hunk ./compiler/main/HscTypes.lhs 1155
   = lookupNameEnv pte name
   where mod = ASSERT( isExternalName name ) nameModule name
-	this_pkg = thisPackage dflags
+        this_pkg = thisPackage dflags
 
 -- | As 'lookupType', but with a marginally easier-to-use interface
 -- if you have a 'HscEnv'
hunk ./compiler/main/HscTypes.lhs 1163
 lookupTypeHscEnv hsc_env name = do
     eps <- readIORef (hsc_EPS hsc_env)
     return $! lookupType dflags hpt (eps_PTE eps) name
-  where 
+  where
     dflags = hsc_dflags hsc_env
     hpt = hsc_HPT hsc_env
 \end{code}
hunk ./compiler/main/HscTypes.lhs 1172
 -- | Get the 'TyCon' from a 'TyThing' if it is a type constructor thing. Panics otherwise
 tyThingTyCon :: TyThing -> TyCon
 tyThingTyCon (ATyCon tc) = tc
-tyThingTyCon other	 = pprPanic "tyThingTyCon" (pprTyThing other)
+tyThingTyCon other       = pprPanic "tyThingTyCon" (pprTyThing other)
 
 -- | Get the 'Class' from a 'TyThing' if it is a class thing. Panics otherwise
 tyThingClass :: TyThing -> Class
hunk ./compiler/main/HscTypes.lhs 1177
 tyThingClass (AClass cls) = cls
-tyThingClass other	  = pprPanic "tyThingClass" (pprTyThing other)
+tyThingClass other        = pprPanic "tyThingClass" (pprTyThing other)
 
 -- | Get the 'DataCon' from a 'TyThing' if it is a data constructor thing. Panics otherwise
 tyThingDataCon :: TyThing -> DataCon
hunk ./compiler/main/HscTypes.lhs 1182
 tyThingDataCon (ADataCon dc) = dc
-tyThingDataCon other	     = pprPanic "tyThingDataCon" (pprTyThing other)
+tyThingDataCon other         = pprPanic "tyThingDataCon" (pprTyThing other)
 
 -- | Get the 'Id' from a 'TyThing' if it is a id *or* data constructor thing. Panics otherwise
 tyThingId :: TyThing -> Id
hunk ./compiler/main/HscTypes.lhs 1222
 -- | Constructs cache for the 'mi_hash_fn' field of a 'ModIface'
 mkIfaceHashCache :: [(Fingerprint,IfaceDecl)]
                  -> (OccName -> Maybe (OccName, Fingerprint))
-mkIfaceHashCache pairs 
+mkIfaceHashCache pairs
   = \occ -> lookupOccEnv env occ
   where
     env = foldr add_decl emptyOccEnv pairs
hunk ./compiler/main/HscTypes.lhs 1237
 \end{code}
 
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Auxiliary types}
hunk ./compiler/main/HscTypes.lhs 1239
-%*									*
+%*                                                                      *
 %************************************************************************
 
 These types are defined here because they are mentioned in ModDetails,
hunk ./compiler/main/HscTypes.lhs 1250
 -- | Warning information for a module
 data Warnings
   = NoWarnings                          -- ^ Nothing deprecated
-  | WarnAll WarningTxt	                -- ^ Whole module deprecated
+  | WarnAll WarningTxt                  -- ^ Whole module deprecated
   | WarnSome [(OccName,WarningTxt)]     -- ^ Some specific things deprecated
 
      -- Only an OccName is needed because
hunk ./compiler/main/HscTypes.lhs 1293
 \end{code}
 \begin{code}
 -- | A collection of 'AvailInfo' - several things that are \"available\"
-type Avails	  = [AvailInfo]
+type Avails       = [AvailInfo]
 -- | 'Name'd things that are available
 type AvailInfo    = GenAvailInfo Name
 -- | 'RdrName'd things that are available
hunk ./compiler/main/HscTypes.lhs 1300
 type RdrAvailInfo = GenAvailInfo OccName
 
 -- | Records what things are "available", i.e. in scope
-data GenAvailInfo name	= Avail name	 -- ^ An ordinary identifier in scope
-			| AvailTC name
-				  [name] -- ^ A type or class in scope. Parameters:
-				         --
-				         --  1) The name of the type or class
-				         --
-				         --  2) The available pieces of type or class.
-					 --     NB: If the type or class is itself
-					 --     to be in scope, it must be in this list.
-					 --     Thus, typically: @AvailTC Eq [Eq, ==, \/=]@
-			deriving( Eq )
-			-- Equality used when deciding if the interface has changed
+data GenAvailInfo name  = Avail name     -- ^ An ordinary identifier in scope
+                        | AvailTC name
+                                  [name] -- ^ A type or class in scope. Parameters:
+                                         --
+                                         --  1) The name of the type or class
+                                         --
+                                         --  2) The available pieces of type or class.
+                                         --     NB: If the type or class is itself
+                                         --     to be in scope, it must be in this list.
+                                         --     Thus, typically: @AvailTC Eq [Eq, ==, \/=]@
+                        deriving( Eq )
+                        -- Equality used when deciding if the interface has changed
 
 -- | The original names declared of a certain module that are exported
 type IfaceExport = (Module, [GenAvailInfo OccName])
hunk ./compiler/main/HscTypes.lhs 1347
 \begin{code}
 -- | Creates cached lookup for the 'mi_fix_fn' field of 'ModIface'
 mkIfaceFixCache :: [(OccName, Fixity)] -> OccName -> Fixity
-mkIfaceFixCache pairs 
+mkIfaceFixCache pairs
   = \n -> lookupOccEnv env n `orElse` defaultFixity
   where
    env = mkOccEnv pairs
hunk ./compiler/main/HscTypes.lhs 1358
 -- | Fixity environment mapping names to their fixities
 type FixityEnv = NameEnv FixItem
 
--- | Fixity information for an 'Name'. We keep the OccName in the range 
+-- | Fixity information for an 'Name'. We keep the OccName in the range
 -- so that we can generate an interface from it
 data FixItem = FixItem OccName Fixity
 
hunk ./compiler/main/HscTypes.lhs 1370
 
 lookupFixity :: FixityEnv -> Name -> Fixity
 lookupFixity env n = case lookupNameEnv env n of
-			Just (FixItem _ fix) -> fix
-			Nothing	      	-> defaultFixity
+                        Just (FixItem _ fix) -> fix
+                        Nothing         -> defaultFixity
 \end{code}
 
 
hunk ./compiler/main/HscTypes.lhs 1376
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{WhatsImported}
hunk ./compiler/main/HscTypes.lhs 1378
-%*									*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 1406
 data Dependencies
   = Deps { dep_mods   :: [(ModuleName, IsBootInterface)]
                         -- ^ Home-package module dependencies
-	 , dep_pkgs   :: [PackageId]
-	                -- ^ External package dependencies
-	 , dep_orphs  :: [Module]	    
-	                -- ^ Orphan modules (whether home or external pkg),
-	                -- *not* including family instance orphans as they
-	                -- are anyway included in 'dep_finsts'
-         , dep_finsts :: [Module]	    
+         , dep_pkgs   :: [PackageId]
+                        -- ^ External package dependencies
+         , dep_orphs  :: [Module]
+                        -- ^ Orphan modules (whether home or external pkg),
+                        -- *not* including family instance orphans as they
+                        -- are anyway included in 'dep_finsts'
+         , dep_finsts :: [Module]
                         -- ^ Modules that contain family instances (whether the
                         -- instances are from the home or an external package)
          }
hunk ./compiler/main/HscTypes.lhs 1417
   deriving( Eq )
-	-- Equality used only for old/new comparison in MkIface.addVersionInfo
+        -- Equality used only for old/new comparison in MkIface.addVersionInfo
 
         -- See 'TcRnTypes.ImportAvails' for details on dependencies.
 
hunk ./compiler/main/HscTypes.lhs 1430
         usg_mod      :: Module,
            -- ^ External package module depended on
         usg_mod_hash :: Fingerprint,
-	    -- ^ Cached module fingerprint
+            -- ^ Cached module fingerprint
         usg_safe :: IsSafeImport
             -- ^ Was this module imported as a safe import
     }                                           -- ^ Module from another package
hunk ./compiler/main/HscTypes.lhs 1437
   | UsageHomeModule {
         usg_mod_name :: ModuleName,
             -- ^ Name of the module
-	usg_mod_hash :: Fingerprint,
-	    -- ^ Cached module fingerprint
-	usg_entities :: [(OccName,Fingerprint)],
+        usg_mod_hash :: Fingerprint,
+            -- ^ Cached module fingerprint
+        usg_entities :: [(OccName,Fingerprint)],
             -- ^ Entities we depend on, sorted by occurrence name and fingerprinted.
hunk ./compiler/main/HscTypes.lhs 1441
-            -- NB: usages are for parent names only, e.g. type constructors 
+            -- NB: usages are for parent names only, e.g. type constructors
             -- but not the associated data constructors.
hunk ./compiler/main/HscTypes.lhs 1443
-	usg_exports  :: Maybe Fingerprint
+        usg_exports  :: Maybe Fingerprint,
             -- ^ Fingerprint for the export list we used to depend on this module,
             -- if we depend on the export list
         usg_safe :: IsSafeImport
hunk ./compiler/main/HscTypes.lhs 1450
             -- ^ Was this module imported as a safe import
     }                                           -- ^ Module from the current package
     deriving( Eq )
-	-- The export list field is (Just v) if we depend on the export list:
-	--	i.e. we imported the module directly, whether or not we
-	--	     enumerated the things we imported, or just imported 
+        -- The export list field is (Just v) if we depend on the export list:
+        --      i.e. we imported the module directly, whether or not we
+        --           enumerated the things we imported, or just imported
         --           everything
hunk ./compiler/main/HscTypes.lhs 1454
-	-- We need to recompile if M's exports change, because 
-	-- if the import was	import M, 	we might now have a name clash
+        -- We need to recompile if M's exports change, because
+        -- if the import was    import M,       we might now have a name clash
         --                                      in the importing module.
hunk ./compiler/main/HscTypes.lhs 1457
-	-- if the import was	import M(x)	M might no longer export x
-	-- The only way we don't depend on the export list is if we have
-	--			import M()
-	-- And of course, for modules that aren't imported directly we don't
-	-- depend on their export lists
+        -- if the import was    import M(x)     M might no longer export x
+        -- The only way we don't depend on the export list is if we have
+        --                      import M()
+        -- And of course, for modules that aren't imported directly we don't
+        -- depend on their export lists
 \end{code}
 
 
hunk ./compiler/main/HscTypes.lhs 1466
 %************************************************************************
-%*									*
-		The External Package State
-%*									*
+%*                                                                      *
+                The External Package State
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 1483
 -- their interface files
 data ExternalPackageState
   = EPS {
-	eps_is_boot :: !(ModuleNameEnv (ModuleName, IsBootInterface)),
-		-- ^ In OneShot mode (only), home-package modules
-		-- accumulate in the external package state, and are
-		-- sucked in lazily.  For these home-pkg modules
-		-- (only) we need to record which are boot modules.
-		-- We set this field after loading all the
-		-- explicitly-imported interfaces, but before doing
-		-- anything else
-		--
-		-- The 'ModuleName' part is not necessary, but it's useful for
-		-- debug prints, and it's convenient because this field comes
-		-- direct from 'TcRnTypes.imp_dep_mods'
+        eps_is_boot :: !(ModuleNameEnv (ModuleName, IsBootInterface)),
+                -- ^ In OneShot mode (only), home-package modules
+                -- accumulate in the external package state, and are
+                -- sucked in lazily.  For these home-pkg modules
+                -- (only) we need to record which are boot modules.
+                -- We set this field after loading all the
+                -- explicitly-imported interfaces, but before doing
+                -- anything else
+                --
+                -- The 'ModuleName' part is not necessary, but it's useful for
+                -- debug prints, and it's convenient because this field comes
+                -- direct from 'TcRnTypes.imp_dep_mods'
+
+        eps_PIT :: !PackageIfaceTable,
+                -- ^ The 'ModIface's for modules in external packages
+                -- whose interfaces we have opened.
+                -- The declarations in these interface files are held in the
+                -- 'eps_decls', 'eps_inst_env', 'eps_fam_inst_env' and 'eps_rules'
+                -- fields of this record, not in the 'mi_decls' fields of the
+                -- interface we have sucked in.
+                --
+                -- What /is/ in the PIT is:
+                --
+                -- * The Module
+                --
+                -- * Fingerprint info
+                --
+                -- * Its exports
+                --
+                -- * Fixities
+                --
+                -- * Deprecations and warnings
 
hunk ./compiler/main/HscTypes.lhs 1516
-	eps_PIT :: !PackageIfaceTable,
-		-- ^ The 'ModIface's for modules in external packages
-		-- whose interfaces we have opened.
-		-- The declarations in these interface files are held in the
-		-- 'eps_decls', 'eps_inst_env', 'eps_fam_inst_env' and 'eps_rules'
-		-- fields of this record, not in the 'mi_decls' fields of the 
-		-- interface we have sucked in.
-		--
-		-- What /is/ in the PIT is:
-		--
-		-- * The Module
-		--
-		-- * Fingerprint info
-		--
-		-- * Its exports
-		--
-		-- * Fixities
-		--
-		-- * Deprecations and warnings
+        eps_PTE :: !PackageTypeEnv,
+                -- ^ Result of typechecking all the external package
+                -- interface files we have sucked in. The domain of
+                -- the mapping is external-package modules
 
hunk ./compiler/main/HscTypes.lhs 1521
-	eps_PTE :: !PackageTypeEnv,	   
-	        -- ^ Result of typechecking all the external package
-	        -- interface files we have sucked in. The domain of
-	        -- the mapping is external-package modules
-	        
-	eps_inst_env     :: !PackageInstEnv,   -- ^ The total 'InstEnv' accumulated
-					       -- from all the external-package modules
-	eps_fam_inst_env :: !PackageFamInstEnv,-- ^ The total 'FamInstEnv' accumulated
-					       -- from all the external-package modules
-	eps_rule_base    :: !PackageRuleBase,  -- ^ The total 'RuleEnv' accumulated
-					       -- from all the external-package modules
-	eps_vect_info    :: !PackageVectInfo,  -- ^ The total 'VectInfo' accumulated
-					       -- from all the external-package modules
+        eps_inst_env     :: !PackageInstEnv,   -- ^ The total 'InstEnv' accumulated
+                                               -- from all the external-package modules
+        eps_fam_inst_env :: !PackageFamInstEnv,-- ^ The total 'FamInstEnv' accumulated
+                                               -- from all the external-package modules
+        eps_rule_base    :: !PackageRuleBase,  -- ^ The total 'RuleEnv' accumulated
+                                               -- from all the external-package modules
+        eps_vect_info    :: !PackageVectInfo,  -- ^ The total 'VectInfo' accumulated
+                                               -- from all the external-package modules
         eps_ann_env      :: !PackageAnnEnv,    -- ^ The total 'AnnEnv' accumulated
hunk ./compiler/main/HscTypes.lhs 1530
-					       -- from all the external-package modules
+                                               -- from all the external-package modules
 
         eps_mod_fam_inst_env :: !(ModuleEnv FamInstEnv), -- ^ The family instances accumulated from external
                                                          -- packages, keyed off the module that declared them
hunk ./compiler/main/HscTypes.lhs 1535
 
-	eps_stats :: !EpsStats                 -- ^ Stastics about what was loaded from external packages
+        eps_stats :: !EpsStats                 -- ^ Stastics about what was loaded from external packages
   }
 
 -- | Accumulated statistics about what we are putting into the 'ExternalPackageState'.
hunk ./compiler/main/HscTypes.lhs 1542
 -- \"In\" means stuff that is just /read/ from interface files,
 -- \"Out\" means actually sucked in and type-checked
 data EpsStats = EpsStats { n_ifaces_in
-			 , n_decls_in, n_decls_out 
-			 , n_rules_in, n_rules_out
-			 , n_insts_in, n_insts_out :: !Int }
+                         , n_decls_in, n_decls_out
+                         , n_rules_in, n_rules_out
+                         , n_insts_in, n_insts_out :: !Int }
 
 addEpsInStats :: EpsStats -> Int -> Int -> Int -> EpsStats
 -- ^ Add stats for one newly-read interface
hunk ./compiler/main/HscTypes.lhs 1550
 addEpsInStats stats n_decls n_insts n_rules
   = stats { n_ifaces_in = n_ifaces_in stats + 1
-	  , n_decls_in  = n_decls_in stats + n_decls
-	  , n_insts_in  = n_insts_in stats + n_insts
-	  , n_rules_in  = n_rules_in stats + n_rules }
+          , n_decls_in  = n_decls_in stats + n_decls
+          , n_insts_in  = n_insts_in stats + n_insts
+          , n_rules_in  = n_rules_in stats + n_rules }
 \end{code}
 
hunk ./compiler/main/HscTypes.lhs 1555
-Names in a NameCache are always stored as a Global, and have the SrcLoc 
+Names in a NameCache are always stored as a Global, and have the SrcLoc
 of their binding locations.
 
 Actually that's not quite right.  When we first encounter the original
hunk ./compiler/main/HscTypes.lhs 1569
 -- something of a lookup mechanism for those names.
 data NameCache
  = NameCache {  nsUniqs :: UniqSupply,
-		-- ^ Supply of uniques
-		nsNames :: OrigNameCache,
-		-- ^ Ensures that one original name gets one unique
-		nsIPs   :: OrigIParamCache
-		-- ^ Ensures that one implicit parameter name gets one unique
+                -- ^ Supply of uniques
+                nsNames :: OrigNameCache,
+                -- ^ Ensures that one original name gets one unique
+                nsIPs   :: OrigIParamCache
+                -- ^ Ensures that one implicit parameter name gets one unique
    }
 
 -- | Per-module cache of original 'OccName's given 'Name's
hunk ./compiler/main/HscTypes.lhs 1586
 
 
 %************************************************************************
-%*									*
-		The module graph and ModSummary type
-	A ModSummary is a node in the compilation manager's
-	dependency graph, and it's also passed to hscMain
-%*									*
+%*                                                                      *
+                The module graph and ModSummary type
+        A ModSummary is a node in the compilation manager's
+        dependency graph, and it's also passed to hscMain
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 1614
 -- * An external-core source module
 data ModSummary
    = ModSummary {
-        ms_mod       :: Module,			-- ^ Identity of the module
-	ms_hsc_src   :: HscSource,		-- ^ The module source either plain Haskell, hs-boot or external core
-        ms_location  :: ModLocation,		-- ^ Location of the various files belonging to the module
-        ms_hs_date   :: ClockTime,		-- ^ Timestamp of source file
-	ms_obj_date  :: Maybe ClockTime,	-- ^ Timestamp of object, if we have one
-        ms_srcimps   :: [Located (ImportDecl RdrName)],	-- ^ Source imports of the module
-        ms_imps      :: [Located (ImportDecl RdrName)],	-- ^ Non-source imports of the module
-        ms_hspp_file :: FilePath,		-- ^ Filename of preprocessed source file
+        ms_mod       :: Module,                 -- ^ Identity of the module
+        ms_hsc_src   :: HscSource,              -- ^ The module source either plain Haskell, hs-boot or external core
+        ms_location  :: ModLocation,            -- ^ Location of the various files belonging to the module
+        ms_hs_date   :: ClockTime,              -- ^ Timestamp of source file
+        ms_obj_date  :: Maybe ClockTime,        -- ^ Timestamp of object, if we have one
+        ms_srcimps   :: [Located (ImportDecl RdrName)], -- ^ Source imports of the module
+        ms_imps      :: [Located (ImportDecl RdrName)], -- ^ Non-source imports of the module
+        ms_hspp_file :: FilePath,               -- ^ Filename of preprocessed source file
         ms_hspp_opts :: DynFlags,               -- ^ Cached flags from @OPTIONS@, @INCLUDE@
                                                 -- and @LANGUAGE@ pragmas in the modules source code
hunk ./compiler/main/HscTypes.lhs 1624
-	ms_hspp_buf  :: Maybe StringBuffer    	-- ^ The actual preprocessed source, if we have it
+        ms_hspp_buf  :: Maybe StringBuffer      -- ^ The actual preprocessed source, if we have it
      }
 
 ms_mod_name :: ModSummary -> ModuleName
hunk ./compiler/main/HscTypes.lhs 1633
 -- The ModLocation contains both the original source filename and the
 -- filename of the cleaned-up source file after all preprocessing has been
 -- done.  The point is that the summariser will have to cpp/unlit/whatever
--- all files anyway, and there's no point in doing this twice -- just 
+-- all files anyway, and there's no point in doing this twice -- just
 -- park the result in a temp file, put the name of it in the location,
 -- and let @compile@ read from that file on the way back up.
 
hunk ./compiler/main/HscTypes.lhs 1653
    ppr ms
       = sep [text "ModSummary {",
              nest 3 (sep [text "ms_hs_date = " <> text (show (ms_hs_date ms)),
-                          text "ms_mod =" <+> ppr (ms_mod ms) 
-				<> text (hscSourceString (ms_hsc_src ms)) <> comma,
+                          text "ms_mod =" <+> ppr (ms_mod ms)
+                                <> text (hscSourceString (ms_hsc_src ms)) <> comma,
                           text "ms_imps =" <+> ppr (ms_imps ms),
                           text "ms_srcimps =" <+> ppr (ms_srcimps ms)]),
              char '}'
hunk ./compiler/main/HscTypes.lhs 1666
         hsep [text (mod_str ++ replicate (max 0 (16 - length mod_str)) ' '),
               char '(', text (normalise $ msHsFilePath mod_summary) <> comma,
               case target of
-                  HscInterpreted | recomp 
+                  HscInterpreted | recomp
                              -> text "interpreted"
                   HscNothing -> text "nothing"
                   _          -> text (normalise $ msObjFilePath mod_summary),
hunk ./compiler/main/HscTypes.lhs 1671
               char ')']
- where 
+ where
     mod     = moduleName (ms_mod mod_summary)
     mod_str = showSDoc (ppr mod) ++ hscSourceString (ms_hsc_src mod_summary)
 \end{code}
hunk ./compiler/main/HscTypes.lhs 1678
 
 
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Hpc Support}
hunk ./compiler/main/HscTypes.lhs 1680
-%*									*
+%*                                                                      *
 %************************************************************************
 
 \begin{code}
hunk ./compiler/main/HscTypes.lhs 1686
 -- | Information about a modules use of Haskell Program Coverage
 data HpcInfo
-  = HpcInfo 
+  = HpcInfo
      { hpcInfoTickCount :: Int
      , hpcInfoHash      :: Int
      }
hunk ./compiler/main/HscTypes.lhs 1690
-  | NoHpcInfo 
+  | NoHpcInfo
      { hpcUsed          :: AnyHpcUsage  -- ^ Is hpc used anywhere on the module \*tree\*?
      }
 
hunk ./compiler/main/HscTypes.lhs 1699
 type AnyHpcUsage = Bool
 
 emptyHpcInfo :: AnyHpcUsage -> HpcInfo
-emptyHpcInfo = NoHpcInfo 
+emptyHpcInfo = NoHpcInfo
 
 -- | Find out if HPC is used by this module or any of the modules
 -- it depends upon
hunk ./compiler/main/HscTypes.lhs 1704
 isHpcUsed :: HpcInfo -> AnyHpcUsage
-isHpcUsed (HpcInfo {})     		 = True
+isHpcUsed (HpcInfo {})                   = True
 isHpcUsed (NoHpcInfo { hpcUsed = used }) = used
 \end{code}
 
hunk ./compiler/main/HscTypes.lhs 1709
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Vectorisation Support}
hunk ./compiler/main/HscTypes.lhs 1711
-%*									*
+%*                                                                      *
 %************************************************************************
 
 The following information is generated and consumed by the vectorisation
hunk ./compiler/main/HscTypes.lhs 1725
 
 \begin{code}
 -- | Vectorisation information for 'ModGuts', 'ModDetails' and 'ExternalPackageState'.
-data VectInfo      
+data VectInfo
   = VectInfo {
       vectInfoVar     :: VarEnv  (Var    , Var  ),   -- ^ @(f, f_v)@ keyed on @f@
       vectInfoTyCon   :: NameEnv (TyCon  , TyCon),   -- ^ @(T, T_v)@ keyed on @T@
hunk ./compiler/main/HscTypes.lhs 1735
     }
 
 -- | Vectorisation information for 'ModIface': a slightly less low-level view
-data IfaceVectInfo 
+data IfaceVectInfo
   = IfaceVectInfo {
       ifaceVectInfoVar        :: [Name],
         -- ^ All variables in here have a vectorised variant
hunk ./compiler/main/HscTypes.lhs 1745
         -- data constructors are determined by 'OccName.mkVectTyConOcc'
         -- and 'OccName.mkVectDataConOcc'; the names of
         -- the isomorphisms are determined by 'OccName.mkVectIsoOcc'
-      ifaceVectInfoTyConReuse :: [Name]              
+      ifaceVectInfoTyConReuse :: [Name]
         -- ^ The vectorised form of all the 'TyCon's in here coincides with
         -- the unconverted form; the name of the isomorphisms is determined
         -- by 'OccName.mkVectIsoOcc'
hunk ./compiler/main/HscTypes.lhs 1755
 noVectInfo = VectInfo emptyVarEnv emptyNameEnv emptyNameEnv emptyNameEnv emptyNameEnv
 
 plusVectInfo :: VectInfo -> VectInfo -> VectInfo
-plusVectInfo vi1 vi2 = 
+plusVectInfo vi1 vi2 =
   VectInfo (vectInfoVar     vi1 `plusVarEnv`  vectInfoVar     vi2)
            (vectInfoTyCon   vi1 `plusNameEnv` vectInfoTyCon   vi2)
            (vectInfoDataCon vi1 `plusNameEnv` vectInfoDataCon vi2)
hunk ./compiler/main/HscTypes.lhs 1770
 \end{code}
 
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Safe Haskell Support}
hunk ./compiler/main/HscTypes.lhs 1772
-%*									*
+%*                                                                      *
 %************************************************************************
 
 This stuff here is related to supporting the Safe Haskell extension,
hunk ./compiler/main/HscTypes.lhs 1825
 \end{code}
 
 %************************************************************************
-%*									*
+%*                                                                      *
 \subsection{Linkable stuff}
hunk ./compiler/main/HscTypes.lhs 1827
-%*									*
+%*                                                                      *
 %************************************************************************
 
 This stuff is in here, rather than (say) in Linker.lhs, because the Linker.lhs
hunk ./compiler/main/HscTypes.lhs 1836
 \begin{code}
 -- | Information we can use to dynamically link modules into the compiler
 data Linkable = LM {
-  linkableTime     :: ClockTime,	-- ^ Time at which this linkable was built
-					-- (i.e. when the bytecodes were produced,
-					--	 or the mod date on the files)
+  linkableTime     :: ClockTime,        -- ^ Time at which this linkable was built
+                                        -- (i.e. when the bytecodes were produced,
+                                        --       or the mod date on the files)
   linkableModule   :: Module,           -- ^ The linkable module itself
   linkableUnlinked :: [Unlinked]
     -- ^ Those files and chunks of code we have yet to link.
hunk ./compiler/main/HscTypes.lhs 1853
 isObjectLinkable :: Linkable -> Bool
 isObjectLinkable l = not (null unlinked) && all isObject unlinked
   where unlinked = linkableUnlinked l
-	-- A linkable with no Unlinked's is treated as a BCO.  We can
-	-- generate a linkable with no Unlinked's as a result of
-	-- compiling a module in HscNothing mode, and this choice
-	-- happens to work well with checkStability in module GHC.
+        -- A linkable with no Unlinked's is treated as a BCO.  We can
+        -- generate a linkable with no Unlinked's as a result of
+        -- compiling a module in HscNothing mode, and this choice
+        -- happens to work well with checkStability in module GHC.
 
 instance Outputable Linkable where
    ppr (LM when_made mod unlinkeds)
hunk ./compiler/main/HscTypes.lhs 1926
 data ModBreaks
    = ModBreaks
    { modBreaks_flags :: BreakArray
-        -- ^ The array of flags, one per breakpoint, 
+        -- ^ The array of flags, one per breakpoint,
         -- indicating which breakpoints are enabled.
    , modBreaks_locs :: !(Array BreakIndex SrcSpan)
         -- ^ An array giving the source span of each breakpoint.
hunk ./compiler/main/HscTypes.lhs 1939
 emptyModBreaks :: ModBreaks
 emptyModBreaks = ModBreaks
    { modBreaks_flags = error "ModBreaks.modBreaks_array not initialised"
-         -- Todo: can we avoid this? 
+         -- Todo: can we avoid this?
    , modBreaks_locs  = array (0,-1) []
    , modBreaks_vars  = array (0,-1) []
    , modBreaks_decls = array (0,-1) []
hunk ./compiler/typecheck/TcRnMonad.lhs 83
 	type_env_var <- case hsc_type_env_var hsc_env of {
                            Just (_mod, te_var) -> return te_var ;
                            Nothing             -> newIORef emptyNameEnv } ;
-      	let {
+        let {
              maybe_rn_syntax :: forall a. a -> Maybe a ;
              maybe_rn_syntax empty_val
 		| keep_rn_syntax = Just empty_val
hunk ./compiler/typecheck/TcRnMonad.lhs 88
 		| otherwise      = Nothing ;
-
+    
 	     gbl_env = TcGblEnv {
 		tcg_mod       = mod,
hunk ./compiler/typecheck/TcRnMonad.lhs 91
-		tcg_src	      = hsc_src,
+		tcg_src       = hsc_src,
 		tcg_rdr_env   = emptyGlobalRdrEnv,
 		tcg_fix_env   = emptyNameEnv,
 		tcg_field_env = RecFields emptyNameEnv emptyNameSet,
hunk ./compiler/typecheck/TcRnMonad.lhs 99
 		tcg_type_env  = emptyNameEnv,
 		tcg_type_env_var = type_env_var,
 		tcg_inst_env  = emptyInstEnv,
-		tcg_fam_inst_env  = emptyFamInstEnv,
+		tcg_fam_inst_env = emptyFamInstEnv,
                 tcg_th_used   = th_var,
hunk ./compiler/typecheck/TcRnMonad.lhs 101
-		tcg_exports  = [],
-		tcg_imports  = emptyImportAvails,
+		tcg_exports   = [],
+		tcg_imports   = emptyImportAvails,
                 tcg_used_rdrnames = used_rdr_var,
hunk ./compiler/typecheck/TcRnMonad.lhs 104
-		tcg_dus      = emptyDUs,
+		tcg_dus       = emptyDUs,
 
                 tcg_rn_imports = [],
                 tcg_rn_exports = maybe_rn_syntax [],
hunk ./compiler/typecheck/TcRnTypes.lhs 567
 --
 --  * when figuring out what things are really unused
 --
+
 data ImportAvails 
    = ImportAvails {
 	imp_mods :: ImportedMods,
}
[Fix small error in comment
David Terei <davidt@scs.stanford.edu>**20110303010340
 Ignore-this: 464411d2ecb9cf058cb398fc876d5678
] {
hunk ./compiler/basicTypes/NameSet.lhs 179
     get (Just d1, _u1) d2 = d1 `unionNameSets` d2
 
 allUses :: DefUses -> Uses
--- ^ Just like 'allUses', but 'Defs' are not eliminated from the 'Uses' returned
+-- ^ Just like 'duUses', but 'Defs' are not eliminated from the 'Uses' returned
 allUses dus = foldr get emptyNameSet dus
   where
     get (_d1, u1) u2 = u1 `unionNameSets` u2
hunk ./compiler/basicTypes/NameSet.lhs 187
 duUses :: DefUses -> Uses
 -- ^ Collect all 'Uses', regardless of whether the group is itself used,
 -- but remove 'Defs' on the way
-duUses dus
-  = foldr get emptyNameSet dus
+duUses dus = foldr get emptyNameSet dus
   where
     get (Nothing,   rhs_uses) uses = rhs_uses `unionNameSets` uses
     get (Just defs, rhs_uses) uses = (rhs_uses `unionNameSets` uses)
}
[Fix another small error in comments
David Terei <davidt@scs.stanford.edu>**20110303010442
 Ignore-this: f4d07b111a6935083b405c21fc241208
] hunk ./compiler/prelude/PrelRules.lhs 56
 like that, so we use a BuiltinRule instead, so that we
 can match in any two literal values.  So the rule is really
 more like
-        (Lit 4) +# (Lit y) = Lit (x+#y)
+        (Lit x) +# (Lit y) = Lit (x+#y)
 where the (+#) on the rhs is done at compile time
 
 That is why these rules are built in here.  Other rules
[SafeHaskell: Force all imports to be safe when Safe mode
David Terei <davidt@scs.stanford.edu>**20110303010722
 Ignore-this: a877cacbce5bbc8af2d8ef0818995562
] {
hunk ./compiler/iface/MkIface.lhs 907
 
         (is_direct_import, imp_safe)
             = case lookupModuleEnv direct_imports mod of
-                Just ((_,_,_,safe):xs) -> (True, safe)
-                Just _                 -> pprPanic "mkUsage: empty direct import" empty
-                Nothing                -> (False, False)
+                Just ((_,_,_,safe):_xs) -> (True, safe)
+                Just _                  -> pprPanic "mkUsage: empty direct import" empty
+                Nothing                 -> (False, safeImportsRequired dflags)
+                -- Nothing case is for implicit imports like 'System.IO' when 'putStrLn'
+                -- is used in the source code. We require them to be safe in SafeHaskell
 
         used_occs = lookupModuleEnv ent_map mod `orElse` []
 
hunk ./compiler/main/DynFlags.hs 37
         fFlags, fLangFlags, xFlags,
         DPHBackend(..), dphPackage,
         wayNames,
+
+        -- ** SafeHaskell
         SafeHaskellMode(..),
hunk ./compiler/main/DynFlags.hs 40
-        safeHaskellOn,
+        safeHaskellOn, safeImportsRequired,
 
         -- ** Manipulating DynFlags
         defaultDynFlags,                -- DynFlags
hunk ./compiler/main/DynFlags.hs 898
                          safeHaskell = combineSafeFlags sf s
                      }
 
+-- | Are all imports required to be safe for this SafeHaskell mode?
+safeImportsRequired :: DynFlags -> Bool
+safeImportsRequired dflags = m == Sf_SafeLanguage || m == Sf_Safe
+                            where m = safeHaskell dflags
+
 -- | Combine two SafeHaskell modes correctly. Used for dealing with multiple flags.
 -- This makes SafeHaskell very much a monoid but for now I prefer this as I don't
 -- want to export this functionality from the module but do want to export the
hunk ./compiler/rename/RnNames.lhs 221
                         Just (is_hiding, ls) -> not is_hiding && null ls
                         _                    -> False
 
+        mod_safe' = mod_safe || safeImportsRequired dflags
+
         imports   = ImportAvails {
hunk ./compiler/rename/RnNames.lhs 224
-                        imp_mods     = unitModuleEnv imp_mod [(qual_mod_name, import_all, loc, mod_safe)],
+                        imp_mods     = unitModuleEnv imp_mod [(qual_mod_name, import_all, loc, mod_safe')],
                         imp_orphs    = orphans,
                         imp_finsts   = finsts,
                         imp_dep_mods = mkModDeps dependent_mods,
hunk ./compiler/rename/RnNames.lhs 238
           _           -> return ()
      )
 
-    let new_imp_decl = L loc (ImportDecl loc_imp_mod_name mb_pkg want_boot mod_safe
+    let new_imp_decl = L loc (ImportDecl loc_imp_mod_name mb_pkg want_boot mod_safe'
                                          qual_only as_mod new_imp_details)
 
     return (new_imp_decl, gbl_env, imports, mi_hpc iface)
}
[Fix missing eol marker in RnSource.lhs
David Terei <davidt@scs.stanford.edu>**20110303010929
 Ignore-this: f13f472b5553ab02c7a6e864b1748ae7
] hunk ./compiler/rename/RnSource.lhs 1232
 add_sig s (ValBindsIn bs sigs) = ValBindsIn bs (s:sigs) 
 add_sig _ (ValBindsOut {})     = panic "RdrHsSyn:add_sig"
 \end{code}
+
[Formatting changes to Lexer.x
David Terei <davidt@scs.stanford.edu>**20110303220129
 Ignore-this: 1f581e5b539d46a2f2f4527983cf64d6
] {
hunk ./compiler/parser/Lexer.x 1876
       alr_justClosedExplicitLetBlock = False
     }
     where
-      bitmap = genericsBit `setBitIf` xopt Opt_Generics flags
+      bitmap =     genericsBit       `setBitIf` xopt Opt_Generics flags
                .|. ffiBit            `setBitIf` xopt Opt_ForeignFunctionInterface flags
                .|. parrBit           `setBitIf` xopt Opt_ParallelArrays  flags
                .|. arrowsBit         `setBitIf` xopt Opt_Arrows          flags
hunk ./compiler/parser/Lexer.x 1884
                .|. qqBit             `setBitIf` xopt Opt_QuasiQuotes     flags
                .|. ipBit             `setBitIf` xopt Opt_ImplicitParams  flags
                .|. explicitForallBit `setBitIf` xopt Opt_ExplicitForAll  flags
-               .|. bangPatBit        `setBitIf` xopt Opt_BangPatterns flags
-               .|. tyFamBit          `setBitIf` xopt Opt_TypeFamilies flags
-               .|. haddockBit        `setBitIf` dopt Opt_Haddock      flags
-               .|. magicHashBit      `setBitIf` xopt Opt_MagicHash    flags
-               .|. kindSigsBit       `setBitIf` xopt Opt_KindSignatures flags
-               .|. recursiveDoBit    `setBitIf` xopt Opt_RecursiveDo flags
-               .|. recBit            `setBitIf` xopt Opt_DoRec  flags
-               .|. recBit            `setBitIf` xopt Opt_Arrows flags
-               .|. unicodeSyntaxBit  `setBitIf` xopt Opt_UnicodeSyntax flags
-               .|. unboxedTuplesBit  `setBitIf` xopt Opt_UnboxedTuples flags
+               .|. bangPatBit        `setBitIf` xopt Opt_BangPatterns    flags
+               .|. tyFamBit          `setBitIf` xopt Opt_TypeFamilies    flags
+               .|. haddockBit        `setBitIf` dopt Opt_Haddock         flags
+               .|. magicHashBit      `setBitIf` xopt Opt_MagicHash       flags
+               .|. kindSigsBit       `setBitIf` xopt Opt_KindSignatures  flags
+               .|. recursiveDoBit    `setBitIf` xopt Opt_RecursiveDo     flags
+               .|. recBit            `setBitIf` xopt Opt_DoRec           flags
+               .|. recBit            `setBitIf` xopt Opt_Arrows          flags
+               .|. unicodeSyntaxBit  `setBitIf` xopt Opt_UnicodeSyntax   flags
+               .|. unboxedTuplesBit  `setBitIf` xopt Opt_UnboxedTuples   flags
                .|. datatypeContextsBit `setBitIf` xopt Opt_DatatypeContexts flags
                .|. transformComprehensionsBit `setBitIf` xopt Opt_TransformListComp flags
                .|. rawTokenStreamBit `setBitIf` dopt Opt_KeepRawTokenStream flags
hunk ./compiler/parser/Lexer.x 1898
                .|. alternativeLayoutRuleBit `setBitIf` xopt Opt_AlternativeLayoutRule flags
-               .|. relaxedLayoutBit `setBitIf` xopt Opt_RelaxedLayout flags
+               .|. relaxedLayoutBit  `setBitIf` xopt Opt_RelaxedLayout flags
                .|. nondecreasingIndentationBit `setBitIf` xopt Opt_NondecreasingIndentation flags
                .|. safeHaskellBit    `setBitIf` safeHaskellOn flags
       --
}
[SafeHaskell: First pass at checking safe imports are valid
David Terei <davidt@scs.stanford.edu>**20110308004119
 Ignore-this: c13dfe7b55a67bc9f0ddc3a0f87ca23f
] {
hunk ./compiler/iface/MkIface.lhs 909
             = case lookupModuleEnv direct_imports mod of
                 Just ((_,_,_,safe):_xs) -> (True, safe)
                 Just _                  -> pprPanic "mkUsage: empty direct import" empty
-                Nothing                 -> (False, safeImportsRequired dflags)
+                Nothing                 -> (False, safeImplicitImpsReq dflags)
                 -- Nothing case is for implicit imports like 'System.IO' when 'putStrLn'
                 -- is used in the source code. We require them to be safe in SafeHaskell
 
hunk ./compiler/main/DynFlags.hs 40
 
         -- ** SafeHaskell
         SafeHaskellMode(..),
-        safeHaskellOn, safeImportsRequired,
+        safeHaskellOn, safeDirectImpsReq, safeImplicitImpsReq,
 
         -- ** Manipulating DynFlags
         defaultDynFlags,                -- DynFlags
hunk ./compiler/main/DynFlags.hs 898
                          safeHaskell = combineSafeFlags sf s
                      }
 
--- | Are all imports required to be safe for this SafeHaskell mode?
-safeImportsRequired :: DynFlags -> Bool
-safeImportsRequired dflags = m == Sf_SafeLanguage || m == Sf_Safe
-                            where m = safeHaskell dflags
+-- | Are all direct imports required to be safe for this SafeHaskell mode?
+-- Direct imports are when the code explicitly imports a module
+safeDirectImpsReq :: DynFlags -> Bool
+safeDirectImpsReq dflags = s == Sf_SafeLanguage || s == Sf_Safe
+                          where s = safeHaskell dflags
+
+-- | Are all implicit imports required to be safe for this SafeHaskell mode?
+-- Implicit imports are things in the prelude. e.g System.IO when print is used.
+safeImplicitImpsReq :: DynFlags -> Bool
+safeImplicitImpsReq _ = False
 
 -- | Combine two SafeHaskell modes correctly. Used for dealing with multiple flags.
 -- This makes SafeHaskell very much a monoid but for now I prefer this as I don't
hunk ./compiler/main/HeaderInfo.hs 110
           ImportDecl (L loc pRELUDE_NAME)
                Nothing  {- No specific package -}
                False    {- Not a boot interface -}
-               False    {- Not a safe interface -}
+               False    {- Not a safe import -}
                False    {- Not qualified -}
                Nothing  {- No "as" -}
                Nothing  {- No import list -}
hunk ./compiler/main/HscMain.lhs 88
 #endif
 
 import Id		( Id )
-import Module		( emptyModuleEnv, ModLocation(..), Module )
+import Module
+import Packages
 import RdrName
 import HsSyn
 import CoreSyn
hunk ./compiler/main/HscMain.lhs 769
 --------------------------------------------------------------
 
 hscFileFrontEnd :: ModSummary -> Hsc TcGblEnv
-hscFileFrontEnd mod_summary =
-    do rdr_module <- hscParse' mod_summary
-       hsc_env <- getHscEnv
-       {-# SCC "Typecheck-Rename" #-}
-         ioMsgMaybe $ 
-             tcRnModule hsc_env (ms_hsc_src mod_summary) False rdr_module
+hscFileFrontEnd mod_summary = do
+    rdr_module <- hscParse' mod_summary
+    hsc_env <- getHscEnv
+    {-# SCC "Typecheck-Rename" #-}
+        tcg_env <- ioMsgMaybe $
+            tcRnModule hsc_env (ms_hsc_src mod_summary) False rdr_module
+    dflags <- getDynFlags
+    tcg_env' <- checkSafeImports dflags hsc_env tcg_env
+    return tcg_env'
+
+--------------------------------------------------------------
+-- SafeHaskell
+--------------------------------------------------------------
+
+-- | Validate that safe imported modules are actually safe.
+-- For modules in the HomePackage (the package the module we
+-- are compiling in resides) this just involves checking its
+-- trust type is 'Safe' or 'Trustworthy'. For modules that
+-- reside in another package we also must check that the
+-- external pacakge is trusted.
+checkSafeImports :: DynFlags -> HscEnv -> TcGblEnv -> Hsc TcGblEnv
+checkSafeImports dflags hsc_env tcg_env
+    | not (safeHaskellOn dflags)
+    = return tcg_env
+
+    | otherwise
+    = do
+        imps <- mapM condense imports'
+        mapM_ checkSafe imps
+        return tcg_env
+    where
+        imp_info = tcg_imports tcg_env     -- ImportAvails
+        imports  = imp_mods imp_info       -- ImportedMods
+        imports' = moduleEnvToList imports -- (Module, [ImportedModsVal])
+
+        condense :: (Module, [ImportedModsVal]) -> Hsc (Module, SrcSpan, IsSafeImport)
+        condense (_, [])   = panic "HscMain.condense: Pattern match failure!"
+        condense (m, x:xs) = do (_,_,l,s) <- foldlM cond' x xs
+                                return (m, l, s)
+        
+        -- ImportedModsVal = (ModuleName, Bool, SrcSpan, IsSafeImport)
+        cond' :: ImportedModsVal -> ImportedModsVal -> Hsc ImportedModsVal
+        cond' v1@(m1,_,l1,s1) (_,_,_,s2)
+            | s1 /= s2
+            = liftIO $ throwIO $ mkSrcErr $ unitBag $ mkPlainErrMsg l1
+                    (text "Module" <+> ppr m1 <+> (text $ "is imported"
+                        ++ " both as a safe and unsafe import!"))
+
+            | otherwise
+            = return v1
+
+        lookup' :: Module -> Hsc (Maybe ModIface)
+        lookup' m = do
+            hsc_eps <- liftIO $ hscEPS hsc_env
+            let pkgIfaceT = eps_PIT hsc_eps
+                homePkgT = hsc_HPT hsc_env
+                iface = lookupIfaceByModule dflags homePkgT pkgIfaceT m
+            return iface
+
+        -- | Check the package a module resides in is trusted.
+        -- Modules in the home package are trusted but otherwise
+        -- we check the packages trust flag.
+        packageTrusted :: Module -> Bool
+        packageTrusted m
+            | thisPackage dflags == modulePackageId m = True
+            | otherwise = trusted $ getPackageDetails (pkgState dflags)
+                                                      (modulePackageId m)
+
+        -- Is a module a Safe importable? Return Nothing if True, or a String
+        -- if it isn't containing the reason it isn't
+        isModSafe :: Module -> SrcSpan -> Hsc (Maybe SDoc)
+        isModSafe m l = do
+            iface <- lookup' m
+            case iface of
+                -- can't load iface to check trust!
+                Nothing -> liftIO $ throwIO $ mkSrcErr $ unitBag $ mkPlainErrMsg l
+                            $ text "Can't load the interface file for" <+> ppr m <>
+                              text ", to check that it can be safely imported"
+
+                -- got iface, check trust
+                Just iface' -> do
+                    let trust = getSafeMode $ mi_trust iface'
+                        -- check module is trusted
+                        safeM = trust `elem` [Sf_Safe, Sf_Trustworthy,
+                                            Sf_TrustworthyWithSafeLanguage]
+                        -- check package is trusted
+                        safeP = packageTrusted m
+                    if safeM && safeP
+                        then return Nothing
+                        else return $ Just $ if safeM
+                            then text "The package (" <> ppr (modulePackageId m) <>
+                                 text ") the module resides in isn't trusted."
+                            else text "The module itself isn't safe."
+
+        checkSafe :: (Module, SrcSpan, IsSafeImport) -> Hsc ()
+        checkSafe (_, _, False) = return ()
+        checkSafe (m, l, True ) = do
+            module_safe <- isModSafe m l
+            case module_safe of
+                Nothing -> return ()
+                Just s  -> liftIO $ throwIO $ mkSrcErr $ unitBag $ mkPlainErrMsg l
+                            $ text "Safe import of" <+> ppr m <+> text "can't be met!"
+                                <+> s
 
 --------------------------------------------------------------
 -- Simplifiers
hunk ./compiler/main/HscTypes.lhs 18
         -- * Information about modules
         ModDetails(..), emptyModDetails,
         ModGuts(..), CgGuts(..), ForeignStubs(..),
-        ImportedMods,
+        ImportedMods, ImportedModsVal,
 
         ModSummary(..), ms_mod_name, showModMsg, isBootSummary,
         msHsFilePath, msHiFilePath, msObjFilePath,
hunk ./compiler/main/HscTypes.lhs 715
                              }
 
 -- | Records the modules directly imported by a module for extracting e.g. usage information
-type ImportedMods = ModuleEnv [(ModuleName, Bool, SrcSpan, IsSafeImport)]
+type ImportedMods = ModuleEnv [ImportedModsVal]
+type ImportedModsVal = (ModuleName, Bool, SrcSpan, IsSafeImport)
+
 -- TODO: we are not actually using the codomain of this type at all, so it can be
 -- replaced with ModuleEnv ()
 
hunk ./compiler/rename/RnNames.lhs 221
                         Just (is_hiding, ls) -> not is_hiding && null ls
                         _                    -> False
 
-        mod_safe' = mod_safe || safeImportsRequired dflags
+        -- should the import be safe?
+        mod_safe' = mod_safe
+                    || (not implicit_prelude && safeDirectImpsReq dflags)
+                    || (implicit_prelude && safeImplicitImpsReq dflags)
 
         imports   = ImportAvails {
                         imp_mods     = unitModuleEnv imp_mod [(qual_mod_name, import_all, loc, mod_safe')],
}
[Trim some trailing spaces
David Terei <davidt@scs.stanford.edu>**20110308004329
 Ignore-this: a3e4fdd9e32099d9319dc8a118c69bf8
] hunk ./compiler/main/HscMain.lhs 1217
 hscTcExpr hsc_env expr = runHsc hsc_env $ do
     maybe_stmt <- hscParseStmt expr
     case maybe_stmt of
-      Just (L _ (ExprStmt expr _ _)) ->
-          ioMsgMaybe $ tcRnExpr hsc_env (hsc_IC hsc_env) expr
-      _ -> 
-          liftIO $ throwIO $ mkSrcErr $ unitBag $ 
-              mkPlainErrMsg noSrcSpan
-                            (text "not an expression:" <+> quotes (text expr))
+        Just (L _ (ExprStmt expr _ _)) ->
+            ioMsgMaybe $ tcRnExpr hsc_env (hsc_IC hsc_env) expr
+        _ ->
+            liftIO $ throwIO $ mkSrcErr $ unitBag $ mkPlainErrMsg noSrcSpan
+                (text "not an expression:" <+> quotes (text expr))
 
 -- | Find the kind of a type
 hscKcType
[Consistent order of flag processing.
David Terei <davidt@scs.stanford.edu>**20110309190751
 Ignore-this: 22f2b1add7b6a23f4a73500db30e54ff
 
 Some code paths for handling pragmas would check they are valid
 and then check if any are depreciated, while others would swap these
 steps around. We now consistently check they are valid and then warn
 for depreciated.
] {
hunk ./compiler/main/DriverPipeline.hs 701
             src_opts <- getOptionsFromFile dflags0 output_fn
             (dflags2, unhandled_flags, warns)
                 <- parseDynamicNoPackageFlags dflags0 src_opts
-            unless (dopt Opt_Pp dflags2) $ handleFlagWarnings dflags2 warns
             -- the HsPp pass below will emit warnings
             checkProcessArgsResult unhandled_flags
hunk ./compiler/main/DriverPipeline.hs 703
+            unless (dopt Opt_Pp dflags2) $ handleFlagWarnings dflags2 warns
 
             return (HsPp sf, dflags2, maybe_loc, output_fn)
 
hunk ./compiler/main/DriverPipeline.hs 732
             src_opts <- getOptionsFromFile dflags output_fn
             (dflags1, unhandled_flags, warns)
                 <- parseDynamicNoPackageFlags dflags src_opts
-            handleFlagWarnings dflags1 warns
             checkProcessArgsResult unhandled_flags
hunk ./compiler/main/DriverPipeline.hs 733
+            handleFlagWarnings dflags1 warns
 
             return (Hsc sf, dflags1, maybe_loc, output_fn)
 
}
[Format wibble
David Terei <davidt@scs.stanford.edu>**20110330212740
 Ignore-this: 1c49859068210796c6de25a52a417ace
] hunk ./compiler/main/DriverPipeline.hs 713
 runPhase (HsPp sf) _stop hsc_env basename suff input_fn get_output_fn maybe_loc
   = do let dflags = hsc_dflags hsc_env
        if not (dopt Opt_Pp dflags) then
-           -- no need to preprocess, just pass input file along
-           -- to the next phase of the pipeline.
-          return (Hsc sf, dflags, maybe_loc, input_fn)
+             -- no need to preprocess, just pass input file along
+             -- to the next phase of the pipeline.
+            return (Hsc sf, dflags, maybe_loc, input_fn)
         else do
             let hspp_opts = getOpts dflags opt_F
             let orig_fn = basename <.> suff
[Format wibble
David Terei <davidt@scs.stanford.edu>**20110330212752
 Ignore-this: d355614356808fed35c8ae9a645bfa71
] hunk ./compiler/main/GhcMake.hs 1394
   = do
         let dflags = hsc_dflags hsc_env
 	-- case we bypass the preprocessing stage?
-	let 
-	    local_opts = getOptions dflags buf src_fn
-	--
+	let local_opts = getOptions dflags buf src_fn
+	
 	(dflags', leftovers, warns)
             <- parseDynamicNoPackageFlags dflags local_opts
         checkProcessArgsResult leftovers
[Change GhcMake to unix file format
David Terei <davidt@scs.stanford.edu>**20110330212841
 Ignore-this: e803f3a38a7cb8de85a83c70deb7aa28
] hunk ./compiler/main/GhcMake.hs 1
--- -----------------------------------------------------------------------------
---
--- (c) The University of Glasgow, 2005
---
---       This module deals with --make
--- -----------------------------------------------------------------------------
-
-module GhcMake( 
-  depanal, 
-  load, LoadHowMuch(..),
-
-  topSortModuleGraph, 
-
-  noModError, cyclicModuleErr
-  ) where
-
-#include "HsVersions.h"
-
-#ifdef GHCI
-import qualified Linker		( unload )
-#endif
-
-import DriverPipeline
-import DriverPhases
-import GhcMonad
-import Module
-import HscTypes
-import ErrUtils
-import DynFlags
-import HsSyn hiding ((<.>))
-import Finder
-import HeaderInfo
-import TcIface		( typecheckIface )
-import TcRnMonad	( initIfaceCheck )
-import RdrName		( RdrName )
-
-import Exception	( evaluate, tryIO )
-import Panic
-import SysTools
-import BasicTypes
-import SrcLoc
-import Util
-import Digraph
-import Bag		( listToBag )
-import Maybes		( expectJust, mapCatMaybes )
-import StringBuffer
-import FastString
-import Outputable
-import UniqFM
-
-import qualified Data.Map as Map
-import qualified FiniteMap as Map( insertListWith)
-
-import System.Directory ( doesFileExist, getModificationTime )
-import System.IO	( fixIO )
-import System.IO.Error	( isDoesNotExistError )
-import System.Time	( ClockTime )
-import System.FilePath
-import Control.Monad
-import Data.Maybe
-import Data.List
-import qualified Data.List as List
-
--- -----------------------------------------------------------------------------
--- Loading the program
-
--- | Perform a dependency analysis starting from the current targets
--- and update the session with the new module graph.
---
--- Dependency analysis entails parsing the @import@ directives and may
--- therefore require running certain preprocessors.
---
--- Note that each 'ModSummary' in the module graph caches its 'DynFlags'.
--- These 'DynFlags' are determined by the /current/ session 'DynFlags' and the
--- @OPTIONS@ and @LANGUAGE@ pragmas of the parsed module.  Thus if you want to
--- changes to the 'DynFlags' to take effect you need to call this function
--- again.
---
-depanal :: GhcMonad m =>
-           [ModuleName]  -- ^ excluded modules
-        -> Bool          -- ^ allow duplicate roots
-        -> m ModuleGraph
-depanal excluded_mods allow_dup_roots = do
-  hsc_env <- getSession
-  let
-	 dflags  = hsc_dflags hsc_env
-	 targets = hsc_targets hsc_env
-	 old_graph = hsc_mod_graph hsc_env
-	
-  liftIO $ showPass dflags "Chasing dependencies"
-  liftIO $ debugTraceMsg dflags 2 (hcat [
-	     text "Chasing modules from: ",
-	     hcat (punctuate comma (map pprTarget targets))])
-
-  mod_graph <- liftIO $ downsweep hsc_env old_graph excluded_mods allow_dup_roots
-  modifySession $ \_ -> hsc_env { hsc_mod_graph = mod_graph }
-  return mod_graph
-
--- | Describes which modules of the module graph need to be loaded.
-data LoadHowMuch
-   = LoadAllTargets
-     -- ^ Load all targets and its dependencies.
-   | LoadUpTo ModuleName
-     -- ^ Load only the given module and its dependencies.
-   | LoadDependenciesOf ModuleName
-     -- ^ Load only the dependencies of the given module, but not the module
-     -- itself.
-
--- | Try to load the program.  See 'LoadHowMuch' for the different modes.
---
--- This function implements the core of GHC's @--make@ mode.  It preprocesses,
--- compiles and loads the specified modules, avoiding re-compilation wherever
--- possible.  Depending on the target (see 'DynFlags.hscTarget') compilating
--- and loading may result in files being created on disk.
---
--- Calls the 'reportModuleCompilationResult' callback after each compiling
--- each module, whether successful or not.
---
--- Throw a 'SourceError' if errors are encountered before the actual
--- compilation starts (e.g., during dependency analysis).  All other errors
--- are reported using the callback.
---
-load :: GhcMonad m => LoadHowMuch -> m SuccessFlag
-load how_much = do
-   mod_graph <- depanal [] False
-   load2 how_much mod_graph
-
-load2 :: GhcMonad m => LoadHowMuch -> [ModSummary]
-      -> m SuccessFlag
-load2 how_much mod_graph = do
-        guessOutputFile
-	hsc_env <- getSession
-
-        let hpt1      = hsc_HPT hsc_env
-        let dflags    = hsc_dflags hsc_env
-
-	-- The "bad" boot modules are the ones for which we have
-	-- B.hs-boot in the module graph, but no B.hs
-	-- The downsweep should have ensured this does not happen
-	-- (see msDeps)
-        let all_home_mods = [ms_mod_name s 
-			    | s <- mod_graph, not (isBootSummary s)]
-	    bad_boot_mods = [s 	      | s <- mod_graph, isBootSummary s,
-					not (ms_mod_name s `elem` all_home_mods)]
-	ASSERT( null bad_boot_mods ) return ()
-
-        -- check that the module given in HowMuch actually exists, otherwise
-        -- topSortModuleGraph will bomb later.
-        let checkHowMuch (LoadUpTo m)           = checkMod m
-            checkHowMuch (LoadDependenciesOf m) = checkMod m
-            checkHowMuch _ = id
-
-            checkMod m and_then
-                | m `elem` all_home_mods = and_then
-                | otherwise = do 
-                        liftIO $ errorMsg dflags (text "no such module:" <+>
-                                         quotes (ppr m))
-                        return Failed
-
-        checkHowMuch how_much $ do
-
-        -- mg2_with_srcimps drops the hi-boot nodes, returning a 
-	-- graph with cycles.  Among other things, it is used for
-        -- backing out partially complete cycles following a failed
-        -- upsweep, and for removing from hpt all the modules
-        -- not in strict downwards closure, during calls to compile.
-        let mg2_with_srcimps :: [SCC ModSummary]
-	    mg2_with_srcimps = topSortModuleGraph True mod_graph Nothing
-
-	-- If we can determine that any of the {-# SOURCE #-} imports
-	-- are definitely unnecessary, then emit a warning.
-	warnUnnecessarySourceImports mg2_with_srcimps
-
- 	let
-	    -- check the stability property for each module.
-	    stable_mods@(stable_obj,stable_bco)
-	        = checkStability hpt1 mg2_with_srcimps all_home_mods
-
-	    -- prune bits of the HPT which are definitely redundant now,
-	    -- to save space.
-	    pruned_hpt = pruneHomePackageTable hpt1 
-				(flattenSCCs mg2_with_srcimps)
-				stable_mods
-
-	_ <- liftIO $ evaluate pruned_hpt
-
-        -- before we unload anything, make sure we don't leave an old
-        -- interactive context around pointing to dead bindings.  Also,
-        -- write the pruned HPT to allow the old HPT to be GC'd.
-        modifySession $ \_ -> hsc_env{ hsc_IC = emptyInteractiveContext,
-                                       hsc_HPT = pruned_hpt }
-
-	liftIO $ debugTraceMsg dflags 2 (text "Stable obj:" <+> ppr stable_obj $$
-				text "Stable BCO:" <+> ppr stable_bco)
-
-	-- Unload any modules which are going to be re-linked this time around.
-	let stable_linkables = [ linkable
-			       | m <- stable_obj++stable_bco,
-				 Just hmi <- [lookupUFM pruned_hpt m],
-				 Just linkable <- [hm_linkable hmi] ]
-	liftIO $ unload hsc_env stable_linkables
-
-        -- We could at this point detect cycles which aren't broken by
-        -- a source-import, and complain immediately, but it seems better
-        -- to let upsweep_mods do this, so at least some useful work gets
-        -- done before the upsweep is abandoned.
-        --hPutStrLn stderr "after tsort:\n"
-        --hPutStrLn stderr (showSDoc (vcat (map ppr mg2)))
-
-        -- Now do the upsweep, calling compile for each module in
-        -- turn.  Final result is version 3 of everything.
-
-        -- Topologically sort the module graph, this time including hi-boot
-	-- nodes, and possibly just including the portion of the graph
-	-- reachable from the module specified in the 2nd argument to load.
-	-- This graph should be cycle-free.
-	-- If we're restricting the upsweep to a portion of the graph, we
-	-- also want to retain everything that is still stable.
-        let full_mg :: [SCC ModSummary]
-	    full_mg    = topSortModuleGraph False mod_graph Nothing
-
-	    maybe_top_mod = case how_much of
-				LoadUpTo m           -> Just m
-			  	LoadDependenciesOf m -> Just m
-			  	_		     -> Nothing
-
-	    partial_mg0 :: [SCC ModSummary]
-	    partial_mg0 = topSortModuleGraph False mod_graph maybe_top_mod
-
-	    -- LoadDependenciesOf m: we want the upsweep to stop just
-	    -- short of the specified module (unless the specified module
-	    -- is stable).
-	    partial_mg
-		| LoadDependenciesOf _mod <- how_much
-		= ASSERT( case last partial_mg0 of 
-			    AcyclicSCC ms -> ms_mod_name ms == _mod; _ -> False )
-		  List.init partial_mg0
-		| otherwise
-		= partial_mg0
-  
-	    stable_mg = 
-		[ AcyclicSCC ms
-	        | AcyclicSCC ms <- full_mg,
-		  ms_mod_name ms `elem` stable_obj++stable_bco,
-		  ms_mod_name ms `notElem` [ ms_mod_name ms' | 
-						AcyclicSCC ms' <- partial_mg ] ]
-
-	    mg = stable_mg ++ partial_mg
-
-	-- clean up between compilations
-	let cleanup = cleanTempFilesExcept dflags
-			  (ppFilesFromSummaries (flattenSCCs mg2_with_srcimps))
-
-	liftIO $ debugTraceMsg dflags 2 (hang (text "Ready for upsweep")
-				   2 (ppr mg))
-
-        setSession hsc_env{ hsc_HPT = emptyHomePackageTable }
-        (upsweep_ok, modsUpswept)
-           <- upsweep pruned_hpt stable_mods cleanup mg
-
-	-- Make modsDone be the summaries for each home module now
-	-- available; this should equal the domain of hpt3.
-        -- Get in in a roughly top .. bottom order (hence reverse).
-
-        let modsDone = reverse modsUpswept
-
-        -- Try and do linking in some form, depending on whether the
-        -- upsweep was completely or only partially successful.
-
-        if succeeded upsweep_ok
-
-         then 
-           -- Easy; just relink it all.
-           do liftIO $ debugTraceMsg dflags 2 (text "Upsweep completely successful.")
-
-	      -- Clean up after ourselves
-	      liftIO $ cleanTempFilesExcept dflags (ppFilesFromSummaries modsDone)
-
-	      -- Issue a warning for the confusing case where the user
-	      -- said '-o foo' but we're not going to do any linking.
-	      -- We attempt linking if either (a) one of the modules is
-	      -- called Main, or (b) the user said -no-hs-main, indicating
-	      -- that main() is going to come from somewhere else.
-	      --
-	      let ofile = outputFile dflags
-	      let no_hs_main = dopt Opt_NoHsMain dflags
-	      let 
-	 	main_mod = mainModIs dflags
-		a_root_is_Main = any ((==main_mod).ms_mod) mod_graph
-		do_linking = a_root_is_Main || no_hs_main || ghcLink dflags == LinkDynLib
-
-	      when (ghcLink dflags == LinkBinary 
-                    && isJust ofile && not do_linking) $
-	        liftIO $ debugTraceMsg dflags 1 $
-                    text ("Warning: output was redirected with -o, " ++
-                          "but no output will be generated\n" ++
-			  "because there is no " ++ 
-                          moduleNameString (moduleName main_mod) ++ " module.")
-
-	      -- link everything together
-              hsc_env1 <- getSession
-              linkresult <- liftIO $ link (ghcLink dflags) dflags do_linking (hsc_HPT hsc_env1)
-
-	      loadFinish Succeeded linkresult
-
-         else 
-           -- Tricky.  We need to back out the effects of compiling any
-           -- half-done cycles, both so as to clean up the top level envs
-           -- and to avoid telling the interactive linker to link them.
-           do liftIO $ debugTraceMsg dflags 2 (text "Upsweep partially successful.")
-
-              let modsDone_names
-                     = map ms_mod modsDone
-              let mods_to_zap_names 
-                     = findPartiallyCompletedCycles modsDone_names 
-			  mg2_with_srcimps
-              let mods_to_keep
-                     = filter ((`notElem` mods_to_zap_names).ms_mod) 
-			  modsDone
-
-              hsc_env1 <- getSession
-              let hpt4 = retainInTopLevelEnvs (map ms_mod_name mods_to_keep) 
-					      (hsc_HPT hsc_env1)
-
-	      -- Clean up after ourselves
-	      liftIO $ cleanTempFilesExcept dflags (ppFilesFromSummaries mods_to_keep)
-
-	      -- there should be no Nothings where linkables should be, now
-	      ASSERT(all (isJust.hm_linkable) 
-			(eltsUFM (hsc_HPT hsc_env))) do
-	
-	      -- Link everything together
-              linkresult <- liftIO $ link (ghcLink dflags) dflags False hpt4
-
-              modifySession $ \hsc_env -> hsc_env{ hsc_HPT = hpt4 }
-	      loadFinish Failed linkresult
-
--- Finish up after a load.
-
--- If the link failed, unload everything and return.
-loadFinish :: GhcMonad m =>
-              SuccessFlag -> SuccessFlag
-           -> m SuccessFlag
-loadFinish _all_ok Failed
-  = do hsc_env <- getSession
-       liftIO $ unload hsc_env []
-       modifySession discardProg
-       return Failed
-
--- Empty the interactive context and set the module context to the topmost
--- newly loaded module, or the Prelude if none were loaded.
-loadFinish all_ok Succeeded
-  = do modifySession $ \hsc_env -> hsc_env{ hsc_IC = emptyInteractiveContext }
-       return all_ok
-
-
--- Forget the current program, but retain the persistent info in HscEnv
-discardProg :: HscEnv -> HscEnv
-discardProg hsc_env
-  = hsc_env { hsc_mod_graph = emptyMG, 
-	      hsc_IC = emptyInteractiveContext,
-	      hsc_HPT = emptyHomePackageTable }
-
--- used to fish out the preprocess output files for the purposes of
--- cleaning up.  The preprocessed file *might* be the same as the
--- source file, but that doesn't do any harm.
-ppFilesFromSummaries :: [ModSummary] -> [FilePath]
-ppFilesFromSummaries summaries = map ms_hspp_file summaries
-
--- | If there is no -o option, guess the name of target executable
--- by using top-level source file name as a base.
-guessOutputFile :: GhcMonad m => m ()
-guessOutputFile = modifySession $ \env ->
-    let dflags = hsc_dflags env
-        mod_graph = hsc_mod_graph env
-        mainModuleSrcPath :: Maybe String
-        mainModuleSrcPath = do
-            let isMain = (== mainModIs dflags) . ms_mod
-            [ms] <- return (filter isMain mod_graph)
-            ml_hs_file (ms_location ms)
-        name = fmap dropExtension mainModuleSrcPath
-
-#if defined(mingw32_HOST_OS)
-        -- we must add the .exe extention unconditionally here, otherwise
-        -- when name has an extension of its own, the .exe extension will
-        -- not be added by DriverPipeline.exeFileName.  See #2248
-        name_exe = fmap (<.> "exe") name
-#else
-        name_exe = name
-#endif
-    in
-    case outputFile dflags of
-        Just _ -> env
-        Nothing -> env { hsc_dflags = dflags { outputFile = name_exe } }
-
--- -----------------------------------------------------------------------------
-
--- | Prune the HomePackageTable
---
--- Before doing an upsweep, we can throw away:
---
---   - For non-stable modules:
---	- all ModDetails, all linked code
---   - all unlinked code that is out of date with respect to
---     the source file
---
--- This is VERY IMPORTANT otherwise we'll end up requiring 2x the
--- space at the end of the upsweep, because the topmost ModDetails of the
--- old HPT holds on to the entire type environment from the previous
--- compilation.
-
-pruneHomePackageTable
-   :: HomePackageTable
-   -> [ModSummary]
-   -> ([ModuleName],[ModuleName])
-   -> HomePackageTable
-
-pruneHomePackageTable hpt summ (stable_obj, stable_bco)
-  = mapUFM prune hpt
-  where prune hmi
-	  | is_stable modl = hmi'
-	  | otherwise      = hmi'{ hm_details = emptyModDetails }
-	  where
-	   modl = moduleName (mi_module (hm_iface hmi))
-	   hmi' | Just l <- hm_linkable hmi, linkableTime l < ms_hs_date ms
-		= hmi{ hm_linkable = Nothing }
-		| otherwise
-		= hmi
-		where ms = expectJust "prune" (lookupUFM ms_map modl)
-
-        ms_map = listToUFM [(ms_mod_name ms, ms) | ms <- summ]
-
-	is_stable m = m `elem` stable_obj || m `elem` stable_bco
-
--- -----------------------------------------------------------------------------
-
--- Return (names of) all those in modsDone who are part of a cycle
--- as defined by theGraph.
-findPartiallyCompletedCycles :: [Module] -> [SCC ModSummary] -> [Module]
-findPartiallyCompletedCycles modsDone theGraph
-   = chew theGraph
-     where
-        chew [] = []
-        chew ((AcyclicSCC _):rest) = chew rest    -- acyclic?  not interesting.
-        chew ((CyclicSCC vs):rest)
-           = let names_in_this_cycle = nub (map ms_mod vs)
-                 mods_in_this_cycle  
-                    = nub ([done | done <- modsDone, 
-                                   done `elem` names_in_this_cycle])
-                 chewed_rest = chew rest
-             in 
-             if   notNull mods_in_this_cycle
-                  && length mods_in_this_cycle < length names_in_this_cycle
-             then mods_in_this_cycle ++ chewed_rest
-             else chewed_rest
-
-
--- ---------------------------------------------------------------------------
--- Unloading
-
-unload :: HscEnv -> [Linkable] -> IO ()
-unload hsc_env stable_linkables	-- Unload everthing *except* 'stable_linkables'
-  = case ghcLink (hsc_dflags hsc_env) of
-#ifdef GHCI
-	LinkInMemory -> Linker.unload (hsc_dflags hsc_env) stable_linkables
-#else
-	LinkInMemory -> panic "unload: no interpreter"
-                                -- urgh.  avoid warnings:
-                                hsc_env stable_linkables
-#endif
-	_other -> return ()
-
--- -----------------------------------------------------------------------------
-
-{- |
-
-  Stability tells us which modules definitely do not need to be recompiled.
-  There are two main reasons for having stability:
-  
-   - avoid doing a complete upsweep of the module graph in GHCi when
-     modules near the bottom of the tree have not changed.
-
-   - to tell GHCi when it can load object code: we can only load object code
-     for a module when we also load object code fo  all of the imports of the
-     module.  So we need to know that we will definitely not be recompiling
-     any of these modules, and we can use the object code.
-
-  The stability check is as follows.  Both stableObject and
-  stableBCO are used during the upsweep phase later.
-
-@
-  stable m = stableObject m || stableBCO m
-
-  stableObject m = 
-	all stableObject (imports m)
-	&& old linkable does not exist, or is == on-disk .o
-	&& date(on-disk .o) > date(.hs)
-
-  stableBCO m =
-	all stable (imports m)
-	&& date(BCO) > date(.hs)
-@
-
-  These properties embody the following ideas:
-
-    - if a module is stable, then:
-
-	- if it has been compiled in a previous pass (present in HPT)
-	  then it does not need to be compiled or re-linked.
-
-        - if it has not been compiled in a previous pass,
-	  then we only need to read its .hi file from disk and
-	  link it to produce a 'ModDetails'.
-
-    - if a modules is not stable, we will definitely be at least
-      re-linking, and possibly re-compiling it during the 'upsweep'.
-      All non-stable modules can (and should) therefore be unlinked
-      before the 'upsweep'.
-
-    - Note that objects are only considered stable if they only depend
-      on other objects.  We can't link object code against byte code.
--}
-
-checkStability
-	:: HomePackageTable		-- HPT from last compilation
-	-> [SCC ModSummary]		-- current module graph (cyclic)
-	-> [ModuleName]			-- all home modules
-	-> ([ModuleName],		-- stableObject
-	    [ModuleName])		-- stableBCO
-
-checkStability hpt sccs all_home_mods = foldl checkSCC ([],[]) sccs
-  where
-   checkSCC (stable_obj, stable_bco) scc0
-     | stableObjects = (scc_mods ++ stable_obj, stable_bco)
-     | stableBCOs    = (stable_obj, scc_mods ++ stable_bco)
-     | otherwise     = (stable_obj, stable_bco)
-     where
-	scc = flattenSCC scc0
-	scc_mods = map ms_mod_name scc
-	home_module m   = m `elem` all_home_mods && m `notElem` scc_mods
-
-        scc_allimps = nub (filter home_module (concatMap ms_home_allimps scc))
-	    -- all imports outside the current SCC, but in the home pkg
-	
-	stable_obj_imps = map (`elem` stable_obj) scc_allimps
-	stable_bco_imps = map (`elem` stable_bco) scc_allimps
-
-	stableObjects = 
-	   and stable_obj_imps
-	   && all object_ok scc
-
-	stableBCOs = 
-	   and (zipWith (||) stable_obj_imps stable_bco_imps)
-	   && all bco_ok scc
-
-	object_ok ms
-	  | Just t <- ms_obj_date ms  =  t >= ms_hs_date ms 
-					 && same_as_prev t
-	  | otherwise = False
-	  where
-	     same_as_prev t = case lookupUFM hpt (ms_mod_name ms) of
-				Just hmi  | Just l <- hm_linkable hmi
-				 -> isObjectLinkable l && t == linkableTime l
-				_other  -> True
-		-- why '>=' rather than '>' above?  If the filesystem stores
-		-- times to the nearset second, we may occasionally find that
-		-- the object & source have the same modification time, 
-		-- especially if the source was automatically generated
-		-- and compiled.  Using >= is slightly unsafe, but it matches
-		-- make's behaviour.
-
-	bco_ok ms
-	  = case lookupUFM hpt (ms_mod_name ms) of
-		Just hmi  | Just l <- hm_linkable hmi ->
-			not (isObjectLinkable l) && 
-			linkableTime l >= ms_hs_date ms
-		_other  -> False
-
--- -----------------------------------------------------------------------------
-
--- | The upsweep
---
--- This is where we compile each module in the module graph, in a pass
--- from the bottom to the top of the graph.
---
--- There better had not be any cyclic groups here -- we check for them.
-
-upsweep
-    :: GhcMonad m
-    => HomePackageTable		-- ^ HPT from last time round (pruned)
-    -> ([ModuleName],[ModuleName]) -- ^ stable modules (see checkStability)
-    -> IO ()			-- ^ How to clean up unwanted tmp files
-    -> [SCC ModSummary]		-- ^ Mods to do (the worklist)
-    -> m (SuccessFlag,
-          [ModSummary])
-       -- ^ Returns:
-       --
-       --  1. A flag whether the complete upsweep was successful.
-       --  2. The 'HscEnv' in the monad has an updated HPT
-       --  3. A list of modules which succeeded loading.
-
-upsweep old_hpt stable_mods cleanup sccs = do
-   (res, done) <- upsweep' old_hpt [] sccs 1 (length sccs)
-   return (res, reverse done)
- where
-
-  upsweep' _old_hpt done
-     [] _ _
-   = return (Succeeded, done)
-
-  upsweep' _old_hpt done
-     (CyclicSCC ms:_) _ _
-   = do dflags <- getSessionDynFlags
-        liftIO $ fatalErrorMsg dflags (cyclicModuleErr ms)
-        return (Failed, done)
-
-  upsweep' old_hpt done
-     (AcyclicSCC mod:mods) mod_index nmods
-   = do -- putStrLn ("UPSWEEP_MOD: hpt = " ++ 
-	--	     show (map (moduleUserString.moduleName.mi_module.hm_iface) 
-	--		       (moduleEnvElts (hsc_HPT hsc_env)))
-        let logger _mod = defaultWarnErrLogger
-
-        hsc_env <- getSession
-        mb_mod_info
-            <- handleSourceError
-                   (\err -> do logger mod (Just err); return Nothing) $ do
-                 mod_info <- liftIO $ upsweep_mod hsc_env old_hpt stable_mods
-                                                  mod mod_index nmods
-                 logger mod Nothing -- log warnings
-                 return (Just mod_info)
-
-        liftIO cleanup -- Remove unwanted tmp files between compilations
-
-        case mb_mod_info of
-          Nothing -> return (Failed, done)
-          Just mod_info -> do
-		let this_mod = ms_mod_name mod
-
-			-- Add new info to hsc_env
-		    hpt1     = addToUFM (hsc_HPT hsc_env) this_mod mod_info
-		    hsc_env1 = hsc_env { hsc_HPT = hpt1 }
-
-			-- Space-saving: delete the old HPT entry
-			-- for mod BUT if mod is a hs-boot
-			-- node, don't delete it.  For the
-			-- interface, the HPT entry is probaby for the
-			-- main Haskell source file.  Deleting it
-			-- would force the real module to be recompiled
-                        -- every time.
-		    old_hpt1 | isBootSummary mod = old_hpt
-			     | otherwise = delFromUFM old_hpt this_mod
-
-                    done' = mod:done
-
-                        -- fixup our HomePackageTable after we've finished compiling
-                        -- a mutually-recursive loop.  See reTypecheckLoop, below.
-                hsc_env2 <- liftIO $ reTypecheckLoop hsc_env1 mod done'
-                setSession hsc_env2
-
-		upsweep' old_hpt1 done' mods (mod_index+1) nmods
-
--- | Compile a single module.  Always produce a Linkable for it if
--- successful.  If no compilation happened, return the old Linkable.
-upsweep_mod :: HscEnv
-            -> HomePackageTable
-	    -> ([ModuleName],[ModuleName])
-            -> ModSummary
-            -> Int  -- index of module
-            -> Int  -- total number of modules
-            -> IO HomeModInfo
-
-upsweep_mod hsc_env old_hpt (stable_obj, stable_bco) summary mod_index nmods
-   =    let 
-       	    this_mod_name = ms_mod_name summary
-	    this_mod    = ms_mod summary
-	    mb_obj_date = ms_obj_date summary
-	    obj_fn	= ml_obj_file (ms_location summary)
-	    hs_date     = ms_hs_date summary
-
-	    is_stable_obj = this_mod_name `elem` stable_obj
-	    is_stable_bco = this_mod_name `elem` stable_bco
-
-	    old_hmi = lookupUFM old_hpt this_mod_name
-
-            -- We're using the dflags for this module now, obtained by
-            -- applying any options in its LANGUAGE & OPTIONS_GHC pragmas.
-            dflags = ms_hspp_opts summary
-            prevailing_target = hscTarget (hsc_dflags hsc_env)
-            local_target      = hscTarget dflags
-
-            -- If OPTIONS_GHC contains -fasm or -fvia-C, be careful that
-            -- we don't do anything dodgy: these should only work to change
-            -- from -fvia-C to -fasm and vice-versa, otherwise we could 
-            -- end up trying to link object code to byte code.
-            target = if prevailing_target /= local_target
-                        && (not (isObjectTarget prevailing_target)
-                            || not (isObjectTarget local_target))
-                        then prevailing_target
-                        else local_target 
-
-            -- store the corrected hscTarget into the summary
-            summary' = summary{ ms_hspp_opts = dflags { hscTarget = target } }
-
-	    -- The old interface is ok if
-	    --	a) we're compiling a source file, and the old HPT
-	    --	   entry is for a source file
-	    --	b) we're compiling a hs-boot file
-	    -- Case (b) allows an hs-boot file to get the interface of its
-	    -- real source file on the second iteration of the compilation
-	    -- manager, but that does no harm.  Otherwise the hs-boot file
-	    -- will always be recompiled
-            
-            mb_old_iface 
-	    	= case old_hmi of
-	    	     Nothing	 			  -> Nothing
-	    	     Just hm_info | isBootSummary summary -> Just iface
-	    			  | not (mi_boot iface)   -> Just iface
-	    			  | otherwise		  -> Nothing
-	    			   where 
-	    			     iface = hm_iface hm_info
-
-	    compile_it :: Maybe Linkable -> IO HomeModInfo
-	    compile_it  mb_linkable = 
-                  compile hsc_env summary' mod_index nmods 
-                          mb_old_iface mb_linkable
-
-            compile_it_discard_iface :: Maybe Linkable -> IO HomeModInfo
-            compile_it_discard_iface mb_linkable =
-                  compile hsc_env summary' mod_index nmods
-                          Nothing mb_linkable
-
-            -- With the HscNothing target we create empty linkables to avoid
-            -- recompilation.  We have to detect these to recompile anyway if
-            -- the target changed since the last compile.
-            is_fake_linkable
-               | Just hmi <- old_hmi, Just l <- hm_linkable hmi =
-                  null (linkableUnlinked l)
-               | otherwise =
-                   -- we have no linkable, so it cannot be fake
-                   False
-
-            implies False _ = True
-            implies True x  = x
-
-        in
-        case () of
-         _
-                -- Regardless of whether we're generating object code or
-                -- byte code, we can always use an existing object file
-                -- if it is *stable* (see checkStability).
-          | is_stable_obj, Just hmi <- old_hmi -> do
-                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                           (text "skipping stable obj mod:" <+> ppr this_mod_name)
-                return hmi
-                -- object is stable, and we have an entry in the
-                -- old HPT: nothing to do
-
-          | is_stable_obj, isNothing old_hmi -> do
-                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                           (text "compiling stable on-disk mod:" <+> ppr this_mod_name)
-                linkable <- liftIO $ findObjectLinkable this_mod obj_fn
-                              (expectJust "upsweep1" mb_obj_date)
-                compile_it (Just linkable)
-                -- object is stable, but we need to load the interface
-                -- off disk to make a HMI.
-
-          | not (isObjectTarget target), is_stable_bco,
-            (target /= HscNothing) `implies` not is_fake_linkable ->
-                ASSERT(isJust old_hmi) -- must be in the old_hpt
-                let Just hmi = old_hmi in do
-                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                           (text "skipping stable BCO mod:" <+> ppr this_mod_name)
-                return hmi
-                -- BCO is stable: nothing to do
-
-          | not (isObjectTarget target),
-            Just hmi <- old_hmi,
-            Just l <- hm_linkable hmi,
-            not (isObjectLinkable l),
-            (target /= HscNothing) `implies` not is_fake_linkable,
-            linkableTime l >= ms_hs_date summary -> do
-                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                           (text "compiling non-stable BCO mod:" <+> ppr this_mod_name)
-                compile_it (Just l)
-                -- we have an old BCO that is up to date with respect
-                -- to the source: do a recompilation check as normal.
-
-          -- When generating object code, if there's an up-to-date
-          -- object file on the disk, then we can use it.
-          -- However, if the object file is new (compared to any
-          -- linkable we had from a previous compilation), then we
-          -- must discard any in-memory interface, because this
-          -- means the user has compiled the source file
-          -- separately and generated a new interface, that we must
-          -- read from the disk.
-          --
-          | isObjectTarget target,
-            Just obj_date <- mb_obj_date,
-            obj_date >= hs_date -> do
-                case old_hmi of
-                  Just hmi
-                    | Just l <- hm_linkable hmi,
-                      isObjectLinkable l && linkableTime l == obj_date -> do
-                          liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                                     (text "compiling mod with new on-disk obj:" <+> ppr this_mod_name)
-                          compile_it (Just l)
-                  _otherwise -> do
-                          liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                                     (text "compiling mod with new on-disk obj2:" <+> ppr this_mod_name)
-                          linkable <- liftIO $ findObjectLinkable this_mod obj_fn obj_date
-                          compile_it_discard_iface (Just linkable)
-
-         _otherwise -> do
-                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
-                           (text "compiling mod:" <+> ppr this_mod_name)
-                compile_it Nothing
-
-
-
--- Filter modules in the HPT
-retainInTopLevelEnvs :: [ModuleName] -> HomePackageTable -> HomePackageTable
-retainInTopLevelEnvs keep_these hpt
-   = listToUFM   [ (mod, expectJust "retain" mb_mod_info)
-		 | mod <- keep_these
-		 , let mb_mod_info = lookupUFM hpt mod
-		 , isJust mb_mod_info ]
-
--- ---------------------------------------------------------------------------
--- Typecheck module loops
-
-{-
-See bug #930.  This code fixes a long-standing bug in --make.  The
-problem is that when compiling the modules *inside* a loop, a data
-type that is only defined at the top of the loop looks opaque; but
-after the loop is done, the structure of the data type becomes
-apparent.
-
-The difficulty is then that two different bits of code have
-different notions of what the data type looks like.
-
-The idea is that after we compile a module which also has an .hs-boot
-file, we re-generate the ModDetails for each of the modules that
-depends on the .hs-boot file, so that everyone points to the proper
-TyCons, Ids etc. defined by the real module, not the boot module.
-Fortunately re-generating a ModDetails from a ModIface is easy: the
-function TcIface.typecheckIface does exactly that.
-
-Picking the modules to re-typecheck is slightly tricky.  Starting from
-the module graph consisting of the modules that have already been
-compiled, we reverse the edges (so they point from the imported module
-to the importing module), and depth-first-search from the .hs-boot
-node.  This gives us all the modules that depend transitively on the
-.hs-boot module, and those are exactly the modules that we need to
-re-typecheck.
-
-Following this fix, GHC can compile itself with --make -O2.
--}
-
-reTypecheckLoop :: HscEnv -> ModSummary -> ModuleGraph -> IO HscEnv
-reTypecheckLoop hsc_env ms graph
-  | not (isBootSummary ms) && 
-    any (\m -> ms_mod m == this_mod && isBootSummary m) graph
-  = do
-        let mss = reachableBackwards (ms_mod_name ms) graph
-            non_boot = filter (not.isBootSummary) mss
-        debugTraceMsg (hsc_dflags hsc_env) 2 $
-           text "Re-typechecking loop: " <> ppr (map ms_mod_name non_boot)
-        typecheckLoop hsc_env (map ms_mod_name non_boot)
-  | otherwise
-  = return hsc_env
- where
-  this_mod = ms_mod ms
-
-typecheckLoop :: HscEnv -> [ModuleName] -> IO HscEnv
-typecheckLoop hsc_env mods = do
-  new_hpt <-
-    fixIO $ \new_hpt -> do
-      let new_hsc_env = hsc_env{ hsc_HPT = new_hpt }
-      mds <- initIfaceCheck new_hsc_env $ 
-                mapM (typecheckIface . hm_iface) hmis
-      let new_hpt = addListToUFM old_hpt 
-                        (zip mods [ hmi{ hm_details = details }
-                                  | (hmi,details) <- zip hmis mds ])
-      return new_hpt
-  return hsc_env{ hsc_HPT = new_hpt }
-  where
-    old_hpt = hsc_HPT hsc_env
-    hmis    = map (expectJust "typecheckLoop" . lookupUFM old_hpt) mods
-
-reachableBackwards :: ModuleName -> [ModSummary] -> [ModSummary]
-reachableBackwards mod summaries
-  = [ ms | (ms,_,_) <- reachableG (transposeG graph) root ]
-  where -- the rest just sets up the graph:
-        (graph, lookup_node) = moduleGraphNodes False summaries
-        root  = expectJust "reachableBackwards" (lookup_node HsBootFile mod)
-
--- ---------------------------------------------------------------------------
--- Topological sort of the module graph
-
-type SummaryNode = (ModSummary, Int, [Int])
-
-topSortModuleGraph
-	  :: Bool
-          -- ^ Drop hi-boot nodes? (see below)
-	  -> [ModSummary]
-	  -> Maybe ModuleName
-             -- ^ Root module name.  If @Nothing@, use the full graph.
-	  -> [SCC ModSummary]
--- ^ Calculate SCCs of the module graph, possibly dropping the hi-boot nodes
--- The resulting list of strongly-connected-components is in topologically
--- sorted order, starting with the module(s) at the bottom of the
--- dependency graph (ie compile them first) and ending with the ones at
--- the top.
---
--- Drop hi-boot nodes (first boolean arg)? 
---
--- - @False@:	treat the hi-boot summaries as nodes of the graph,
---		so the graph must be acyclic
---
--- - @True@:	eliminate the hi-boot nodes, and instead pretend
---		the a source-import of Foo is an import of Foo
---		The resulting graph has no hi-boot nodes, but can be cyclic
-
-topSortModuleGraph drop_hs_boot_nodes summaries mb_root_mod
-  = map (fmap summaryNodeSummary) $ stronglyConnCompG initial_graph
-  where
-    (graph, lookup_node) = moduleGraphNodes drop_hs_boot_nodes summaries
-    
-    initial_graph = case mb_root_mod of
-        Nothing -> graph
-        Just root_mod ->
-            -- restrict the graph to just those modules reachable from
-            -- the specified module.  We do this by building a graph with
-            -- the full set of nodes, and determining the reachable set from
-            -- the specified node.
-            let root | Just node <- lookup_node HsSrcFile root_mod, graph `hasVertexG` node = node
-                     | otherwise = ghcError (ProgramError "module does not exist")
-            in graphFromEdgedVertices (seq root (reachableG graph root))
-
-summaryNodeKey :: SummaryNode -> Int
-summaryNodeKey (_, k, _) = k
-
-summaryNodeSummary :: SummaryNode -> ModSummary
-summaryNodeSummary (s, _, _) = s
-
-moduleGraphNodes :: Bool -> [ModSummary]
-  -> (Graph SummaryNode, HscSource -> ModuleName -> Maybe SummaryNode)
-moduleGraphNodes drop_hs_boot_nodes summaries = (graphFromEdgedVertices nodes, lookup_node)
-  where
-    numbered_summaries = zip summaries [1..]
-
-    lookup_node :: HscSource -> ModuleName -> Maybe SummaryNode
-    lookup_node hs_src mod = Map.lookup (mod, hs_src) node_map
-
-    lookup_key :: HscSource -> ModuleName -> Maybe Int
-    lookup_key hs_src mod = fmap summaryNodeKey (lookup_node hs_src mod)
-
-    node_map :: NodeMap SummaryNode
-    node_map = Map.fromList [ ((moduleName (ms_mod s), ms_hsc_src s), node)
-                            | node@(s, _, _) <- nodes ]
-
-    -- We use integers as the keys for the SCC algorithm
-    nodes :: [SummaryNode]
-    nodes = [ (s, key, out_keys)
-            | (s, key) <- numbered_summaries
-             -- Drop the hi-boot ones if told to do so
-            , not (isBootSummary s && drop_hs_boot_nodes)
-            , let out_keys = out_edge_keys hs_boot_key (map unLoc (ms_home_srcimps s)) ++
-                             out_edge_keys HsSrcFile   (map unLoc (ms_home_imps s)) ++
-                             (-- see [boot-edges] below
-                              if drop_hs_boot_nodes || ms_hsc_src s == HsBootFile 
-                              then [] 
-                              else case lookup_key HsBootFile (ms_mod_name s) of
-                                    Nothing -> []
-                                    Just k  -> [k]) ]
-
-    -- [boot-edges] if this is a .hs and there is an equivalent
-    -- .hs-boot, add a link from the former to the latter.  This
-    -- has the effect of detecting bogus cases where the .hs-boot
-    -- depends on the .hs, by introducing a cycle.  Additionally,
-    -- it ensures that we will always process the .hs-boot before
-    -- the .hs, and so the HomePackageTable will always have the
-    -- most up to date information.
-
-    -- Drop hs-boot nodes by using HsSrcFile as the key
-    hs_boot_key | drop_hs_boot_nodes = HsSrcFile
-                | otherwise          = HsBootFile
-
-    out_edge_keys :: HscSource -> [ModuleName] -> [Int]
-    out_edge_keys hi_boot ms = mapCatMaybes (lookup_key hi_boot) ms
-        -- If we want keep_hi_boot_nodes, then we do lookup_key with
-        -- the IsBootInterface parameter True; else False
-
-
-type NodeKey   = (ModuleName, HscSource)  -- The nodes of the graph are 
-type NodeMap a = Map.Map NodeKey a	  -- keyed by (mod, src_file_type) pairs
-
-msKey :: ModSummary -> NodeKey
-msKey (ModSummary { ms_mod = mod, ms_hsc_src = boot }) = (moduleName mod,boot)
-
-mkNodeMap :: [ModSummary] -> NodeMap ModSummary
-mkNodeMap summaries = Map.fromList [ (msKey s, s) | s <- summaries]
-	
-nodeMapElts :: NodeMap a -> [a]
-nodeMapElts = Map.elems
-
--- | If there are {-# SOURCE #-} imports between strongly connected
--- components in the topological sort, then those imports can
--- definitely be replaced by ordinary non-SOURCE imports: if SOURCE
--- were necessary, then the edge would be part of a cycle.
-warnUnnecessarySourceImports :: GhcMonad m => [SCC ModSummary] -> m ()
-warnUnnecessarySourceImports sccs = do
-  logWarnings (listToBag (concatMap (check.flattenSCC) sccs))
-  where check ms =
-	   let mods_in_this_cycle = map ms_mod_name ms in
-	   [ warn i | m <- ms, i <- ms_home_srcimps m,
-	              unLoc i `notElem`  mods_in_this_cycle ]
-
-	warn :: Located ModuleName -> WarnMsg
-	warn (L loc mod) = 
-	   mkPlainErrMsg loc
-		(ptext (sLit "Warning: {-# SOURCE #-} unnecessary in import of ")
-		 <+> quotes (ppr mod))
-
------------------------------------------------------------------------------
--- Downsweep (dependency analysis)
-
--- Chase downwards from the specified root set, returning summaries
--- for all home modules encountered.  Only follow source-import
--- links.
-
--- We pass in the previous collection of summaries, which is used as a
--- cache to avoid recalculating a module summary if the source is
--- unchanged.
---
--- The returned list of [ModSummary] nodes has one node for each home-package
--- module, plus one for any hs-boot files.  The imports of these nodes 
--- are all there, including the imports of non-home-package modules.
-
-downsweep :: HscEnv
-	  -> [ModSummary]	-- Old summaries
-	  -> [ModuleName]	-- Ignore dependencies on these; treat
-				-- them as if they were package modules
-	  -> Bool		-- True <=> allow multiple targets to have 
-				-- 	    the same module name; this is 
-				--	    very useful for ghc -M
-	  -> IO [ModSummary]
-		-- The elts of [ModSummary] all have distinct
-		-- (Modules, IsBoot) identifiers, unless the Bool is true
-		-- in which case there can be repeats
-downsweep hsc_env old_summaries excl_mods allow_dup_roots
-   = do
-       rootSummaries <- mapM getRootSummary roots
-       let root_map = mkRootMap rootSummaries
-       checkDuplicates root_map
-       summs <- loop (concatMap msDeps rootSummaries) root_map
-       return summs
-     where
-	roots = hsc_targets hsc_env
-
-	old_summary_map :: NodeMap ModSummary
-	old_summary_map = mkNodeMap old_summaries
-
-	getRootSummary :: Target -> IO ModSummary
-	getRootSummary (Target (TargetFile file mb_phase) obj_allowed maybe_buf)
-	   = do exists <- liftIO $ doesFileExist file
-		if exists 
-		    then summariseFile hsc_env old_summaries file mb_phase 
-                                       obj_allowed maybe_buf
-		    else throwOneError $ mkPlainErrMsg noSrcSpan $
-			   text "can't find file:" <+> text file
-	getRootSummary (Target (TargetModule modl) obj_allowed maybe_buf)
- 	   = do maybe_summary <- summariseModule hsc_env old_summary_map False 
-					   (L rootLoc modl) obj_allowed 
-                                           maybe_buf excl_mods
-		case maybe_summary of
-		   Nothing -> packageModErr modl
-		   Just s  -> return s
-
-	rootLoc = mkGeneralSrcSpan (fsLit "<command line>")
-
-	-- In a root module, the filename is allowed to diverge from the module
-	-- name, so we have to check that there aren't multiple root files
-	-- defining the same module (otherwise the duplicates will be silently
- 	-- ignored, leading to confusing behaviour).
-	checkDuplicates :: NodeMap [ModSummary] -> IO ()
-	checkDuplicates root_map 
-	   | allow_dup_roots = return ()
-	   | null dup_roots  = return ()
-	   | otherwise	     = liftIO $ multiRootsErr (head dup_roots)
-	   where
-	     dup_roots :: [[ModSummary]]	-- Each at least of length 2
-	     dup_roots = filterOut isSingleton (nodeMapElts root_map)
-
-	loop :: [(Located ModuleName,IsBootInterface)]
-			-- Work list: process these modules
-	     -> NodeMap [ModSummary]
-		 	-- Visited set; the range is a list because
-			-- the roots can have the same module names
-			-- if allow_dup_roots is True
-	     -> IO [ModSummary]
-			-- The result includes the worklist, except
-			-- for those mentioned in the visited set
-	loop [] done 	  = return (concat (nodeMapElts done))
-	loop ((wanted_mod, is_boot) : ss) done 
-	  | Just summs <- Map.lookup key done
-	  = if isSingleton summs then
-		loop ss done
-	    else
-		do { multiRootsErr summs; return [] }
-	  | otherwise
-          = do mb_s <- summariseModule hsc_env old_summary_map 
-                                       is_boot wanted_mod True
-                                       Nothing excl_mods
-               case mb_s of
-                   Nothing -> loop ss done
-                   Just s  -> loop (msDeps s ++ ss) (Map.insert key [s] done)
-	  where
-	    key = (unLoc wanted_mod, if is_boot then HsBootFile else HsSrcFile)
-
--- XXX Does the (++) here need to be flipped?
-mkRootMap :: [ModSummary] -> NodeMap [ModSummary]
-mkRootMap summaries = Map.insertListWith (flip (++))
-                                         [ (msKey s, [s]) | s <- summaries ]
-                                         Map.empty
-
-msDeps :: ModSummary -> [(Located ModuleName, IsBootInterface)]
--- (msDeps s) returns the dependencies of the ModSummary s.
--- A wrinkle is that for a {-# SOURCE #-} import we return
---	*both* the hs-boot file
---	*and* the source file
--- as "dependencies".  That ensures that the list of all relevant
--- modules always contains B.hs if it contains B.hs-boot.
--- Remember, this pass isn't doing the topological sort.  It's
--- just gathering the list of all relevant ModSummaries
-msDeps s = 
-    concat [ [(m,True), (m,False)] | m <- ms_home_srcimps s ] 
-	 ++ [ (m,False) | m <- ms_home_imps s ] 
-
-home_imps :: [Located (ImportDecl RdrName)] -> [Located ModuleName]
-home_imps imps = [ ideclName i |  L _ i <- imps, isLocal (ideclPkgQual i) ]
-  where isLocal Nothing = True
-        isLocal (Just pkg) | pkg == fsLit "this" = True -- "this" is special
-        isLocal _ = False
-
-ms_home_allimps :: ModSummary -> [ModuleName]
-ms_home_allimps ms = map unLoc (ms_home_srcimps ms ++ ms_home_imps ms)
-
-ms_home_srcimps :: ModSummary -> [Located ModuleName]
-ms_home_srcimps = home_imps . ms_srcimps
-
-ms_home_imps :: ModSummary -> [Located ModuleName]
-ms_home_imps = home_imps . ms_imps
-
------------------------------------------------------------------------------
--- Summarising modules
-
--- We have two types of summarisation:
---
---    * Summarise a file.  This is used for the root module(s) passed to
---	cmLoadModules.  The file is read, and used to determine the root
---	module name.  The module name may differ from the filename.
---
---    * Summarise a module.  We are given a module name, and must provide
---	a summary.  The finder is used to locate the file in which the module
---	resides.
-
-summariseFile
-	:: HscEnv
-	-> [ModSummary]			-- old summaries
-	-> FilePath			-- source file name
-	-> Maybe Phase			-- start phase
-        -> Bool                         -- object code allowed?
-	-> Maybe (StringBuffer,ClockTime)
-	-> IO ModSummary
-
-summariseFile hsc_env old_summaries file mb_phase obj_allowed maybe_buf
-	-- we can use a cached summary if one is available and the
-	-- source file hasn't changed,  But we have to look up the summary
-	-- by source file, rather than module name as we do in summarise.
-   | Just old_summary <- findSummaryBySourceFile old_summaries file
-   = do
-	let location = ms_location old_summary
-
-		-- return the cached summary if the source didn't change
-	src_timestamp <- case maybe_buf of
-			   Just (_,t) -> return t
-			   Nothing    -> liftIO $ getModificationTime file
-		-- The file exists; we checked in getRootSummary above.
-		-- If it gets removed subsequently, then this 
-		-- getModificationTime may fail, but that's the right
-		-- behaviour.
-
-	if ms_hs_date old_summary == src_timestamp 
-	   then do -- update the object-file timestamp
-        	  obj_timestamp <-
-                    if isObjectTarget (hscTarget (hsc_dflags hsc_env)) 
-                        || obj_allowed -- bug #1205
-                        then liftIO $ getObjTimestamp location False
-                        else return Nothing
-		  return old_summary{ ms_obj_date = obj_timestamp }
-	   else
-		new_summary
-
-   | otherwise
-   = new_summary
-  where
-    new_summary = do
-   	let dflags = hsc_dflags hsc_env
-
-	(dflags', hspp_fn, buf)
-	    <- preprocessFile hsc_env file mb_phase maybe_buf
-
-        (srcimps,the_imps, L _ mod_name) <- getImports dflags' buf hspp_fn file
-
-	-- Make a ModLocation for this file
-	location <- liftIO $ mkHomeModLocation dflags mod_name file
-
-	-- Tell the Finder cache where it is, so that subsequent calls
-	-- to findModule will find it, even if it's not on any search path
-	mod <- liftIO $ addHomeModuleToFinder hsc_env mod_name location
-
-        src_timestamp <- case maybe_buf of
-			   Just (_,t) -> return t
-			   Nothing    -> liftIO $ getModificationTime file
-			-- getMofificationTime may fail
-
-        -- when the user asks to load a source file by name, we only
-        -- use an object file if -fobject-code is on.  See #1205.
-	obj_timestamp <-
-            if isObjectTarget (hscTarget (hsc_dflags hsc_env)) 
-               || obj_allowed -- bug #1205
-                then liftIO $ modificationTimeIfExists (ml_obj_file location)
-                else return Nothing
-
-        return (ModSummary { ms_mod = mod, ms_hsc_src = HsSrcFile,
-			     ms_location = location,
-                             ms_hspp_file = hspp_fn,
-                             ms_hspp_opts = dflags',
-			     ms_hspp_buf  = Just buf,
-                             ms_srcimps = srcimps, ms_imps = the_imps,
-			     ms_hs_date = src_timestamp,
-			     ms_obj_date = obj_timestamp })
-
-findSummaryBySourceFile :: [ModSummary] -> FilePath -> Maybe ModSummary
-findSummaryBySourceFile summaries file
-  = case [ ms | ms <- summaries, HsSrcFile <- [ms_hsc_src ms],
-			         expectJust "findSummaryBySourceFile" (ml_hs_file (ms_location ms)) == file ] of
-	[] -> Nothing
-	(x:_) -> Just x
-
--- Summarise a module, and pick up source and timestamp.
-summariseModule
-	  :: HscEnv
-	  -> NodeMap ModSummary	-- Map of old summaries
-	  -> IsBootInterface	-- True <=> a {-# SOURCE #-} import
-	  -> Located ModuleName	-- Imported module to be summarised
-          -> Bool               -- object code allowed?
-	  -> Maybe (StringBuffer, ClockTime)
-	  -> [ModuleName]		-- Modules to exclude
-	  -> IO (Maybe ModSummary)	-- Its new summary
-
-summariseModule hsc_env old_summary_map is_boot (L loc wanted_mod) 
-                obj_allowed maybe_buf excl_mods
-  | wanted_mod `elem` excl_mods
-  = return Nothing
-
-  | Just old_summary <- Map.lookup (wanted_mod, hsc_src) old_summary_map
-  = do	 	-- Find its new timestamp; all the 
-		-- ModSummaries in the old map have valid ml_hs_files
-	let location = ms_location old_summary
-	    src_fn = expectJust "summariseModule" (ml_hs_file location)
-
-		-- check the modification time on the source file, and
-		-- return the cached summary if it hasn't changed.  If the
-		-- file has disappeared, we need to call the Finder again.
-	case maybe_buf of
-	   Just (_,t) -> check_timestamp old_summary location src_fn t
-	   Nothing    -> do
-		m <- tryIO (getModificationTime src_fn)
-		case m of
-		   Right t -> check_timestamp old_summary location src_fn t
-		   Left e | isDoesNotExistError e -> find_it
-		          | otherwise             -> ioError e
-
-  | otherwise  = find_it
-  where
-    dflags = hsc_dflags hsc_env
-
-    hsc_src = if is_boot then HsBootFile else HsSrcFile
-
-    check_timestamp old_summary location src_fn src_timestamp
-	| ms_hs_date old_summary == src_timestamp = do
-		-- update the object-file timestamp
-                obj_timestamp <- 
-                    if isObjectTarget (hscTarget (hsc_dflags hsc_env))
-                       || obj_allowed -- bug #1205
-                       then getObjTimestamp location is_boot
-                       else return Nothing
-		return (Just old_summary{ ms_obj_date = obj_timestamp })
-	| otherwise = 
-		-- source changed: re-summarise.
-		new_summary location (ms_mod old_summary) src_fn src_timestamp
-
-    find_it = do
-	-- Don't use the Finder's cache this time.  If the module was
-	-- previously a package module, it may have now appeared on the
-	-- search path, so we want to consider it to be a home module.  If
-	-- the module was previously a home module, it may have moved.
-	uncacheModule hsc_env wanted_mod
-	found <- findImportedModule hsc_env wanted_mod Nothing
-	case found of
-	     Found location mod 
-		| isJust (ml_hs_file location) ->
-			-- Home package
-			 just_found location mod
-		| otherwise -> 
-			-- Drop external-pkg
-			ASSERT(modulePackageId mod /= thisPackage dflags)
-			return Nothing
-			
-	     err -> noModError dflags loc wanted_mod err
-			-- Not found
-
-    just_found location mod = do
-	  	-- Adjust location to point to the hs-boot source file, 
-		-- hi file, object file, when is_boot says so
-	let location' | is_boot   = addBootSuffixLocn location
-		      | otherwise = location
-	    src_fn = expectJust "summarise2" (ml_hs_file location')
-
-		-- Check that it exists
-	  	-- It might have been deleted since the Finder last found it
-	maybe_t <- modificationTimeIfExists src_fn
-	case maybe_t of
-	  Nothing -> noHsFileErr loc src_fn
-	  Just t  -> new_summary location' mod src_fn t
-
-
-    new_summary location mod src_fn src_timestamp
-      = do
-	-- Preprocess the source file and get its imports
-	-- The dflags' contains the OPTIONS pragmas
-	(dflags', hspp_fn, buf) <- preprocessFile hsc_env src_fn Nothing maybe_buf
-        (srcimps, the_imps, L mod_loc mod_name) <- getImports dflags' buf hspp_fn src_fn
-
-	when (mod_name /= wanted_mod) $
-		throwOneError $ mkPlainErrMsg mod_loc $ 
-			      text "File name does not match module name:" 
-			      $$ text "Saw:" <+> quotes (ppr mod_name)
-                              $$ text "Expected:" <+> quotes (ppr wanted_mod)
-
-		-- Find the object timestamp, and return the summary
-	obj_timestamp <-
-           if isObjectTarget (hscTarget (hsc_dflags hsc_env))
-              || obj_allowed -- bug #1205
-              then getObjTimestamp location is_boot
-              else return Nothing
-
-	return (Just (ModSummary { ms_mod       = mod,
-			      ms_hsc_src   = hsc_src,
-			      ms_location  = location,
-			      ms_hspp_file = hspp_fn,
-                              ms_hspp_opts = dflags',
-			      ms_hspp_buf  = Just buf,
-			      ms_srcimps   = srcimps,
-			      ms_imps      = the_imps,
-			      ms_hs_date   = src_timestamp,
-			      ms_obj_date  = obj_timestamp }))
-
-
-getObjTimestamp :: ModLocation -> Bool -> IO (Maybe ClockTime)
-getObjTimestamp location is_boot
-  = if is_boot then return Nothing
-	       else modificationTimeIfExists (ml_obj_file location)
-
-
-preprocessFile :: HscEnv
-               -> FilePath
-               -> Maybe Phase -- ^ Starting phase
-               -> Maybe (StringBuffer,ClockTime)
-               -> IO (DynFlags, FilePath, StringBuffer)
-preprocessFile hsc_env src_fn mb_phase Nothing
-  = do
-	(dflags', hspp_fn) <- preprocess hsc_env (src_fn, mb_phase)
-	buf <- hGetStringBuffer hspp_fn
-	return (dflags', hspp_fn, buf)
-
-preprocessFile hsc_env src_fn mb_phase (Just (buf, _time))
-  = do
-        let dflags = hsc_dflags hsc_env
-	-- case we bypass the preprocessing stage?
-	let local_opts = getOptions dflags buf src_fn
-	
-	(dflags', leftovers, warns)
-            <- parseDynamicNoPackageFlags dflags local_opts
-        checkProcessArgsResult leftovers
-        handleFlagWarnings dflags' warns
-
-	let
-	    needs_preprocessing
-		| Just (Unlit _) <- mb_phase    = True
-	        | Nothing <- mb_phase, Unlit _ <- startPhase src_fn  = True
-		  -- note: local_opts is only required if there's no Unlit phase
-		| xopt Opt_Cpp dflags'		= True
-		| dopt Opt_Pp  dflags'		= True
-		| otherwise			= False
-
-	when needs_preprocessing $
-	   ghcError (ProgramError "buffer needs preprocesing; interactive check disabled")
-
-	return (dflags', src_fn, buf)
-
-
------------------------------------------------------------------------------
--- 			Error messages
------------------------------------------------------------------------------
-
-noModError :: DynFlags -> SrcSpan -> ModuleName -> FindResult -> IO ab
--- ToDo: we don't have a proper line number for this error
-noModError dflags loc wanted_mod err
-  = throwOneError $ mkPlainErrMsg loc $ cannotFindModule dflags wanted_mod err
-				
-noHsFileErr :: SrcSpan -> String -> IO a
-noHsFileErr loc path
-  = throwOneError $ mkPlainErrMsg loc $ text "Can't find" <+> text path
- 
-packageModErr :: ModuleName -> IO a
-packageModErr mod
-  = throwOneError $ mkPlainErrMsg noSrcSpan $
-	text "module" <+> quotes (ppr mod) <+> text "is a package module"
-
-multiRootsErr :: [ModSummary] -> IO ()
-multiRootsErr [] = panic "multiRootsErr"
-multiRootsErr summs@(summ1:_)
-  = throwOneError $ mkPlainErrMsg noSrcSpan $
-	text "module" <+> quotes (ppr mod) <+> 
-	text "is defined in multiple files:" <+>
-	sep (map text files)
-  where
-    mod = ms_mod summ1
-    files = map (expectJust "checkDup" . ml_hs_file . ms_location) summs
-
-cyclicModuleErr :: [ModSummary] -> SDoc
-cyclicModuleErr ms
-  = hang (ptext (sLit "Module imports form a cycle for modules:"))
-       2 (vcat (map show_one ms))
-  where
-    mods_in_cycle = map ms_mod_name ms
-    imp_modname = unLoc . ideclName . unLoc
-    just_in_cycle = filter ((`elem` mods_in_cycle) . imp_modname)
-
-    show_one ms = 
-           vcat [ show_mod (ms_hsc_src ms) (ms_mod_name ms) <+>
-                  maybe empty (parens . text) (ml_hs_file (ms_location ms)),
-                  nest 2 $ ptext (sLit "imports:") <+> vcat [
-                     pp_imps HsBootFile (just_in_cycle $ ms_srcimps ms),
-                     pp_imps HsSrcFile  (just_in_cycle $ ms_imps ms) ]
-                ]
-    show_mod hsc_src mod = ppr mod <> text (hscSourceString hsc_src)
-    pp_imps src imps = fsep (map (show_mod src . unLoc . ideclName . unLoc) imps)
+-- -----------------------------------------------------------------------------
+--
+-- (c) The University of Glasgow, 2005
+--
+--       This module deals with --make
+-- -----------------------------------------------------------------------------
+
+module GhcMake(
+  depanal,
+  load, LoadHowMuch(..),
+
+  topSortModuleGraph,
+
+  noModError, cyclicModuleErr
+  ) where
+
+#include "HsVersions.h"
+
+#ifdef GHCI
+import qualified Linker		( unload )
+#endif
+
+import DriverPipeline
+import DriverPhases
+import GhcMonad
+import Module
+import HscTypes
+import ErrUtils
+import DynFlags
+import HsSyn hiding ((<.>))
+import Finder
+import HeaderInfo
+import TcIface		( typecheckIface )
+import TcRnMonad	( initIfaceCheck )
+import RdrName		( RdrName )
+
+import Exception	( evaluate, tryIO )
+import Panic
+import SysTools
+import BasicTypes
+import SrcLoc
+import Util
+import Digraph
+import Bag		( listToBag )
+import Maybes		( expectJust, mapCatMaybes )
+import StringBuffer
+import FastString
+import Outputable
+import UniqFM
+
+import qualified Data.Map as Map
+import qualified FiniteMap as Map( insertListWith)
+
+import System.Directory ( doesFileExist, getModificationTime )
+import System.IO	( fixIO )
+import System.IO.Error	( isDoesNotExistError )
+import System.Time	( ClockTime )
+import System.FilePath
+import Control.Monad
+import Data.Maybe
+import Data.List
+import qualified Data.List as List
+
+-- -----------------------------------------------------------------------------
+-- Loading the program
+
+-- | Perform a dependency analysis starting from the current targets
+-- and update the session with the new module graph.
+--
+-- Dependency analysis entails parsing the @import@ directives and may
+-- therefore require running certain preprocessors.
+--
+-- Note that each 'ModSummary' in the module graph caches its 'DynFlags'.
+-- These 'DynFlags' are determined by the /current/ session 'DynFlags' and the
+-- @OPTIONS@ and @LANGUAGE@ pragmas of the parsed module.  Thus if you want to
+-- changes to the 'DynFlags' to take effect you need to call this function
+-- again.
+--
+depanal :: GhcMonad m =>
+           [ModuleName]  -- ^ excluded modules
+        -> Bool          -- ^ allow duplicate roots
+        -> m ModuleGraph
+depanal excluded_mods allow_dup_roots = do
+  hsc_env <- getSession
+  let
+	 dflags  = hsc_dflags hsc_env
+	 targets = hsc_targets hsc_env
+	 old_graph = hsc_mod_graph hsc_env
+
+  liftIO $ showPass dflags "Chasing dependencies"
+  liftIO $ debugTraceMsg dflags 2 (hcat [
+	     text "Chasing modules from: ",
+	     hcat (punctuate comma (map pprTarget targets))])
+
+  mod_graph <- liftIO $ downsweep hsc_env old_graph excluded_mods allow_dup_roots
+  modifySession $ \_ -> hsc_env { hsc_mod_graph = mod_graph }
+  return mod_graph
+
+-- | Describes which modules of the module graph need to be loaded.
+data LoadHowMuch
+   = LoadAllTargets
+     -- ^ Load all targets and its dependencies.
+   | LoadUpTo ModuleName
+     -- ^ Load only the given module and its dependencies.
+   | LoadDependenciesOf ModuleName
+     -- ^ Load only the dependencies of the given module, but not the module
+     -- itself.
+
+-- | Try to load the program.  See 'LoadHowMuch' for the different modes.
+--
+-- This function implements the core of GHC's @--make@ mode.  It preprocesses,
+-- compiles and loads the specified modules, avoiding re-compilation wherever
+-- possible.  Depending on the target (see 'DynFlags.hscTarget') compilating
+-- and loading may result in files being created on disk.
+--
+-- Calls the 'reportModuleCompilationResult' callback after each compiling
+-- each module, whether successful or not.
+--
+-- Throw a 'SourceError' if errors are encountered before the actual
+-- compilation starts (e.g., during dependency analysis).  All other errors
+-- are reported using the callback.
+--
+load :: GhcMonad m => LoadHowMuch -> m SuccessFlag
+load how_much = do
+   mod_graph <- depanal [] False
+   load2 how_much mod_graph
+
+load2 :: GhcMonad m => LoadHowMuch -> [ModSummary]
+      -> m SuccessFlag
+load2 how_much mod_graph = do
+        guessOutputFile
+	hsc_env <- getSession
+
+        let hpt1      = hsc_HPT hsc_env
+        let dflags    = hsc_dflags hsc_env
+
+	-- The "bad" boot modules are the ones for which we have
+	-- B.hs-boot in the module graph, but no B.hs
+	-- The downsweep should have ensured this does not happen
+	-- (see msDeps)
+        let all_home_mods = [ms_mod_name s
+			    | s <- mod_graph, not (isBootSummary s)]
+	    bad_boot_mods = [s 	      | s <- mod_graph, isBootSummary s,
+					not (ms_mod_name s `elem` all_home_mods)]
+	ASSERT( null bad_boot_mods ) return ()
+
+        -- check that the module given in HowMuch actually exists, otherwise
+        -- topSortModuleGraph will bomb later.
+        let checkHowMuch (LoadUpTo m)           = checkMod m
+            checkHowMuch (LoadDependenciesOf m) = checkMod m
+            checkHowMuch _ = id
+
+            checkMod m and_then
+                | m `elem` all_home_mods = and_then
+                | otherwise = do
+                        liftIO $ errorMsg dflags (text "no such module:" <+>
+                                         quotes (ppr m))
+                        return Failed
+
+        checkHowMuch how_much $ do
+
+        -- mg2_with_srcimps drops the hi-boot nodes, returning a
+	-- graph with cycles.  Among other things, it is used for
+        -- backing out partially complete cycles following a failed
+        -- upsweep, and for removing from hpt all the modules
+        -- not in strict downwards closure, during calls to compile.
+        let mg2_with_srcimps :: [SCC ModSummary]
+	    mg2_with_srcimps = topSortModuleGraph True mod_graph Nothing
+
+	-- If we can determine that any of the {-# SOURCE #-} imports
+	-- are definitely unnecessary, then emit a warning.
+	warnUnnecessarySourceImports mg2_with_srcimps
+
+ 	let
+	    -- check the stability property for each module.
+	    stable_mods@(stable_obj,stable_bco)
+	        = checkStability hpt1 mg2_with_srcimps all_home_mods
+
+	    -- prune bits of the HPT which are definitely redundant now,
+	    -- to save space.
+	    pruned_hpt = pruneHomePackageTable hpt1
+				(flattenSCCs mg2_with_srcimps)
+				stable_mods
+
+	_ <- liftIO $ evaluate pruned_hpt
+
+        -- before we unload anything, make sure we don't leave an old
+        -- interactive context around pointing to dead bindings.  Also,
+        -- write the pruned HPT to allow the old HPT to be GC'd.
+        modifySession $ \_ -> hsc_env{ hsc_IC = emptyInteractiveContext,
+                                       hsc_HPT = pruned_hpt }
+
+	liftIO $ debugTraceMsg dflags 2 (text "Stable obj:" <+> ppr stable_obj $$
+				text "Stable BCO:" <+> ppr stable_bco)
+
+	-- Unload any modules which are going to be re-linked this time around.
+	let stable_linkables = [ linkable
+			       | m <- stable_obj++stable_bco,
+				 Just hmi <- [lookupUFM pruned_hpt m],
+				 Just linkable <- [hm_linkable hmi] ]
+	liftIO $ unload hsc_env stable_linkables
+
+        -- We could at this point detect cycles which aren't broken by
+        -- a source-import, and complain immediately, but it seems better
+        -- to let upsweep_mods do this, so at least some useful work gets
+        -- done before the upsweep is abandoned.
+        --hPutStrLn stderr "after tsort:\n"
+        --hPutStrLn stderr (showSDoc (vcat (map ppr mg2)))
+
+        -- Now do the upsweep, calling compile for each module in
+        -- turn.  Final result is version 3 of everything.
+
+        -- Topologically sort the module graph, this time including hi-boot
+	-- nodes, and possibly just including the portion of the graph
+	-- reachable from the module specified in the 2nd argument to load.
+	-- This graph should be cycle-free.
+	-- If we're restricting the upsweep to a portion of the graph, we
+	-- also want to retain everything that is still stable.
+        let full_mg :: [SCC ModSummary]
+	    full_mg    = topSortModuleGraph False mod_graph Nothing
+
+	    maybe_top_mod = case how_much of
+				LoadUpTo m           -> Just m
+			  	LoadDependenciesOf m -> Just m
+			  	_		     -> Nothing
+
+	    partial_mg0 :: [SCC ModSummary]
+	    partial_mg0 = topSortModuleGraph False mod_graph maybe_top_mod
+
+	    -- LoadDependenciesOf m: we want the upsweep to stop just
+	    -- short of the specified module (unless the specified module
+	    -- is stable).
+	    partial_mg
+		| LoadDependenciesOf _mod <- how_much
+		= ASSERT( case last partial_mg0 of
+			    AcyclicSCC ms -> ms_mod_name ms == _mod; _ -> False )
+		  List.init partial_mg0
+		| otherwise
+		= partial_mg0
+
+	    stable_mg =
+		[ AcyclicSCC ms
+	        | AcyclicSCC ms <- full_mg,
+		  ms_mod_name ms `elem` stable_obj++stable_bco,
+		  ms_mod_name ms `notElem` [ ms_mod_name ms' |
+						AcyclicSCC ms' <- partial_mg ] ]
+
+	    mg = stable_mg ++ partial_mg
+
+	-- clean up between compilations
+	let cleanup = cleanTempFilesExcept dflags
+			  (ppFilesFromSummaries (flattenSCCs mg2_with_srcimps))
+
+	liftIO $ debugTraceMsg dflags 2 (hang (text "Ready for upsweep")
+				   2 (ppr mg))
+
+        setSession hsc_env{ hsc_HPT = emptyHomePackageTable }
+        (upsweep_ok, modsUpswept)
+           <- upsweep pruned_hpt stable_mods cleanup mg
+
+	-- Make modsDone be the summaries for each home module now
+	-- available; this should equal the domain of hpt3.
+        -- Get in in a roughly top .. bottom order (hence reverse).
+
+        let modsDone = reverse modsUpswept
+
+        -- Try and do linking in some form, depending on whether the
+        -- upsweep was completely or only partially successful.
+
+        if succeeded upsweep_ok
+
+         then
+           -- Easy; just relink it all.
+           do liftIO $ debugTraceMsg dflags 2 (text "Upsweep completely successful.")
+
+	      -- Clean up after ourselves
+	      liftIO $ cleanTempFilesExcept dflags (ppFilesFromSummaries modsDone)
+
+	      -- Issue a warning for the confusing case where the user
+	      -- said '-o foo' but we're not going to do any linking.
+	      -- We attempt linking if either (a) one of the modules is
+	      -- called Main, or (b) the user said -no-hs-main, indicating
+	      -- that main() is going to come from somewhere else.
+	      --
+	      let ofile = outputFile dflags
+	      let no_hs_main = dopt Opt_NoHsMain dflags
+	      let
+	 	main_mod = mainModIs dflags
+		a_root_is_Main = any ((==main_mod).ms_mod) mod_graph
+		do_linking = a_root_is_Main || no_hs_main || ghcLink dflags == LinkDynLib
+
+	      when (ghcLink dflags == LinkBinary
+                    && isJust ofile && not do_linking) $
+	        liftIO $ debugTraceMsg dflags 1 $
+                    text ("Warning: output was redirected with -o, " ++
+                          "but no output will be generated\n" ++
+			  "because there is no " ++
+                          moduleNameString (moduleName main_mod) ++ " module.")
+
+	      -- link everything together
+              hsc_env1 <- getSession
+              linkresult <- liftIO $ link (ghcLink dflags) dflags do_linking (hsc_HPT hsc_env1)
+
+	      loadFinish Succeeded linkresult
+
+         else
+           -- Tricky.  We need to back out the effects of compiling any
+           -- half-done cycles, both so as to clean up the top level envs
+           -- and to avoid telling the interactive linker to link them.
+           do liftIO $ debugTraceMsg dflags 2 (text "Upsweep partially successful.")
+
+              let modsDone_names
+                     = map ms_mod modsDone
+              let mods_to_zap_names
+                     = findPartiallyCompletedCycles modsDone_names
+			  mg2_with_srcimps
+              let mods_to_keep
+                     = filter ((`notElem` mods_to_zap_names).ms_mod)
+			  modsDone
+
+              hsc_env1 <- getSession
+              let hpt4 = retainInTopLevelEnvs (map ms_mod_name mods_to_keep)
+					      (hsc_HPT hsc_env1)
+
+	      -- Clean up after ourselves
+	      liftIO $ cleanTempFilesExcept dflags (ppFilesFromSummaries mods_to_keep)
+
+	      -- there should be no Nothings where linkables should be, now
+	      ASSERT(all (isJust.hm_linkable)
+			(eltsUFM (hsc_HPT hsc_env))) do
+
+	      -- Link everything together
+              linkresult <- liftIO $ link (ghcLink dflags) dflags False hpt4
+
+              modifySession $ \hsc_env -> hsc_env{ hsc_HPT = hpt4 }
+	      loadFinish Failed linkresult
+
+-- Finish up after a load.
+
+-- If the link failed, unload everything and return.
+loadFinish :: GhcMonad m =>
+              SuccessFlag -> SuccessFlag
+           -> m SuccessFlag
+loadFinish _all_ok Failed
+  = do hsc_env <- getSession
+       liftIO $ unload hsc_env []
+       modifySession discardProg
+       return Failed
+
+-- Empty the interactive context and set the module context to the topmost
+-- newly loaded module, or the Prelude if none were loaded.
+loadFinish all_ok Succeeded
+  = do modifySession $ \hsc_env -> hsc_env{ hsc_IC = emptyInteractiveContext }
+       return all_ok
+
+
+-- Forget the current program, but retain the persistent info in HscEnv
+discardProg :: HscEnv -> HscEnv
+discardProg hsc_env
+  = hsc_env { hsc_mod_graph = emptyMG,
+	      hsc_IC = emptyInteractiveContext,
+	      hsc_HPT = emptyHomePackageTable }
+
+-- used to fish out the preprocess output files for the purposes of
+-- cleaning up.  The preprocessed file *might* be the same as the
+-- source file, but that doesn't do any harm.
+ppFilesFromSummaries :: [ModSummary] -> [FilePath]
+ppFilesFromSummaries summaries = map ms_hspp_file summaries
+
+-- | If there is no -o option, guess the name of target executable
+-- by using top-level source file name as a base.
+guessOutputFile :: GhcMonad m => m ()
+guessOutputFile = modifySession $ \env ->
+    let dflags = hsc_dflags env
+        mod_graph = hsc_mod_graph env
+        mainModuleSrcPath :: Maybe String
+        mainModuleSrcPath = do
+            let isMain = (== mainModIs dflags) . ms_mod
+            [ms] <- return (filter isMain mod_graph)
+            ml_hs_file (ms_location ms)
+        name = fmap dropExtension mainModuleSrcPath
+
+#if defined(mingw32_HOST_OS)
+        -- we must add the .exe extention unconditionally here, otherwise
+        -- when name has an extension of its own, the .exe extension will
+        -- not be added by DriverPipeline.exeFileName.  See #2248
+        name_exe = fmap (<.> "exe") name
+#else
+        name_exe = name
+#endif
+    in
+    case outputFile dflags of
+        Just _ -> env
+        Nothing -> env { hsc_dflags = dflags { outputFile = name_exe } }
+
+-- -----------------------------------------------------------------------------
+
+-- | Prune the HomePackageTable
+--
+-- Before doing an upsweep, we can throw away:
+--
+--   - For non-stable modules:
+--	- all ModDetails, all linked code
+--   - all unlinked code that is out of date with respect to
+--     the source file
+--
+-- This is VERY IMPORTANT otherwise we'll end up requiring 2x the
+-- space at the end of the upsweep, because the topmost ModDetails of the
+-- old HPT holds on to the entire type environment from the previous
+-- compilation.
+
+pruneHomePackageTable
+   :: HomePackageTable
+   -> [ModSummary]
+   -> ([ModuleName],[ModuleName])
+   -> HomePackageTable
+
+pruneHomePackageTable hpt summ (stable_obj, stable_bco)
+  = mapUFM prune hpt
+  where prune hmi
+	  | is_stable modl = hmi'
+	  | otherwise      = hmi'{ hm_details = emptyModDetails }
+	  where
+	   modl = moduleName (mi_module (hm_iface hmi))
+	   hmi' | Just l <- hm_linkable hmi, linkableTime l < ms_hs_date ms
+		= hmi{ hm_linkable = Nothing }
+		| otherwise
+		= hmi
+		where ms = expectJust "prune" (lookupUFM ms_map modl)
+
+        ms_map = listToUFM [(ms_mod_name ms, ms) | ms <- summ]
+
+	is_stable m = m `elem` stable_obj || m `elem` stable_bco
+
+-- -----------------------------------------------------------------------------
+
+-- Return (names of) all those in modsDone who are part of a cycle
+-- as defined by theGraph.
+findPartiallyCompletedCycles :: [Module] -> [SCC ModSummary] -> [Module]
+findPartiallyCompletedCycles modsDone theGraph
+   = chew theGraph
+     where
+        chew [] = []
+        chew ((AcyclicSCC _):rest) = chew rest    -- acyclic?  not interesting.
+        chew ((CyclicSCC vs):rest)
+           = let names_in_this_cycle = nub (map ms_mod vs)
+                 mods_in_this_cycle
+                    = nub ([done | done <- modsDone,
+                                   done `elem` names_in_this_cycle])
+                 chewed_rest = chew rest
+             in
+             if   notNull mods_in_this_cycle
+                  && length mods_in_this_cycle < length names_in_this_cycle
+             then mods_in_this_cycle ++ chewed_rest
+             else chewed_rest
+
+
+-- ---------------------------------------------------------------------------
+-- Unloading
+
+unload :: HscEnv -> [Linkable] -> IO ()
+unload hsc_env stable_linkables	-- Unload everthing *except* 'stable_linkables'
+  = case ghcLink (hsc_dflags hsc_env) of
+#ifdef GHCI
+	LinkInMemory -> Linker.unload (hsc_dflags hsc_env) stable_linkables
+#else
+	LinkInMemory -> panic "unload: no interpreter"
+                                -- urgh.  avoid warnings:
+                                hsc_env stable_linkables
+#endif
+	_other -> return ()
+
+-- -----------------------------------------------------------------------------
+
+{- |
+
+  Stability tells us which modules definitely do not need to be recompiled.
+  There are two main reasons for having stability:
+
+   - avoid doing a complete upsweep of the module graph in GHCi when
+     modules near the bottom of the tree have not changed.
+
+   - to tell GHCi when it can load object code: we can only load object code
+     for a module when we also load object code fo  all of the imports of the
+     module.  So we need to know that we will definitely not be recompiling
+     any of these modules, and we can use the object code.
+
+  The stability check is as follows.  Both stableObject and
+  stableBCO are used during the upsweep phase later.
+
+@
+  stable m = stableObject m || stableBCO m
+
+  stableObject m =
+	all stableObject (imports m)
+	&& old linkable does not exist, or is == on-disk .o
+	&& date(on-disk .o) > date(.hs)
+
+  stableBCO m =
+	all stable (imports m)
+	&& date(BCO) > date(.hs)
+@
+
+  These properties embody the following ideas:
+
+    - if a module is stable, then:
+
+	- if it has been compiled in a previous pass (present in HPT)
+	  then it does not need to be compiled or re-linked.
+
+        - if it has not been compiled in a previous pass,
+	  then we only need to read its .hi file from disk and
+	  link it to produce a 'ModDetails'.
+
+    - if a modules is not stable, we will definitely be at least
+      re-linking, and possibly re-compiling it during the 'upsweep'.
+      All non-stable modules can (and should) therefore be unlinked
+      before the 'upsweep'.
+
+    - Note that objects are only considered stable if they only depend
+      on other objects.  We can't link object code against byte code.
+-}
+
+checkStability
+	:: HomePackageTable		-- HPT from last compilation
+	-> [SCC ModSummary]		-- current module graph (cyclic)
+	-> [ModuleName]			-- all home modules
+	-> ([ModuleName],		-- stableObject
+	    [ModuleName])		-- stableBCO
+
+checkStability hpt sccs all_home_mods = foldl checkSCC ([],[]) sccs
+  where
+   checkSCC (stable_obj, stable_bco) scc0
+     | stableObjects = (scc_mods ++ stable_obj, stable_bco)
+     | stableBCOs    = (stable_obj, scc_mods ++ stable_bco)
+     | otherwise     = (stable_obj, stable_bco)
+     where
+	scc = flattenSCC scc0
+	scc_mods = map ms_mod_name scc
+	home_module m   = m `elem` all_home_mods && m `notElem` scc_mods
+
+        scc_allimps = nub (filter home_module (concatMap ms_home_allimps scc))
+	    -- all imports outside the current SCC, but in the home pkg
+
+	stable_obj_imps = map (`elem` stable_obj) scc_allimps
+	stable_bco_imps = map (`elem` stable_bco) scc_allimps
+
+	stableObjects =
+	   and stable_obj_imps
+	   && all object_ok scc
+
+	stableBCOs =
+	   and (zipWith (||) stable_obj_imps stable_bco_imps)
+	   && all bco_ok scc
+
+	object_ok ms
+	  | Just t <- ms_obj_date ms  =  t >= ms_hs_date ms
+					 && same_as_prev t
+	  | otherwise = False
+	  where
+	     same_as_prev t = case lookupUFM hpt (ms_mod_name ms) of
+				Just hmi  | Just l <- hm_linkable hmi
+				 -> isObjectLinkable l && t == linkableTime l
+				_other  -> True
+		-- why '>=' rather than '>' above?  If the filesystem stores
+		-- times to the nearset second, we may occasionally find that
+		-- the object & source have the same modification time,
+		-- especially if the source was automatically generated
+		-- and compiled.  Using >= is slightly unsafe, but it matches
+		-- make's behaviour.
+
+	bco_ok ms
+	  = case lookupUFM hpt (ms_mod_name ms) of
+		Just hmi  | Just l <- hm_linkable hmi ->
+			not (isObjectLinkable l) &&
+			linkableTime l >= ms_hs_date ms
+		_other  -> False
+
+-- -----------------------------------------------------------------------------
+
+-- | The upsweep
+--
+-- This is where we compile each module in the module graph, in a pass
+-- from the bottom to the top of the graph.
+--
+-- There better had not be any cyclic groups here -- we check for them.
+
+upsweep
+    :: GhcMonad m
+    => HomePackageTable		-- ^ HPT from last time round (pruned)
+    -> ([ModuleName],[ModuleName]) -- ^ stable modules (see checkStability)
+    -> IO ()			-- ^ How to clean up unwanted tmp files
+    -> [SCC ModSummary]		-- ^ Mods to do (the worklist)
+    -> m (SuccessFlag,
+          [ModSummary])
+       -- ^ Returns:
+       --
+       --  1. A flag whether the complete upsweep was successful.
+       --  2. The 'HscEnv' in the monad has an updated HPT
+       --  3. A list of modules which succeeded loading.
+
+upsweep old_hpt stable_mods cleanup sccs = do
+   (res, done) <- upsweep' old_hpt [] sccs 1 (length sccs)
+   return (res, reverse done)
+ where
+
+  upsweep' _old_hpt done
+     [] _ _
+   = return (Succeeded, done)
+
+  upsweep' _old_hpt done
+     (CyclicSCC ms:_) _ _
+   = do dflags <- getSessionDynFlags
+        liftIO $ fatalErrorMsg dflags (cyclicModuleErr ms)
+        return (Failed, done)
+
+  upsweep' old_hpt done
+     (AcyclicSCC mod:mods) mod_index nmods
+   = do -- putStrLn ("UPSWEEP_MOD: hpt = " ++
+	--	     show (map (moduleUserString.moduleName.mi_module.hm_iface)
+	--		       (moduleEnvElts (hsc_HPT hsc_env)))
+        let logger _mod = defaultWarnErrLogger
+
+        hsc_env <- getSession
+        mb_mod_info
+            <- handleSourceError
+                   (\err -> do logger mod (Just err); return Nothing) $ do
+                 mod_info <- liftIO $ upsweep_mod hsc_env old_hpt stable_mods
+                                                  mod mod_index nmods
+                 logger mod Nothing -- log warnings
+                 return (Just mod_info)
+
+        liftIO cleanup -- Remove unwanted tmp files between compilations
+
+        case mb_mod_info of
+          Nothing -> return (Failed, done)
+          Just mod_info -> do
+		let this_mod = ms_mod_name mod
+
+			-- Add new info to hsc_env
+		    hpt1     = addToUFM (hsc_HPT hsc_env) this_mod mod_info
+		    hsc_env1 = hsc_env { hsc_HPT = hpt1 }
+
+			-- Space-saving: delete the old HPT entry
+			-- for mod BUT if mod is a hs-boot
+			-- node, don't delete it.  For the
+			-- interface, the HPT entry is probaby for the
+			-- main Haskell source file.  Deleting it
+			-- would force the real module to be recompiled
+                        -- every time.
+		    old_hpt1 | isBootSummary mod = old_hpt
+			     | otherwise = delFromUFM old_hpt this_mod
+
+                    done' = mod:done
+
+                        -- fixup our HomePackageTable after we've finished compiling
+                        -- a mutually-recursive loop.  See reTypecheckLoop, below.
+                hsc_env2 <- liftIO $ reTypecheckLoop hsc_env1 mod done'
+                setSession hsc_env2
+
+		upsweep' old_hpt1 done' mods (mod_index+1) nmods
+
+-- | Compile a single module.  Always produce a Linkable for it if
+-- successful.  If no compilation happened, return the old Linkable.
+upsweep_mod :: HscEnv
+            -> HomePackageTable
+	    -> ([ModuleName],[ModuleName])
+            -> ModSummary
+            -> Int  -- index of module
+            -> Int  -- total number of modules
+            -> IO HomeModInfo
+
+upsweep_mod hsc_env old_hpt (stable_obj, stable_bco) summary mod_index nmods
+   =    let
+       	    this_mod_name = ms_mod_name summary
+	    this_mod    = ms_mod summary
+	    mb_obj_date = ms_obj_date summary
+	    obj_fn	= ml_obj_file (ms_location summary)
+	    hs_date     = ms_hs_date summary
+
+	    is_stable_obj = this_mod_name `elem` stable_obj
+	    is_stable_bco = this_mod_name `elem` stable_bco
+
+	    old_hmi = lookupUFM old_hpt this_mod_name
+
+            -- We're using the dflags for this module now, obtained by
+            -- applying any options in its LANGUAGE & OPTIONS_GHC pragmas.
+            dflags = ms_hspp_opts summary
+            prevailing_target = hscTarget (hsc_dflags hsc_env)
+            local_target      = hscTarget dflags
+
+            -- If OPTIONS_GHC contains -fasm or -fvia-C, be careful that
+            -- we don't do anything dodgy: these should only work to change
+            -- from -fvia-C to -fasm and vice-versa, otherwise we could
+            -- end up trying to link object code to byte code.
+            target = if prevailing_target /= local_target
+                        && (not (isObjectTarget prevailing_target)
+                            || not (isObjectTarget local_target))
+                        then prevailing_target
+                        else local_target
+
+            -- store the corrected hscTarget into the summary
+            summary' = summary{ ms_hspp_opts = dflags { hscTarget = target } }
+
+	    -- The old interface is ok if
+	    --	a) we're compiling a source file, and the old HPT
+	    --	   entry is for a source file
+	    --	b) we're compiling a hs-boot file
+	    -- Case (b) allows an hs-boot file to get the interface of its
+	    -- real source file on the second iteration of the compilation
+	    -- manager, but that does no harm.  Otherwise the hs-boot file
+	    -- will always be recompiled
+
+            mb_old_iface
+	    	= case old_hmi of
+	    	     Nothing	 			  -> Nothing
+	    	     Just hm_info | isBootSummary summary -> Just iface
+	    			  | not (mi_boot iface)   -> Just iface
+	    			  | otherwise		  -> Nothing
+	    			   where
+	    			     iface = hm_iface hm_info
+
+	    compile_it :: Maybe Linkable -> IO HomeModInfo
+	    compile_it  mb_linkable =
+                  compile hsc_env summary' mod_index nmods
+                          mb_old_iface mb_linkable
+
+            compile_it_discard_iface :: Maybe Linkable -> IO HomeModInfo
+            compile_it_discard_iface mb_linkable =
+                  compile hsc_env summary' mod_index nmods
+                          Nothing mb_linkable
+
+            -- With the HscNothing target we create empty linkables to avoid
+            -- recompilation.  We have to detect these to recompile anyway if
+            -- the target changed since the last compile.
+            is_fake_linkable
+               | Just hmi <- old_hmi, Just l <- hm_linkable hmi =
+                  null (linkableUnlinked l)
+               | otherwise =
+                   -- we have no linkable, so it cannot be fake
+                   False
+
+            implies False _ = True
+            implies True x  = x
+
+        in
+        case () of
+         _
+                -- Regardless of whether we're generating object code or
+                -- byte code, we can always use an existing object file
+                -- if it is *stable* (see checkStability).
+          | is_stable_obj, Just hmi <- old_hmi -> do
+                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                           (text "skipping stable obj mod:" <+> ppr this_mod_name)
+                return hmi
+                -- object is stable, and we have an entry in the
+                -- old HPT: nothing to do
+
+          | is_stable_obj, isNothing old_hmi -> do
+                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                           (text "compiling stable on-disk mod:" <+> ppr this_mod_name)
+                linkable <- liftIO $ findObjectLinkable this_mod obj_fn
+                              (expectJust "upsweep1" mb_obj_date)
+                compile_it (Just linkable)
+                -- object is stable, but we need to load the interface
+                -- off disk to make a HMI.
+
+          | not (isObjectTarget target), is_stable_bco,
+            (target /= HscNothing) `implies` not is_fake_linkable ->
+                ASSERT(isJust old_hmi) -- must be in the old_hpt
+                let Just hmi = old_hmi in do
+                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                           (text "skipping stable BCO mod:" <+> ppr this_mod_name)
+                return hmi
+                -- BCO is stable: nothing to do
+
+          | not (isObjectTarget target),
+            Just hmi <- old_hmi,
+            Just l <- hm_linkable hmi,
+            not (isObjectLinkable l),
+            (target /= HscNothing) `implies` not is_fake_linkable,
+            linkableTime l >= ms_hs_date summary -> do
+                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                           (text "compiling non-stable BCO mod:" <+> ppr this_mod_name)
+                compile_it (Just l)
+                -- we have an old BCO that is up to date with respect
+                -- to the source: do a recompilation check as normal.
+
+          -- When generating object code, if there's an up-to-date
+          -- object file on the disk, then we can use it.
+          -- However, if the object file is new (compared to any
+          -- linkable we had from a previous compilation), then we
+          -- must discard any in-memory interface, because this
+          -- means the user has compiled the source file
+          -- separately and generated a new interface, that we must
+          -- read from the disk.
+          --
+          | isObjectTarget target,
+            Just obj_date <- mb_obj_date,
+            obj_date >= hs_date -> do
+                case old_hmi of
+                  Just hmi
+                    | Just l <- hm_linkable hmi,
+                      isObjectLinkable l && linkableTime l == obj_date -> do
+                          liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                                     (text "compiling mod with new on-disk obj:" <+> ppr this_mod_name)
+                          compile_it (Just l)
+                  _otherwise -> do
+                          liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                                     (text "compiling mod with new on-disk obj2:" <+> ppr this_mod_name)
+                          linkable <- liftIO $ findObjectLinkable this_mod obj_fn obj_date
+                          compile_it_discard_iface (Just linkable)
+
+         _otherwise -> do
+                liftIO $ debugTraceMsg (hsc_dflags hsc_env) 5
+                           (text "compiling mod:" <+> ppr this_mod_name)
+                compile_it Nothing
+
+
+
+-- Filter modules in the HPT
+retainInTopLevelEnvs :: [ModuleName] -> HomePackageTable -> HomePackageTable
+retainInTopLevelEnvs keep_these hpt
+   = listToUFM   [ (mod, expectJust "retain" mb_mod_info)
+		 | mod <- keep_these
+		 , let mb_mod_info = lookupUFM hpt mod
+		 , isJust mb_mod_info ]
+
+-- ---------------------------------------------------------------------------
+-- Typecheck module loops
+
+{-
+See bug #930.  This code fixes a long-standing bug in --make.  The
+problem is that when compiling the modules *inside* a loop, a data
+type that is only defined at the top of the loop looks opaque; but
+after the loop is done, the structure of the data type becomes
+apparent.
+
+The difficulty is then that two different bits of code have
+different notions of what the data type looks like.
+
+The idea is that after we compile a module which also has an .hs-boot
+file, we re-generate the ModDetails for each of the modules that
+depends on the .hs-boot file, so that everyone points to the proper
+TyCons, Ids etc. defined by the real module, not the boot module.
+Fortunately re-generating a ModDetails from a ModIface is easy: the
+function TcIface.typecheckIface does exactly that.
+
+Picking the modules to re-typecheck is slightly tricky.  Starting from
+the module graph consisting of the modules that have already been
+compiled, we reverse the edges (so they point from the imported module
+to the importing module), and depth-first-search from the .hs-boot
+node.  This gives us all the modules that depend transitively on the
+.hs-boot module, and those are exactly the modules that we need to
+re-typecheck.
+
+Following this fix, GHC can compile itself with --make -O2.
+-}
+
+reTypecheckLoop :: HscEnv -> ModSummary -> ModuleGraph -> IO HscEnv
+reTypecheckLoop hsc_env ms graph
+  | not (isBootSummary ms) &&
+    any (\m -> ms_mod m == this_mod && isBootSummary m) graph
+  = do
+        let mss = reachableBackwards (ms_mod_name ms) graph
+            non_boot = filter (not.isBootSummary) mss
+        debugTraceMsg (hsc_dflags hsc_env) 2 $
+           text "Re-typechecking loop: " <> ppr (map ms_mod_name non_boot)
+        typecheckLoop hsc_env (map ms_mod_name non_boot)
+  | otherwise
+  = return hsc_env
+ where
+  this_mod = ms_mod ms
+
+typecheckLoop :: HscEnv -> [ModuleName] -> IO HscEnv
+typecheckLoop hsc_env mods = do
+  new_hpt <-
+    fixIO $ \new_hpt -> do
+      let new_hsc_env = hsc_env{ hsc_HPT = new_hpt }
+      mds <- initIfaceCheck new_hsc_env $
+                mapM (typecheckIface . hm_iface) hmis
+      let new_hpt = addListToUFM old_hpt
+                        (zip mods [ hmi{ hm_details = details }
+                                  | (hmi,details) <- zip hmis mds ])
+      return new_hpt
+  return hsc_env{ hsc_HPT = new_hpt }
+  where
+    old_hpt = hsc_HPT hsc_env
+    hmis    = map (expectJust "typecheckLoop" . lookupUFM old_hpt) mods
+
+reachableBackwards :: ModuleName -> [ModSummary] -> [ModSummary]
+reachableBackwards mod summaries
+  = [ ms | (ms,_,_) <- reachableG (transposeG graph) root ]
+  where -- the rest just sets up the graph:
+        (graph, lookup_node) = moduleGraphNodes False summaries
+        root  = expectJust "reachableBackwards" (lookup_node HsBootFile mod)
+
+-- ---------------------------------------------------------------------------
+-- Topological sort of the module graph
+
+type SummaryNode = (ModSummary, Int, [Int])
+
+topSortModuleGraph
+	  :: Bool
+          -- ^ Drop hi-boot nodes? (see below)
+	  -> [ModSummary]
+	  -> Maybe ModuleName
+             -- ^ Root module name.  If @Nothing@, use the full graph.
+	  -> [SCC ModSummary]
+-- ^ Calculate SCCs of the module graph, possibly dropping the hi-boot nodes
+-- The resulting list of strongly-connected-components is in topologically
+-- sorted order, starting with the module(s) at the bottom of the
+-- dependency graph (ie compile them first) and ending with the ones at
+-- the top.
+--
+-- Drop hi-boot nodes (first boolean arg)?
+--
+-- - @False@:	treat the hi-boot summaries as nodes of the graph,
+--		so the graph must be acyclic
+--
+-- - @True@:	eliminate the hi-boot nodes, and instead pretend
+--		the a source-import of Foo is an import of Foo
+--		The resulting graph has no hi-boot nodes, but can be cyclic
+
+topSortModuleGraph drop_hs_boot_nodes summaries mb_root_mod
+  = map (fmap summaryNodeSummary) $ stronglyConnCompG initial_graph
+  where
+    (graph, lookup_node) = moduleGraphNodes drop_hs_boot_nodes summaries
+
+    initial_graph = case mb_root_mod of
+        Nothing -> graph
+        Just root_mod ->
+            -- restrict the graph to just those modules reachable from
+            -- the specified module.  We do this by building a graph with
+            -- the full set of nodes, and determining the reachable set from
+            -- the specified node.
+            let root | Just node <- lookup_node HsSrcFile root_mod, graph `hasVertexG` node = node
+                     | otherwise = ghcError (ProgramError "module does not exist")
+            in graphFromEdgedVertices (seq root (reachableG graph root))
+
+summaryNodeKey :: SummaryNode -> Int
+summaryNodeKey (_, k, _) = k
+
+summaryNodeSummary :: SummaryNode -> ModSummary
+summaryNodeSummary (s, _, _) = s
+
+moduleGraphNodes :: Bool -> [ModSummary]
+  -> (Graph SummaryNode, HscSource -> ModuleName -> Maybe SummaryNode)
+moduleGraphNodes drop_hs_boot_nodes summaries = (graphFromEdgedVertices nodes, lookup_node)
+  where
+    numbered_summaries = zip summaries [1..]
+
+    lookup_node :: HscSource -> ModuleName -> Maybe SummaryNode
+    lookup_node hs_src mod = Map.lookup (mod, hs_src) node_map
+
+    lookup_key :: HscSource -> ModuleName -> Maybe Int
+    lookup_key hs_src mod = fmap summaryNodeKey (lookup_node hs_src mod)
+
+    node_map :: NodeMap SummaryNode
+    node_map = Map.fromList [ ((moduleName (ms_mod s), ms_hsc_src s), node)
+                            | node@(s, _, _) <- nodes ]
+
+    -- We use integers as the keys for the SCC algorithm
+    nodes :: [SummaryNode]
+    nodes = [ (s, key, out_keys)
+            | (s, key) <- numbered_summaries
+             -- Drop the hi-boot ones if told to do so
+            , not (isBootSummary s && drop_hs_boot_nodes)
+            , let out_keys = out_edge_keys hs_boot_key (map unLoc (ms_home_srcimps s)) ++
+                             out_edge_keys HsSrcFile   (map unLoc (ms_home_imps s)) ++
+                             (-- see [boot-edges] below
+                              if drop_hs_boot_nodes || ms_hsc_src s == HsBootFile
+                              then []
+                              else case lookup_key HsBootFile (ms_mod_name s) of
+                                    Nothing -> []
+                                    Just k  -> [k]) ]
+
+    -- [boot-edges] if this is a .hs and there is an equivalent
+    -- .hs-boot, add a link from the former to the latter.  This
+    -- has the effect of detecting bogus cases where the .hs-boot
+    -- depends on the .hs, by introducing a cycle.  Additionally,
+    -- it ensures that we will always process the .hs-boot before
+    -- the .hs, and so the HomePackageTable will always have the
+    -- most up to date information.
+
+    -- Drop hs-boot nodes by using HsSrcFile as the key
+    hs_boot_key | drop_hs_boot_nodes = HsSrcFile
+                | otherwise          = HsBootFile
+
+    out_edge_keys :: HscSource -> [ModuleName] -> [Int]
+    out_edge_keys hi_boot ms = mapCatMaybes (lookup_key hi_boot) ms
+        -- If we want keep_hi_boot_nodes, then we do lookup_key with
+        -- the IsBootInterface parameter True; else False
+
+
+type NodeKey   = (ModuleName, HscSource)  -- The nodes of the graph are
+type NodeMap a = Map.Map NodeKey a	  -- keyed by (mod, src_file_type) pairs
+
+msKey :: ModSummary -> NodeKey
+msKey (ModSummary { ms_mod = mod, ms_hsc_src = boot }) = (moduleName mod,boot)
+
+mkNodeMap :: [ModSummary] -> NodeMap ModSummary
+mkNodeMap summaries = Map.fromList [ (msKey s, s) | s <- summaries]
+
+nodeMapElts :: NodeMap a -> [a]
+nodeMapElts = Map.elems
+
+-- | If there are {-# SOURCE #-} imports between strongly connected
+-- components in the topological sort, then those imports can
+-- definitely be replaced by ordinary non-SOURCE imports: if SOURCE
+-- were necessary, then the edge would be part of a cycle.
+warnUnnecessarySourceImports :: GhcMonad m => [SCC ModSummary] -> m ()
+warnUnnecessarySourceImports sccs = do
+  logWarnings (listToBag (concatMap (check.flattenSCC) sccs))
+  where check ms =
+	   let mods_in_this_cycle = map ms_mod_name ms in
+	   [ warn i | m <- ms, i <- ms_home_srcimps m,
+	              unLoc i `notElem`  mods_in_this_cycle ]
+
+	warn :: Located ModuleName -> WarnMsg
+	warn (L loc mod) =
+	   mkPlainErrMsg loc
+		(ptext (sLit "Warning: {-# SOURCE #-} unnecessary in import of ")
+		 <+> quotes (ppr mod))
+
+-----------------------------------------------------------------------------
+-- Downsweep (dependency analysis)
+
+-- Chase downwards from the specified root set, returning summaries
+-- for all home modules encountered.  Only follow source-import
+-- links.
+
+-- We pass in the previous collection of summaries, which is used as a
+-- cache to avoid recalculating a module summary if the source is
+-- unchanged.
+--
+-- The returned list of [ModSummary] nodes has one node for each home-package
+-- module, plus one for any hs-boot files.  The imports of these nodes
+-- are all there, including the imports of non-home-package modules.
+
+downsweep :: HscEnv
+	  -> [ModSummary]	-- Old summaries
+	  -> [ModuleName]	-- Ignore dependencies on these; treat
+				-- them as if they were package modules
+	  -> Bool		-- True <=> allow multiple targets to have
+				-- 	    the same module name; this is
+				--	    very useful for ghc -M
+	  -> IO [ModSummary]
+		-- The elts of [ModSummary] all have distinct
+		-- (Modules, IsBoot) identifiers, unless the Bool is true
+		-- in which case there can be repeats
+downsweep hsc_env old_summaries excl_mods allow_dup_roots
+   = do
+       rootSummaries <- mapM getRootSummary roots
+       let root_map = mkRootMap rootSummaries
+       checkDuplicates root_map
+       summs <- loop (concatMap msDeps rootSummaries) root_map
+       return summs
+     where
+	roots = hsc_targets hsc_env
+
+	old_summary_map :: NodeMap ModSummary
+	old_summary_map = mkNodeMap old_summaries
+
+	getRootSummary :: Target -> IO ModSummary
+	getRootSummary (Target (TargetFile file mb_phase) obj_allowed maybe_buf)
+	   = do exists <- liftIO $ doesFileExist file
+		if exists
+		    then summariseFile hsc_env old_summaries file mb_phase
+                                       obj_allowed maybe_buf
+		    else throwOneError $ mkPlainErrMsg noSrcSpan $
+			   text "can't find file:" <+> text file
+	getRootSummary (Target (TargetModule modl) obj_allowed maybe_buf)
+ 	   = do maybe_summary <- summariseModule hsc_env old_summary_map False
+					   (L rootLoc modl) obj_allowed
+                                           maybe_buf excl_mods
+		case maybe_summary of
+		   Nothing -> packageModErr modl
+		   Just s  -> return s
+
+	rootLoc = mkGeneralSrcSpan (fsLit "<command line>")
+
+	-- In a root module, the filename is allowed to diverge from the module
+	-- name, so we have to check that there aren't multiple root files
+	-- defining the same module (otherwise the duplicates will be silently
+ 	-- ignored, leading to confusing behaviour).
+	checkDuplicates :: NodeMap [ModSummary] -> IO ()
+	checkDuplicates root_map
+	   | allow_dup_roots = return ()
+	   | null dup_roots  = return ()
+	   | otherwise	     = liftIO $ multiRootsErr (head dup_roots)
+	   where
+	     dup_roots :: [[ModSummary]]	-- Each at least of length 2
+	     dup_roots = filterOut isSingleton (nodeMapElts root_map)
+
+	loop :: [(Located ModuleName,IsBootInterface)]
+			-- Work list: process these modules
+	     -> NodeMap [ModSummary]
+		 	-- Visited set; the range is a list because
+			-- the roots can have the same module names
+			-- if allow_dup_roots is True
+	     -> IO [ModSummary]
+			-- The result includes the worklist, except
+			-- for those mentioned in the visited set
+	loop [] done 	  = return (concat (nodeMapElts done))
+	loop ((wanted_mod, is_boot) : ss) done
+	  | Just summs <- Map.lookup key done
+	  = if isSingleton summs then
+		loop ss done
+	    else
+		do { multiRootsErr summs; return [] }
+	  | otherwise
+          = do mb_s <- summariseModule hsc_env old_summary_map
+                                       is_boot wanted_mod True
+                                       Nothing excl_mods
+               case mb_s of
+                   Nothing -> loop ss done
+                   Just s  -> loop (msDeps s ++ ss) (Map.insert key [s] done)
+	  where
+	    key = (unLoc wanted_mod, if is_boot then HsBootFile else HsSrcFile)
+
+-- XXX Does the (++) here need to be flipped?
+mkRootMap :: [ModSummary] -> NodeMap [ModSummary]
+mkRootMap summaries = Map.insertListWith (flip (++))
+                                         [ (msKey s, [s]) | s <- summaries ]
+                                         Map.empty
+
+msDeps :: ModSummary -> [(Located ModuleName, IsBootInterface)]
+-- (msDeps s) returns the dependencies of the ModSummary s.
+-- A wrinkle is that for a {-# SOURCE #-} import we return
+--	*both* the hs-boot file
+--	*and* the source file
+-- as "dependencies".  That ensures that the list of all relevant
+-- modules always contains B.hs if it contains B.hs-boot.
+-- Remember, this pass isn't doing the topological sort.  It's
+-- just gathering the list of all relevant ModSummaries
+msDeps s =
+    concat [ [(m,True), (m,False)] | m <- ms_home_srcimps s ]
+	 ++ [ (m,False) | m <- ms_home_imps s ]
+
+home_imps :: [Located (ImportDecl RdrName)] -> [Located ModuleName]
+home_imps imps = [ ideclName i |  L _ i <- imps, isLocal (ideclPkgQual i) ]
+  where isLocal Nothing = True
+        isLocal (Just pkg) | pkg == fsLit "this" = True -- "this" is special
+        isLocal _ = False
+
+ms_home_allimps :: ModSummary -> [ModuleName]
+ms_home_allimps ms = map unLoc (ms_home_srcimps ms ++ ms_home_imps ms)
+
+ms_home_srcimps :: ModSummary -> [Located ModuleName]
+ms_home_srcimps = home_imps . ms_srcimps
+
+ms_home_imps :: ModSummary -> [Located ModuleName]
+ms_home_imps = home_imps . ms_imps
+
+-----------------------------------------------------------------------------
+-- Summarising modules
+
+-- We have two types of summarisation:
+--
+--    * Summarise a file.  This is used for the root module(s) passed to
+--	cmLoadModules.  The file is read, and used to determine the root
+--	module name.  The module name may differ from the filename.
+--
+--    * Summarise a module.  We are given a module name, and must provide
+--	a summary.  The finder is used to locate the file in which the module
+--	resides.
+
+summariseFile
+	:: HscEnv
+	-> [ModSummary]			-- old summaries
+	-> FilePath			-- source file name
+	-> Maybe Phase			-- start phase
+        -> Bool                         -- object code allowed?
+	-> Maybe (StringBuffer,ClockTime)
+	-> IO ModSummary
+
+summariseFile hsc_env old_summaries file mb_phase obj_allowed maybe_buf
+	-- we can use a cached summary if one is available and the
+	-- source file hasn't changed,  But we have to look up the summary
+	-- by source file, rather than module name as we do in summarise.
+   | Just old_summary <- findSummaryBySourceFile old_summaries file
+   = do
+	let location = ms_location old_summary
+
+		-- return the cached summary if the source didn't change
+	src_timestamp <- case maybe_buf of
+			   Just (_,t) -> return t
+			   Nothing    -> liftIO $ getModificationTime file
+		-- The file exists; we checked in getRootSummary above.
+		-- If it gets removed subsequently, then this
+		-- getModificationTime may fail, but that's the right
+		-- behaviour.
+
+	if ms_hs_date old_summary == src_timestamp
+	   then do -- update the object-file timestamp
+        	  obj_timestamp <-
+                    if isObjectTarget (hscTarget (hsc_dflags hsc_env))
+                        || obj_allowed -- bug #1205
+                        then liftIO $ getObjTimestamp location False
+                        else return Nothing
+		  return old_summary{ ms_obj_date = obj_timestamp }
+	   else
+		new_summary
+
+   | otherwise
+   = new_summary
+  where
+    new_summary = do
+   	let dflags = hsc_dflags hsc_env
+
+	(dflags', hspp_fn, buf)
+	    <- preprocessFile hsc_env file mb_phase maybe_buf
+
+        (srcimps,the_imps, L _ mod_name) <- getImports dflags' buf hspp_fn file
+
+	-- Make a ModLocation for this file
+	location <- liftIO $ mkHomeModLocation dflags mod_name file
+
+	-- Tell the Finder cache where it is, so that subsequent calls
+	-- to findModule will find it, even if it's not on any search path
+	mod <- liftIO $ addHomeModuleToFinder hsc_env mod_name location
+
+        src_timestamp <- case maybe_buf of
+			   Just (_,t) -> return t
+			   Nothing    -> liftIO $ getModificationTime file
+			-- getMofificationTime may fail
+
+        -- when the user asks to load a source file by name, we only
+        -- use an object file if -fobject-code is on.  See #1205.
+	obj_timestamp <-
+            if isObjectTarget (hscTarget (hsc_dflags hsc_env))
+               || obj_allowed -- bug #1205
+                then liftIO $ modificationTimeIfExists (ml_obj_file location)
+                else return Nothing
+
+        return (ModSummary { ms_mod = mod, ms_hsc_src = HsSrcFile,
+			     ms_location = location,
+                             ms_hspp_file = hspp_fn,
+                             ms_hspp_opts = dflags',
+			     ms_hspp_buf  = Just buf,
+                             ms_srcimps = srcimps, ms_imps = the_imps,
+			     ms_hs_date = src_timestamp,
+			     ms_obj_date = obj_timestamp })
+
+findSummaryBySourceFile :: [ModSummary] -> FilePath -> Maybe ModSummary
+findSummaryBySourceFile summaries file
+  = case [ ms | ms <- summaries, HsSrcFile <- [ms_hsc_src ms],
+			         expectJust "findSummaryBySourceFile" (ml_hs_file (ms_location ms)) == file ] of
+	[] -> Nothing
+	(x:_) -> Just x
+
+-- Summarise a module, and pick up source and timestamp.
+summariseModule
+	  :: HscEnv
+	  -> NodeMap ModSummary	-- Map of old summaries
+	  -> IsBootInterface	-- True <=> a {-# SOURCE #-} import
+	  -> Located ModuleName	-- Imported module to be summarised
+          -> Bool               -- object code allowed?
+	  -> Maybe (StringBuffer, ClockTime)
+	  -> [ModuleName]		-- Modules to exclude
+	  -> IO (Maybe ModSummary)	-- Its new summary
+
+summariseModule hsc_env old_summary_map is_boot (L loc wanted_mod)
+                obj_allowed maybe_buf excl_mods
+  | wanted_mod `elem` excl_mods
+  = return Nothing
+
+  | Just old_summary <- Map.lookup (wanted_mod, hsc_src) old_summary_map
+  = do	 	-- Find its new timestamp; all the
+		-- ModSummaries in the old map have valid ml_hs_files
+	let location = ms_location old_summary
+	    src_fn = expectJust "summariseModule" (ml_hs_file location)
+
+		-- check the modification time on the source file, and
+		-- return the cached summary if it hasn't changed.  If the
+		-- file has disappeared, we need to call the Finder again.
+	case maybe_buf of
+	   Just (_,t) -> check_timestamp old_summary location src_fn t
+	   Nothing    -> do
+		m <- tryIO (getModificationTime src_fn)
+		case m of
+		   Right t -> check_timestamp old_summary location src_fn t
+		   Left e | isDoesNotExistError e -> find_it
+		          | otherwise             -> ioError e
+
+  | otherwise  = find_it
+  where
+    dflags = hsc_dflags hsc_env
+
+    hsc_src = if is_boot then HsBootFile else HsSrcFile
+
+    check_timestamp old_summary location src_fn src_timestamp
+	| ms_hs_date old_summary == src_timestamp = do
+		-- update the object-file timestamp
+                obj_timestamp <-
+                    if isObjectTarget (hscTarget (hsc_dflags hsc_env))
+                       || obj_allowed -- bug #1205
+                       then getObjTimestamp location is_boot
+                       else return Nothing
+		return (Just old_summary{ ms_obj_date = obj_timestamp })
+	| otherwise =
+		-- source changed: re-summarise.
+		new_summary location (ms_mod old_summary) src_fn src_timestamp
+
+    find_it = do
+	-- Don't use the Finder's cache this time.  If the module was
+	-- previously a package module, it may have now appeared on the
+	-- search path, so we want to consider it to be a home module.  If
+	-- the module was previously a home module, it may have moved.
+	uncacheModule hsc_env wanted_mod
+	found <- findImportedModule hsc_env wanted_mod Nothing
+	case found of
+	     Found location mod
+		| isJust (ml_hs_file location) ->
+			-- Home package
+			 just_found location mod
+		| otherwise ->
+			-- Drop external-pkg
+			ASSERT(modulePackageId mod /= thisPackage dflags)
+			return Nothing
+
+	     err -> noModError dflags loc wanted_mod err
+			-- Not found
+
+    just_found location mod = do
+	  	-- Adjust location to point to the hs-boot source file,
+		-- hi file, object file, when is_boot says so
+	let location' | is_boot   = addBootSuffixLocn location
+		      | otherwise = location
+	    src_fn = expectJust "summarise2" (ml_hs_file location')
+
+		-- Check that it exists
+	  	-- It might have been deleted since the Finder last found it
+	maybe_t <- modificationTimeIfExists src_fn
+	case maybe_t of
+	  Nothing -> noHsFileErr loc src_fn
+	  Just t  -> new_summary location' mod src_fn t
+
+
+    new_summary location mod src_fn src_timestamp
+      = do
+	-- Preprocess the source file and get its imports
+	-- The dflags' contains the OPTIONS pragmas
+	(dflags', hspp_fn, buf) <- preprocessFile hsc_env src_fn Nothing maybe_buf
+        (srcimps, the_imps, L mod_loc mod_name) <- getImports dflags' buf hspp_fn src_fn
+
+	when (mod_name /= wanted_mod) $
+		throwOneError $ mkPlainErrMsg mod_loc $
+			      text "File name does not match module name:"
+			      $$ text "Saw:" <+> quotes (ppr mod_name)
+                              $$ text "Expected:" <+> quotes (ppr wanted_mod)
+
+		-- Find the object timestamp, and return the summary
+	obj_timestamp <-
+           if isObjectTarget (hscTarget (hsc_dflags hsc_env))
+              || obj_allowed -- bug #1205
+              then getObjTimestamp location is_boot
+              else return Nothing
+
+	return (Just (ModSummary { ms_mod       = mod,
+			      ms_hsc_src   = hsc_src,
+			      ms_location  = location,
+			      ms_hspp_file = hspp_fn,
+                              ms_hspp_opts = dflags',
+			      ms_hspp_buf  = Just buf,
+			      ms_srcimps   = srcimps,
+			      ms_imps      = the_imps,
+			      ms_hs_date   = src_timestamp,
+			      ms_obj_date  = obj_timestamp }))
+
+
+getObjTimestamp :: ModLocation -> Bool -> IO (Maybe ClockTime)
+getObjTimestamp location is_boot
+  = if is_boot then return Nothing
+	       else modificationTimeIfExists (ml_obj_file location)
+
+
+preprocessFile :: HscEnv
+               -> FilePath
+               -> Maybe Phase -- ^ Starting phase
+               -> Maybe (StringBuffer,ClockTime)
+               -> IO (DynFlags, FilePath, StringBuffer)
+preprocessFile hsc_env src_fn mb_phase Nothing
+  = do
+	(dflags', hspp_fn) <- preprocess hsc_env (src_fn, mb_phase)
+	buf <- hGetStringBuffer hspp_fn
+	return (dflags', hspp_fn, buf)
+
+preprocessFile hsc_env src_fn mb_phase (Just (buf, _time))
+  = do
+        let dflags = hsc_dflags hsc_env
+	-- case we bypass the preprocessing stage?
+	let local_opts = getOptions dflags buf src_fn
+
+	(dflags', leftovers, warns)
+            <- parseDynamicNoPackageFlags dflags local_opts
+        checkProcessArgsResult leftovers
+        handleFlagWarnings dflags' warns
+
+	let
+	    needs_preprocessing
+		| Just (Unlit _) <- mb_phase    = True
+	        | Nothing <- mb_phase, Unlit _ <- startPhase src_fn  = True
+		  -- note: local_opts is only required if there's no Unlit phase
+		| xopt Opt_Cpp dflags'		= True
+		| dopt Opt_Pp  dflags'		= True
+		| otherwise			= False
+
+	when needs_preprocessing $
+	   ghcError (ProgramError "buffer needs preprocesing; interactive check disabled")
+
+	return (dflags', src_fn, buf)
+
+
+-----------------------------------------------------------------------------
+-- 			Error messages
+-----------------------------------------------------------------------------
+
+noModError :: DynFlags -> SrcSpan -> ModuleName -> FindResult -> IO ab
+-- ToDo: we don't have a proper line number for this error
+noModError dflags loc wanted_mod err
+  = throwOneError $ mkPlainErrMsg loc $ cannotFindModule dflags wanted_mod err
+
+noHsFileErr :: SrcSpan -> String -> IO a
+noHsFileErr loc path
+  = throwOneError $ mkPlainErrMsg loc $ text "Can't find" <+> text path
+
+packageModErr :: ModuleName -> IO a
+packageModErr mod
+  = throwOneError $ mkPlainErrMsg noSrcSpan $
+	text "module" <+> quotes (ppr mod) <+> text "is a package module"
+
+multiRootsErr :: [ModSummary] -> IO ()
+multiRootsErr [] = panic "multiRootsErr"
+multiRootsErr summs@(summ1:_)
+  = throwOneError $ mkPlainErrMsg noSrcSpan $
+	text "module" <+> quotes (ppr mod) <+>
+	text "is defined in multiple files:" <+>
+	sep (map text files)
+  where
+    mod = ms_mod summ1
+    files = map (expectJust "checkDup" . ml_hs_file . ms_location) summs
+
+cyclicModuleErr :: [ModSummary] -> SDoc
+cyclicModuleErr ms
+  = hang (ptext (sLit "Module imports form a cycle for modules:"))
+       2 (vcat (map show_one ms))
+  where
+    mods_in_cycle = map ms_mod_name ms
+    imp_modname = unLoc . ideclName . unLoc
+    just_in_cycle = filter ((`elem` mods_in_cycle) . imp_modname)
+
+    show_one ms =
+           vcat [ show_mod (ms_hsc_src ms) (ms_mod_name ms) <+>
+                  maybe empty (parens . text) (ml_hs_file (ms_location ms)),
+                  nest 2 $ ptext (sLit "imports:") <+> vcat [
+                     pp_imps HsBootFile (just_in_cycle $ ms_srcimps ms),
+                     pp_imps HsSrcFile  (just_in_cycle $ ms_imps ms) ]
+                ]
+    show_mod hsc_src mod = ppr mod <> text (hscSourceString hsc_src)
+    pp_imps src imps = fsep (map (show_mod src . unLoc . ideclName . unLoc) imps)
[SafeHaskell: Disable unsafe flags in Safe mode
David Terei <davidt@scs.stanford.edu>**20110412171240
 Ignore-this: 6eacaf0ccfae3642d24afb0023c634a5
] {
hunk ./compiler/main/CmdLineParser.hs 15
 module CmdLineParser (
         processArgs, OptKind(..),
         CmdLineP(..), getCmdLineState, putCmdLineState,
-        Flag(..), 
-        errorsToGhcException,
+        Flag(..), FlagSafety(..), flagA, flagR, flagC, flagN,
+        errorsToGhcException, determineSafeLevel,
 
         EwM, addErr, addWarn, getArg, liftEwM, deprecate
   ) where
hunk ./compiler/main/CmdLineParser.hs 37
 
 data Flag m = Flag
     {   flagName    :: String,       -- Flag, without the leading "-"
+        flagSafety  :: FlagSafety,   -- Flag safety level (SafeHaskell)
         flagOptKind :: OptKind m     -- What to do if we see it
     }
 
hunk ./compiler/main/CmdLineParser.hs 41
+-- | This determines how a flag should behave when SafeHaskell
+-- mode is on.
+data FlagSafety
+ = EnablesSafe         -- ^ This flag is a little bit of a hack. We give
+                       -- the safe haskell flags (-XSafe and -XSafeLanguage)
+                       -- this safety type so we can easily detect when safe
+                       -- haskell mode has been enable in a module pragma
+                       -- as this changes how the rest of the parsing should
+                       -- happen.
+
+ | AlwaysAllowed       -- ^ Flag is always allowed
+ | RestrictedFunction  -- ^ Flag is allowed but functions in a reduced way
+ | CmdLineOnly         -- ^ Flag is only allowed on command line, not in pragma
+ | NeverAllowed        -- ^ Flag isn't allowed at all
+ deriving ( Eq, Ord )
+
+determineSafeLevel :: Bool -> FlagSafety
+determineSafeLevel False = RestrictedFunction
+determineSafeLevel True  = CmdLineOnly
+
+flagA, flagR, flagC, flagN :: String -> OptKind m -> Flag m
+flagA n o = Flag n AlwaysAllowed o
+flagR n o = Flag n RestrictedFunction o
+flagC n o = Flag n CmdLineOnly o
+flagN n o = Flag n NeverAllowed o
+
 -------------------------------
 data OptKind m                      -- Suppose the flag is -f
  = NoArg     (EwM m ())                 -- -f all by itself
hunk ./compiler/main/CmdLineParser.hs 94
 -- EwM (short for "errors and warnings monad") is a
 -- monad transformer for m that adds an (err, warn) state
 newtype EwM m a = EwM { unEwM :: Located String	    -- Current arg
+                              -> FlagSafety         -- arg safety level
+                              -> FlagSafety         -- global safety level
                               -> Errs -> Warns
                               -> m (Errs, Warns, a) }
 
hunk ./compiler/main/CmdLineParser.hs 100
 instance Monad m => Monad (EwM m) where
-  (EwM f) >>= k = EwM (\l e w -> do { (e', w', r) <- f l e w 
-                                    ; unEwM (k r) l e' w' })
-  return v = EwM (\_ e w -> return (e, w, v))
+  (EwM f) >>= k = EwM (\l s c e w -> do { (e', w', r) <- f l s c e w 
+                                    ; unEwM (k r) l s c e' w' })
+  return v = EwM (\_ _ _ e w -> return (e, w, v))
 
hunk ./compiler/main/CmdLineParser.hs 104
-setArg :: Located String -> EwM m a -> EwM m a
-setArg l (EwM f) = EwM (\_ es ws -> f l es ws)
+setArg :: Monad m => Located String -> FlagSafety -> EwM m () -> EwM m ()
+setArg l s (EwM f) = EwM (\_ _ c es ws ->
+    let check | s <= c    = f l s c es ws
+              | otherwise = err l es ws
+        err locArg@(L loc ('-' : arg)) es ws =
+            let msg = "Flag (" ++ arg ++ ") is not allowed in SafeHaskell"
+            in return (es `snocBag` L loc msg, ws, ())
+    in check)
 
 addErr :: Monad m => String -> EwM m ()
hunk ./compiler/main/CmdLineParser.hs 114
-addErr e = EwM (\(L loc _) es ws -> return (es `snocBag` L loc e, ws, ()))
+addErr e = EwM (\(L loc _) _ _ es ws -> return (es `snocBag` L loc e, ws, ()))
 
 addWarn :: Monad m => String -> EwM m ()
hunk ./compiler/main/CmdLineParser.hs 117
-addWarn msg = EwM (\(L loc _) es ws -> return (es, ws `snocBag` L loc w, ()))
+addWarn msg = EwM (\(L loc _) _ _ es ws -> return (es, ws `snocBag` L loc w, ()))
   where
     w = "Warning: " ++ msg
 
hunk ./compiler/main/CmdLineParser.hs 127
        ; addWarn (arg ++ " is deprecated: " ++ s) }
 
 getArg :: Monad m => EwM m String
-getArg = EwM (\(L _ arg) es ws -> return (es, ws, arg))
+getArg = EwM (\(L _ arg) _ _ es ws -> return (es, ws, arg))
 
 liftEwM :: Monad m => m a -> EwM m a
hunk ./compiler/main/CmdLineParser.hs 130
-liftEwM action = EwM (\_ es ws -> do { r <- action; return (es, ws, r) })
+liftEwM action = EwM (\_ _ _ es ws -> do { r <- action; return (es, ws, r) })
 
 -- -----------------------------------------------------------------------------
 -- A state monad for use in the command-line parser
hunk ./compiler/main/CmdLineParser.hs 157
 processArgs :: Monad m
             => [Flag m] -- cmdline parser spec
             -> [Located String]      -- args
+            -> FlagSafety            -- flag clearance lvl
+            -> Bool
             -> m (
                   [Located String],  -- spare args
                   [Located String],  -- errors
hunk ./compiler/main/CmdLineParser.hs 164
                   [Located String]   -- warnings
                  )
-processArgs spec args 
-  = do { (errs, warns, spare) <- unEwM (process args []) 
-                                       (panic "processArgs: no arg yet")
-                                       emptyBag emptyBag 
-       ; return (spare, bagToList errs, bagToList warns) }
+processArgs spec args clvl0 cmdline
+  = let (clvl1, action) = process clvl0 True args []
+    in do { (errs, warns, spare) <- unEwM action (panic "processArgs: no arg yet")
+                                       AlwaysAllowed clvl1 emptyBag emptyBag 
+          ; return (spare, bagToList errs, bagToList warns) }
   where
hunk ./compiler/main/CmdLineParser.hs 170
-    -- process :: [Located String] -> [Located String] -> EwM m [Located String]
-    process [] spare = return (reverse spare)
+    -- process :: FlagSafety -> Bool -> [Located String] -> [Located String] -> (FlagSafety, EwM m [Located String])
+    --
+    process clvl _ [] spare = (clvl, return (reverse spare))
 
hunk ./compiler/main/CmdLineParser.hs 174
-    process (locArg@(L _ ('-' : arg)) : args) spare =
+    process clvl first (locArg@(L _ ('-' : arg)) : args) spare =
       case findArg spec arg of
hunk ./compiler/main/CmdLineParser.hs 176
-        Just (rest, opt_kind) ->
-           case processOneArg opt_kind rest arg args of
-              Left err            -> do { setArg locArg $ addErr err
-                                        ; process args spare }
-              Right (action,rest) -> do { setArg locArg $ action
-                                        ; process rest spare }
-        Nothing -> process args (locArg : spare) 
+        Just (rest, opt_kind, fsafe) ->
+           let clvl1 = if fsafe == EnablesSafe then determineSafeLevel cmdline else clvl
+           in case processOneArg opt_kind rest arg args of
+               Left err ->
+                   let (clvl2,b) = process clvl1 False args spare
+                       clvl3 = min clvl1 clvl2
+                   in (clvl3, (setArg locArg fsafe $ addErr err) >> b)
+
+               Right (action,rest) ->
+                   let (clvl2,b) = process clvl1 False rest spare
+                       clvl3 = min clvl1 clvl2
+                   in (clvl3, (setArg locArg fsafe $ action) >> b)
+
+        Nothing -> process clvl False args (locArg : spare) 
 
hunk ./compiler/main/CmdLineParser.hs 191
-    process (arg : args) spare = process args (arg : spare) 
+    process clvl first (arg : args) spare = process clvl first args (arg : spare) 
 
 
 processOneArg :: OptKind m -> String -> String -> [Located String]
hunk ./compiler/main/CmdLineParser.hs 232
         AnySuffixPred _ f -> Right (f dash_arg, args)
 
 
-findArg :: [Flag m] -> String -> Maybe (String, OptKind m)
+findArg :: [Flag m] -> String -> Maybe (String, OptKind m, FlagSafety)
 findArg spec arg
hunk ./compiler/main/CmdLineParser.hs 234
-  = case [ (removeSpaces rest, optKind)
+  = case [ (removeSpaces rest, optKind, flagSafe)
          | flag <- spec,
hunk ./compiler/main/CmdLineParser.hs 236
-           let optKind = flagOptKind flag,
+           let optKind  = flagOptKind flag,
+           let flagSafe = flagSafety flag,
            Just rest <- [stripPrefix (flagName flag) arg],
            arg_ok optKind rest arg ]
     of
hunk ./compiler/main/DriverPipeline.hs 683
   = do let dflags0 = hsc_dflags hsc_env
        src_opts <- getOptionsFromFile dflags0 input_fn
        (dflags1, unhandled_flags, warns)
-           <- parseDynamicNoPackageFlags dflags0 src_opts
+           <- parseDynamicFilePragma dflags0 src_opts
        checkProcessArgsResult unhandled_flags
 
        if not (xopt Opt_Cpp dflags1) then do
hunk ./compiler/main/DriverPipeline.hs 700
             -- See #2464,#3457
             src_opts <- getOptionsFromFile dflags0 output_fn
             (dflags2, unhandled_flags, warns)
-                <- parseDynamicNoPackageFlags dflags0 src_opts
+                <- parseDynamicFilePragma dflags0 src_opts
             -- the HsPp pass below will emit warnings
             checkProcessArgsResult unhandled_flags
             unless (dopt Opt_Pp dflags2) $ handleFlagWarnings dflags2 warns
hunk ./compiler/main/DriverPipeline.hs 731
             -- re-read pragmas now that we've parsed the file (see #3674)
             src_opts <- getOptionsFromFile dflags output_fn
             (dflags1, unhandled_flags, warns)
-                <- parseDynamicNoPackageFlags dflags src_opts
+                <- parseDynamicFilePragma dflags src_opts
             checkProcessArgsResult unhandled_flags
             handleFlagWarnings dflags1 warns
 
hunk ./compiler/main/DynFlags.hs 40
 
         -- ** SafeHaskell
         SafeHaskellMode(..),
-        safeHaskellOn, safeDirectImpsReq, safeImplicitImpsReq,
+        safeHaskellOn, safeLanguageOn,
+        safeDirectImpsReq, safeImplicitImpsReq,
 
         -- ** Manipulating DynFlags
         defaultDynFlags,                -- DynFlags
hunk ./compiler/main/DynFlags.hs 55
         doingTickyProfiling,
 
         -- ** Parsing DynFlags
-        parseDynamicFlags,
-        parseDynamicNoPackageFlags,
+        parseDynamicFlagsCmdLine,
+        parseDynamicFilePragma,
         allFlags,
 
         supportedLanguagesAndExtensions,
hunk ./compiler/main/DynFlags.hs 649
   | SystemDependent
   deriving Eq
 
-data RtsOptsEnabled = RtsOptsNone | RtsOptsSafeOnly | RtsOptsAll
+data RtsOptsEnabled = RtsOptsNone | RtsOptsSafeOnly | RtsOptsAll deriving ( Eq )
 
 -- | Used by 'GHC.newSession' to partially initialize a new 'DynFlags' value
 initDynFlags :: DynFlags -> IO DynFlags
hunk ./compiler/main/DynFlags.hs 887
                          extensionFlags = flattenExtensionFlags mLang oneoffs
                      }
 
+safeLanguageOn :: DynFlags -> Bool
+safeLanguageOn dflags = s == Sf_SafeLanguage || s == Sf_Safe
+                          where s = safeHaskell dflags
+
 -- | Test if SafeHaskell is on in some form
 safeHaskellOn :: DynFlags -> Bool
 safeHaskellOn dflags = safeHaskell dflags /= Sf_None
hunk ./compiler/main/DynFlags.hs 906
 -- | Are all direct imports required to be safe for this SafeHaskell mode?
 -- Direct imports are when the code explicitly imports a module
 safeDirectImpsReq :: DynFlags -> Bool
-safeDirectImpsReq dflags = s == Sf_SafeLanguage || s == Sf_Safe
-                          where s = safeHaskell dflags
+safeDirectImpsReq = safeLanguageOn
 
 -- | Are all implicit imports required to be safe for this SafeHaskell mode?
 -- Implicit imports are things in the prelude. e.g System.IO when print is used.
hunk ./compiler/main/DynFlags.hs 1038
                       -- transformed (e.g., "/out=")
               String  -- the filepath/filename portion
  | Option     String
+ deriving ( Eq )
 
 showOpt :: Option -> String
 showOpt (FileOption pre f) = pre ++ f
hunk ./compiler/main/DynFlags.hs 1094
 -- the parsed 'DynFlags', the left-over arguments, and a list of warnings.
 -- Throws a 'UsageError' if errors occurred during parsing (such as unknown
 -- flags or missing arguments).
-parseDynamicFlags :: Monad m =>
+parseDynamicFlagsCmdLine :: Monad m =>
                      DynFlags -> [Located String]
                   -> m (DynFlags, [Located String], [Located String])
                      -- ^ Updated 'DynFlags', left-over arguments, and
hunk ./compiler/main/DynFlags.hs 1099
                      -- list of warnings.
-parseDynamicFlags dflags args = parseDynamicFlags_ dflags args True
+parseDynamicFlagsCmdLine dflags args = parseDynamicFlags dflags args True
 
hunk ./compiler/main/DynFlags.hs 1101
--- | Like 'parseDynamicFlags' but does not allow the package flags (-package,
--- -hide-package, -ignore-package, -hide-all-packages, -package-conf).
-parseDynamicNoPackageFlags :: Monad m =>
+-- | Like 'parseDynamicFlagsCmdLine' but does not allow the package flags
+-- (-package, -hide-package, -ignore-package, -hide-all-packages, -package-conf).
+-- Used to parse flags set in a modules pragma.
+parseDynamicFilePragma :: Monad m =>
                      DynFlags -> [Located String]
                   -> m (DynFlags, [Located String], [Located String])
                      -- ^ Updated 'DynFlags', left-over arguments, and
hunk ./compiler/main/DynFlags.hs 1109
                      -- list of warnings.
-parseDynamicNoPackageFlags dflags args = parseDynamicFlags_ dflags args False
+parseDynamicFilePragma dflags args = parseDynamicFlags dflags args False
 
hunk ./compiler/main/DynFlags.hs 1111
-parseDynamicFlags_ :: Monad m =>
+parseDynamicFlags :: Monad m =>
                       DynFlags -> [Located String] -> Bool
                   -> m (DynFlags, [Located String], [Located String])
hunk ./compiler/main/DynFlags.hs 1114
-parseDynamicFlags_ dflags0 args pkg_flags = do
+parseDynamicFlags dflags0 args cmdline = do
   -- XXX Legacy support code
   -- We used to accept things like
   --     optdep-f  -optdepdepend
hunk ./compiler/main/DynFlags.hs 1128
       args' = f args
 
       -- Note: -ignore-package (package_flags) must precede -i* (dynamic_flags)
-      flag_spec | pkg_flags = package_flags ++ dynamic_flags
+      flag_spec | cmdline   = package_flags ++ dynamic_flags
                 | otherwise = dynamic_flags
 
hunk ./compiler/main/DynFlags.hs 1131
+  let safeLevel = if safeLanguageOn dflags0
+                     then determineSafeLevel cmdline else NeverAllowed
   let ((leftover, errs, warns), dflags1)
hunk ./compiler/main/DynFlags.hs 1134
-          = runCmdLine (processArgs flag_spec args') dflags0
+          = runCmdLine (processArgs flag_spec args' safeLevel cmdline) dflags0
   when (not (null errs)) $ ghcError $ errorsToGhcException errs
 
   -- Cannot use -fPIC with registerised -fvia-C, because the mangler
hunk ./compiler/main/DynFlags.hs 1154
                 dflags1{ hscTarget = HscAsm })
 #endif
         | otherwise = ([], dflags1)
+  
+  -- check for disabled flags in safe haskell
+  {-
+  when (safeHaskellOn dflags2) $ do {
+        shFlagsDisallowed dflags2
+      ; when (not cmdline) $ shFlagsCmdLineOnly dflags0 dflags2
+  }
+  -}
 
   return (dflags2, leftover, pic_warns ++ warns)
 
hunk ./compiler/main/DynFlags.hs 1165
+{-
+    -- ALTERNATE SAFE HASKELL CHECK METHOD
+
+-- | Extensions that can't be enabled at all when compiling in Safe mode
+-- checkSafeHaskellFlags :: MonadIO m => DynFlags -> m ()
+shFlagsDisallowed :: Monad m => DynFlags -> m ()
+shFlagsDisallowed dflags = mapM_ check_method bad_flags 
+    where
+        check_method (flag,str)
+            = when (flag dflags) $ safeFailure str
+
+        bad_flags = [(xopt Opt_GeneralizedNewtypeDeriving, "GeneralizedNewtypeDeriving")]
+
+-- | Extensions that can only be enabled on the command line when compiling in
+-- Safe mode
+shFlagsCmdLineOnly :: Monad m => DynFlags -> DynFlags -> m ()
+shFlagsCmdLineOnly oldf newf = mapM_ check_method bad_flags
+    where
+        check_method (test,str) = when test $ safeFailure str
+        
+        ext_test ext = xopt ext newf && not (xopt ext oldf)
+        pgm_test pgm = pgm oldf == pgm newf
+        dyn_test dyn = dopt dyn newf && not (dopt dyn oldf)
+
+        bad_flags = [ (ext_test Opt_TemplateHaskell, "TemplateHaskell")
+                    , (ext_test Opt_Cpp,             "CPP")
+                    , (dyn_test Opt_Pp,              "F")
+
+                    , (pgm_test pgm_lo,              "pgmlo")
+                    , (pgm_test pgm_lc,              "pgmlc")
+                    , (pgm_test pgm_L,               "pgmL")
+                    , (pgm_test pgm_P,               "pgmP")
+                    , (pgm_test pgm_F,               "pgmF")
+                    , (pgm_test pgm_c,               "pgmc")
+                    , (pgm_test pgm_m,               "pgmm")
+                    , (pgm_test pgm_s,               "pgms")
+                    , (pgm_test pgm_a,               "pgma")
+                    , (pgm_test pgm_l,               "pgml")
+                    , (pgm_test pgm_dll,             "pgmdll")
+                    , (pgm_test pgm_windres,         "pgmwindres")
+
+                    , (pgm_test opt_lo,              "optlo")
+                    , (pgm_test opt_lc,              "optlc")
+                    , (pgm_test opt_L,               "optL")
+                    , (pgm_test opt_P,               "optP")
+                    , (pgm_test opt_F,               "optF")
+                    , (pgm_test opt_c,               "optc")
+                    , (pgm_test opt_m,               "optm")
+                    , (pgm_test opt_a,               "opta")
+                    , (pgm_test opt_l,               "optl OR l")
+                    , (pgm_test opt_windres,         "optlwindres")
+
+                    , (pgm_test mainFunIs
+                       && pgm_test mainModIs,        "main-is")
+                    , (pgm_test libraryPaths,        "L")
+                    , (pgm_test dynLibLoader,        "dynload")
+
+                    , (pgm_test hcSuf,               "hcsuf")
+                    , (pgm_test hiSuf,               "hisuf")
+                    , (pgm_test objectSuf,           "osuf")
+                    , (pgm_test hiDir,               "hidir")
+                    , (pgm_test objectDir,           "odir")
+                    , (pgm_test stubDir,             "stubdir")
+                    , (pgm_test outputHi,            "ohi")
+                    , (pgm_test outputFile,          "o")
+                    , (pgm_test tmpDir,              "tmpdir")
+
+                    , (pgm_test includePaths,        "I")
+
+                    , (pgm_test rtsOpts,             "with-rtsopts")
+                    , (pgm_test rtsOptsEnabled,      "rtsopts")
+
+                    , (pgm_test dylibInstallName,    "dylib-install-name")
+                    ]
+
+-- safeFailure :: MonadIO m => String -> m ()
+safeFailure :: Monad m => String -> m ()
+safeFailure s = ghcError $ CmdLineError $ "Illegal extension (" ++ s
+                    ++ ") in use while compiling with Safe Haskell!"
+{-
+  -- prefer this error but circular imports arise.
+  = liftIO $ throwIO $ mkSrcErr $ unitBag $ mkPlainErrMsg noSrcSpan $
+      text "Illegal extension (" <> text s <>
+          text ") in use while compiling with Safe Haskell!"
+-}
+-}
+
 
 {- **********************************************************************
 %*									*
hunk ./compiler/main/DynFlags.hs 1267
            map ("f"++) flags' ++
            map ("X"++) supportedExtensions
     where ok (PrefixPred _ _) = False
-          ok _ = True
-          flags = [ name | (name, _, _) <- fFlags ]
-          flags' = [ name | (name, _, _) <- fLangFlags ]
+          ok _   = True
+          flags  = [ name | (name, _, _, _) <- fFlags ]
+          flags' = [ name | (name, _, _, _) <- fLangFlags ]
 
 --------------- The main flags themselves ------------------
 dynamic_flags :: [Flag (CmdLineP DynFlags)]
hunk ./compiler/main/DynFlags.hs 1274
 dynamic_flags = [
-    Flag "n"        (NoArg (setDynFlag Opt_DryRun))
-  , Flag "cpp"      (NoArg (setExtensionFlag Opt_Cpp)) 
-  , Flag "F"        (NoArg (setDynFlag Opt_Pp)) 
-  , Flag "#include" 
+    flagA "n"        (NoArg (setDynFlag Opt_DryRun))
+  , flagC "cpp"      (NoArg (setExtensionFlag Opt_Cpp)) 
+  , flagC "F"        (NoArg (setDynFlag Opt_Pp)) 
+  , flagA "#include" 
          (HasArg (\s -> do { addCmdlineHCInclude s
                            ; addWarn "-#include and INCLUDE pragmas are deprecated: They no longer have any effect" }))
hunk ./compiler/main/DynFlags.hs 1280
-  , Flag "v"        (OptIntSuffix setVerbosity)
+  , flagA "v"        (OptIntSuffix setVerbosity)
 
         ------- Specific phases  --------------------------------------------
     -- need to appear before -pgmL to be parsed as LLVM flags.
hunk ./compiler/main/DynFlags.hs 1284
-  , Flag "pgmlo"          (hasArg (\f d -> d{ pgm_lo  = (f,[])}))
-  , Flag "pgmlc"          (hasArg (\f d -> d{ pgm_lc  = (f,[])}))
-  , Flag "pgmL"           (hasArg (\f d -> d{ pgm_L   = f}))
-  , Flag "pgmP"           (hasArg setPgmP)
-  , Flag "pgmF"           (hasArg (\f d -> d{ pgm_F   = f}))
-  , Flag "pgmc"           (hasArg (\f d -> d{ pgm_c   = (f,[])}))
-  , Flag "pgmm"           (hasArg (\f d -> d{ pgm_m   = (f,[])}))
-  , Flag "pgms"           (hasArg (\f d -> d{ pgm_s   = (f,[])}))
-  , Flag "pgma"           (hasArg (\f d -> d{ pgm_a   = (f,[])}))
-  , Flag "pgml"           (hasArg (\f d -> d{ pgm_l   = (f,[])}))
-  , Flag "pgmdll"         (hasArg (\f d -> d{ pgm_dll = (f,[])}))
-  , Flag "pgmwindres"     (hasArg (\f d -> d{ pgm_windres = f}))
+  , flagC "pgmlo"          (hasArg (\f d -> d{ pgm_lo  = (f,[])}))
+  , flagC "pgmlc"          (hasArg (\f d -> d{ pgm_lc  = (f,[])}))
+  , flagC "pgmL"           (hasArg (\f d -> d{ pgm_L   = f}))
+  , flagC "pgmP"           (hasArg setPgmP)
+  , flagC "pgmF"           (hasArg (\f d -> d{ pgm_F   = f}))
+  , flagC "pgmc"           (hasArg (\f d -> d{ pgm_c   = (f,[])}))
+  , flagC "pgmm"           (hasArg (\f d -> d{ pgm_m   = (f,[])}))
+  , flagC "pgms"           (hasArg (\f d -> d{ pgm_s   = (f,[])}))
+  , flagC "pgma"           (hasArg (\f d -> d{ pgm_a   = (f,[])}))
+  , flagC "pgml"           (hasArg (\f d -> d{ pgm_l   = (f,[])}))
+  , flagC "pgmdll"         (hasArg (\f d -> d{ pgm_dll = (f,[])}))
+  , flagC "pgmwindres"     (hasArg (\f d -> d{ pgm_windres = f}))
 
     -- need to appear before -optl/-opta to be parsed as LLVM flags.
hunk ./compiler/main/DynFlags.hs 1298
-  , Flag "optlo"          (hasArg (\f d -> d{ opt_lo  = f : opt_lo d}))
-  , Flag "optlc"          (hasArg (\f d -> d{ opt_lc  = f : opt_lc d}))
-  , Flag "optL"           (hasArg (\f d -> d{ opt_L   = f : opt_L d}))
-  , Flag "optP"           (hasArg addOptP)
-  , Flag "optF"           (hasArg (\f d -> d{ opt_F   = f : opt_F d}))
-  , Flag "optc"           (hasArg (\f d -> d{ opt_c   = f : opt_c d}))
-  , Flag "optm"           (hasArg (\f d -> d{ opt_m   = f : opt_m d}))
-  , Flag "opta"           (hasArg (\f d -> d{ opt_a   = f : opt_a d}))
-  , Flag "optl"           (hasArg addOptl)
-  , Flag "optwindres"     (hasArg (\f d -> d{ opt_windres = f : opt_windres d}))
+  , flagC "optlo"          (hasArg (\f d -> d{ opt_lo  = f : opt_lo d}))
+  , flagC "optlc"          (hasArg (\f d -> d{ opt_lc  = f : opt_lc d}))
+  , flagC "optL"           (hasArg (\f d -> d{ opt_L   = f : opt_L d}))
+  , flagC "optP"           (hasArg addOptP)
+  , flagC "optF"           (hasArg (\f d -> d{ opt_F   = f : opt_F d}))
+  , flagC "optc"           (hasArg (\f d -> d{ opt_c   = f : opt_c d}))
+  , flagC "optm"           (hasArg (\f d -> d{ opt_m   = f : opt_m d}))
+  , flagC "opta"           (hasArg (\f d -> d{ opt_a   = f : opt_a d}))
+  , flagC "optl"           (hasArg addOptl)
+  , flagC "optwindres"     (hasArg (\f d -> d{ opt_windres = f : opt_windres d}))
 
hunk ./compiler/main/DynFlags.hs 1309
-  , Flag "split-objs"
+  , flagA "split-objs"
          (NoArg (if can_split 
                  then setDynFlag Opt_SplitObjs
                  else addWarn "ignoring -fsplit-objs"))
hunk ./compiler/main/DynFlags.hs 1315
 
         -------- ghc -M -----------------------------------------------------
-  , Flag "dep-suffix"     (hasArg addDepSuffix)
-  , Flag "optdep-s"       (hasArgDF addDepSuffix "Use -dep-suffix instead")
-  , Flag "dep-makefile"   (hasArg setDepMakefile)
-  , Flag "optdep-f"       (hasArgDF setDepMakefile "Use -dep-makefile instead")
-  , Flag "optdep-w"       (NoArg  (deprecate "doesn't do anything"))
-  , Flag "include-pkg-deps"         (noArg (setDepIncludePkgDeps True))
-  , Flag "optdep--include-prelude"  (noArgDF (setDepIncludePkgDeps True) "Use -include-pkg-deps instead")
-  , Flag "optdep--include-pkg-deps" (noArgDF (setDepIncludePkgDeps True) "Use -include-pkg-deps instead")
-  , Flag "exclude-module"           (hasArg addDepExcludeMod)
-  , Flag "optdep--exclude-module"   (hasArgDF addDepExcludeMod "Use -exclude-module instead")
-  , Flag "optdep-x"                 (hasArgDF addDepExcludeMod "Use -exclude-module instead")
+  , flagA "dep-suffix"     (hasArg addDepSuffix)
+  , flagA "optdep-s"       (hasArgDF addDepSuffix "Use -dep-suffix instead")
+  , flagA "dep-makefile"   (hasArg setDepMakefile)
+  , flagA "optdep-f"       (hasArgDF setDepMakefile "Use -dep-makefile instead")
+  , flagA "optdep-w"       (NoArg  (deprecate "doesn't do anything"))
+  , flagA "include-pkg-deps"         (noArg (setDepIncludePkgDeps True))
+  , flagA "optdep--include-prelude"  (noArgDF (setDepIncludePkgDeps True) "Use -include-pkg-deps instead")
+  , flagA "optdep--include-pkg-deps" (noArgDF (setDepIncludePkgDeps True) "Use -include-pkg-deps instead")
+  , flagA "exclude-module"           (hasArg addDepExcludeMod)
+  , flagA "optdep--exclude-module"   (hasArgDF addDepExcludeMod "Use -exclude-module instead")
+  , flagA "optdep-x"                 (hasArgDF addDepExcludeMod "Use -exclude-module instead")
 
         -------- Linking ----------------------------------------------------
hunk ./compiler/main/DynFlags.hs 1328
-  , Flag "no-link"            (noArg (\d -> d{ ghcLink=NoLink }))
-  , Flag "shared"             (noArg (\d -> d{ ghcLink=LinkDynLib }))
-  , Flag "dynload"            (hasArg parseDynLibLoaderMode)
-  , Flag "dylib-install-name" (hasArg setDylibInstallName)
+  , flagA "no-link"            (noArg (\d -> d{ ghcLink=NoLink }))
+  , flagA "shared"             (noArg (\d -> d{ ghcLink=LinkDynLib }))
+  , flagC "dynload"            (hasArg parseDynLibLoaderMode)
+  , flagC "dylib-install-name" (hasArg setDylibInstallName)
 
         ------- Libraries ---------------------------------------------------
hunk ./compiler/main/DynFlags.hs 1334
-  , Flag "L"   (Prefix    addLibraryPath)
-  , Flag "l"   (AnySuffix (upd . addOptl))
+  , flagC "L"   (Prefix    addLibraryPath)
+  , flagC "l"   (AnySuffix (upd . addOptl))
 
         ------- Frameworks --------------------------------------------------
         -- -framework-path should really be -F ...
hunk ./compiler/main/DynFlags.hs 1339
-  , Flag "framework-path" (HasArg addFrameworkPath)
-  , Flag "framework"      (hasArg addCmdlineFramework)
+  , flagC "framework-path" (HasArg addFrameworkPath)
+  , flagC "framework"      (hasArg addCmdlineFramework)
 
         ------- Output Redirection ------------------------------------------
hunk ./compiler/main/DynFlags.hs 1343
-  , Flag "odir"              (hasArg setObjectDir)
-  , Flag "o"                 (SepArg (upd . setOutputFile . Just))
-  , Flag "ohi"               (hasArg (setOutputHi . Just ))
-  , Flag "osuf"              (hasArg setObjectSuf)
-  , Flag "hcsuf"             (hasArg setHcSuf)
-  , Flag "hisuf"             (hasArg setHiSuf)
-  , Flag "hidir"             (hasArg setHiDir)
-  , Flag "tmpdir"            (hasArg setTmpDir)
-  , Flag "stubdir"           (hasArg setStubDir)
-  , Flag "outputdir"         (hasArg setOutputDir)
-  , Flag "ddump-file-prefix" (hasArg (setDumpPrefixForce . Just))
+  , flagC "odir"              (hasArg setObjectDir)
+  , flagC "o"                 (SepArg (upd . setOutputFile . Just))
+  , flagC "ohi"               (hasArg (setOutputHi . Just ))
+  , flagC "osuf"              (hasArg setObjectSuf)
+  , flagC "hcsuf"             (hasArg setHcSuf)
+  , flagC "hisuf"             (hasArg setHiSuf)
+  , flagC "hidir"             (hasArg setHiDir)
+  , flagC "tmpdir"            (hasArg setTmpDir)
+  , flagC "stubdir"           (hasArg setStubDir)
+  , flagC "outputdir"         (hasArg setOutputDir)
+  , flagC "ddump-file-prefix" (hasArg (setDumpPrefixForce . Just))
 
         ------- Keeping temporary files -------------------------------------
      -- These can be singular (think ghc -c) or plural (think ghc --make)
hunk ./compiler/main/DynFlags.hs 1357
-  , Flag "keep-hc-file"     (NoArg (setDynFlag Opt_KeepHcFiles))
-  , Flag "keep-hc-files"    (NoArg (setDynFlag Opt_KeepHcFiles))
-  , Flag "keep-s-file"      (NoArg (setDynFlag Opt_KeepSFiles))
-  , Flag "keep-s-files"     (NoArg (setDynFlag Opt_KeepSFiles))
-  , Flag "keep-raw-s-file"  (NoArg (setDynFlag Opt_KeepRawSFiles))
-  , Flag "keep-raw-s-files" (NoArg (setDynFlag Opt_KeepRawSFiles))
-  , Flag "keep-llvm-file"   (NoArg (setDynFlag Opt_KeepLlvmFiles))
-  , Flag "keep-llvm-files"  (NoArg (setDynFlag Opt_KeepLlvmFiles))
+  , flagA "keep-hc-file"     (NoArg (setDynFlag Opt_KeepHcFiles))
+  , flagA "keep-hc-files"    (NoArg (setDynFlag Opt_KeepHcFiles))
+  , flagA "keep-s-file"      (NoArg (setDynFlag Opt_KeepSFiles))
+  , flagA "keep-s-files"     (NoArg (setDynFlag Opt_KeepSFiles))
+  , flagA "keep-raw-s-file"  (NoArg (setDynFlag Opt_KeepRawSFiles))
+  , flagA "keep-raw-s-files" (NoArg (setDynFlag Opt_KeepRawSFiles))
+  , flagA "keep-llvm-file"   (NoArg (setDynFlag Opt_KeepLlvmFiles))
+  , flagA "keep-llvm-files"  (NoArg (setDynFlag Opt_KeepLlvmFiles))
      -- This only makes sense as plural
hunk ./compiler/main/DynFlags.hs 1366
-  , Flag "keep-tmp-files"   (NoArg (setDynFlag Opt_KeepTmpFiles))
+  , flagA "keep-tmp-files"   (NoArg (setDynFlag Opt_KeepTmpFiles))
 
         ------- Miscellaneous ----------------------------------------------
hunk ./compiler/main/DynFlags.hs 1369
-  , Flag "no-auto-link-packages" (NoArg (unSetDynFlag Opt_AutoLinkPackages))
-  , Flag "no-hs-main"     (NoArg (setDynFlag Opt_NoHsMain))
-  , Flag "with-rtsopts"   (HasArg setRtsOpts)
-  , Flag "rtsopts"        (NoArg (setRtsOptsEnabled RtsOptsAll))
-  , Flag "rtsopts=all"    (NoArg (setRtsOptsEnabled RtsOptsAll))
-  , Flag "rtsopts=some"   (NoArg (setRtsOptsEnabled RtsOptsSafeOnly))
-  , Flag "rtsopts=none"   (NoArg (setRtsOptsEnabled RtsOptsNone))
-  , Flag "no-rtsopts"     (NoArg (setRtsOptsEnabled RtsOptsNone))
-  , Flag "main-is"        (SepArg setMainIs)
-  , Flag "haddock"        (NoArg (setDynFlag Opt_Haddock))
-  , Flag "haddock-opts"   (hasArg addHaddockOpts)
-  , Flag "hpcdir"         (SepArg setOptHpcDir)
+  , flagA "no-auto-link-packages" (NoArg (unSetDynFlag Opt_AutoLinkPackages))
+  , flagA "no-hs-main"     (NoArg (setDynFlag Opt_NoHsMain))
+  , flagC "with-rtsopts"   (HasArg setRtsOpts)
+  , flagC "rtsopts"        (NoArg (setRtsOptsEnabled RtsOptsAll))
+  , flagC "rtsopts=all"    (NoArg (setRtsOptsEnabled RtsOptsAll))
+  , flagC "rtsopts=some"   (NoArg (setRtsOptsEnabled RtsOptsSafeOnly))
+  , flagC "rtsopts=none"   (NoArg (setRtsOptsEnabled RtsOptsNone))
+  , flagA "no-rtsopts"     (NoArg (setRtsOptsEnabled RtsOptsNone))
+  , flagC "main-is"        (SepArg setMainIs)
+  , flagA "haddock"        (NoArg (setDynFlag Opt_Haddock))
+  , flagA "haddock-opts"   (hasArg addHaddockOpts)
+  , flagA "hpcdir"         (SepArg setOptHpcDir)
 
         ------- recompilation checker --------------------------------------
hunk ./compiler/main/DynFlags.hs 1383
-  , Flag "recomp"         (NoArg (do { unSetDynFlag Opt_ForceRecomp
+  , flagA "recomp"         (NoArg (do { unSetDynFlag Opt_ForceRecomp
                                      ; deprecate "Use -fno-force-recomp instead" }))
hunk ./compiler/main/DynFlags.hs 1385
-  , Flag "no-recomp"      (NoArg (do { setDynFlag Opt_ForceRecomp
+  , flagA "no-recomp"      (NoArg (do { setDynFlag Opt_ForceRecomp
                                      ; deprecate "Use -fforce-recomp instead" }))
 
         ------ HsCpp opts ---------------------------------------------------
hunk ./compiler/main/DynFlags.hs 1389
-  , Flag "D"              (AnySuffix (upd . addOptP))
-  , Flag "U"              (AnySuffix (upd . addOptP))
+  , flagC "D"              (AnySuffix (upd . addOptP))
+  , flagC "U"              (AnySuffix (upd . addOptP))
 
         ------- Include/Import Paths ----------------------------------------
hunk ./compiler/main/DynFlags.hs 1393
-  , Flag "I"              (Prefix    addIncludePath)
-  , Flag "i"              (OptPrefix addImportPath)
+  , flagC "I"              (Prefix    addIncludePath)
+  , flagC "i"              (OptPrefix addImportPath)
 
         ------ Debugging ----------------------------------------------------
hunk ./compiler/main/DynFlags.hs 1397
-  , Flag "dstg-stats"     (NoArg (setDynFlag Opt_StgStats))
+  , flagA "dstg-stats"     (NoArg (setDynFlag Opt_StgStats))
 
hunk ./compiler/main/DynFlags.hs 1399
-  , Flag "ddump-cmm"               (setDumpFlag Opt_D_dump_cmm)
-  , Flag "ddump-cmmz"              (setDumpFlag Opt_D_dump_cmmz)
-  , Flag "ddump-cmmz-pretty"       (setDumpFlag Opt_D_dump_cmmz_pretty)
-  , Flag "ddump-cps-cmm"           (setDumpFlag Opt_D_dump_cps_cmm)
-  , Flag "ddump-cvt-cmm"           (setDumpFlag Opt_D_dump_cvt_cmm)
-  , Flag "ddump-asm"               (setDumpFlag Opt_D_dump_asm)
-  , Flag "ddump-asm-native"        (setDumpFlag Opt_D_dump_asm_native)
-  , Flag "ddump-asm-liveness"      (setDumpFlag Opt_D_dump_asm_liveness)
-  , Flag "ddump-asm-coalesce"      (setDumpFlag Opt_D_dump_asm_coalesce)
-  , Flag "ddump-asm-regalloc"      (setDumpFlag Opt_D_dump_asm_regalloc)
-  , Flag "ddump-asm-conflicts"     (setDumpFlag Opt_D_dump_asm_conflicts)
-  , Flag "ddump-asm-regalloc-stages" (setDumpFlag Opt_D_dump_asm_regalloc_stages)
-  , Flag "ddump-asm-stats"         (setDumpFlag Opt_D_dump_asm_stats)
-  , Flag "ddump-asm-expanded"      (setDumpFlag Opt_D_dump_asm_expanded)
-  , Flag "ddump-llvm"              (NoArg (do { setObjTarget HscLlvm
+  , flagA "ddump-cmm"               (setDumpFlag Opt_D_dump_cmm)
+  , flagA "ddump-cmmz"              (setDumpFlag Opt_D_dump_cmmz)
+  , flagA "ddump-cmmz-pretty"       (setDumpFlag Opt_D_dump_cmmz_pretty)
+  , flagA "ddump-cps-cmm"           (setDumpFlag Opt_D_dump_cps_cmm)
+  , flagA "ddump-cvt-cmm"           (setDumpFlag Opt_D_dump_cvt_cmm)
+  , flagA "ddump-asm"               (setDumpFlag Opt_D_dump_asm)
+  , flagA "ddump-asm-native"        (setDumpFlag Opt_D_dump_asm_native)
+  , flagA "ddump-asm-liveness"      (setDumpFlag Opt_D_dump_asm_liveness)
+  , flagA "ddump-asm-coalesce"      (setDumpFlag Opt_D_dump_asm_coalesce)
+  , flagA "ddump-asm-regalloc"      (setDumpFlag Opt_D_dump_asm_regalloc)
+  , flagA "ddump-asm-conflicts"     (setDumpFlag Opt_D_dump_asm_conflicts)
+  , flagA "ddump-asm-regalloc-stages" (setDumpFlag Opt_D_dump_asm_regalloc_stages)
+  , flagA "ddump-asm-stats"         (setDumpFlag Opt_D_dump_asm_stats)
+  , flagA "ddump-asm-expanded"      (setDumpFlag Opt_D_dump_asm_expanded)
+  , flagA "ddump-llvm"              (NoArg (do { setObjTarget HscLlvm
                                               ; setDumpFlag' Opt_D_dump_llvm}))
hunk ./compiler/main/DynFlags.hs 1415
-  , Flag "ddump-cpranal"           (setDumpFlag Opt_D_dump_cpranal)
-  , Flag "ddump-deriv"             (setDumpFlag Opt_D_dump_deriv)
-  , Flag "ddump-ds"                (setDumpFlag Opt_D_dump_ds)
-  , Flag "ddump-flatC"             (setDumpFlag Opt_D_dump_flatC)
-  , Flag "ddump-foreign"           (setDumpFlag Opt_D_dump_foreign)
-  , Flag "ddump-inlinings"         (setDumpFlag Opt_D_dump_inlinings)
-  , Flag "ddump-rule-firings"      (setDumpFlag Opt_D_dump_rule_firings)
-  , Flag "ddump-rule-rewrites"     (setDumpFlag Opt_D_dump_rule_rewrites)
-  , Flag "ddump-occur-anal"        (setDumpFlag Opt_D_dump_occur_anal)
-  , Flag "ddump-parsed"            (setDumpFlag Opt_D_dump_parsed)
-  , Flag "ddump-rn"                (setDumpFlag Opt_D_dump_rn)
-  , Flag "ddump-simpl"             (setDumpFlag Opt_D_dump_simpl)
-  , Flag "ddump-simpl-iterations"  (setDumpFlag Opt_D_dump_simpl_iterations)
-  , Flag "ddump-simpl-phases"      (OptPrefix setDumpSimplPhases)
-  , Flag "ddump-spec"              (setDumpFlag Opt_D_dump_spec)
-  , Flag "ddump-prep"              (setDumpFlag Opt_D_dump_prep)
-  , Flag "ddump-stg"               (setDumpFlag Opt_D_dump_stg)
-  , Flag "ddump-stranal"           (setDumpFlag Opt_D_dump_stranal)
-  , Flag "ddump-tc"                (setDumpFlag Opt_D_dump_tc)
-  , Flag "ddump-types"             (setDumpFlag Opt_D_dump_types)
-  , Flag "ddump-rules"             (setDumpFlag Opt_D_dump_rules)
-  , Flag "ddump-cse"               (setDumpFlag Opt_D_dump_cse)
-  , Flag "ddump-worker-wrapper"    (setDumpFlag Opt_D_dump_worker_wrapper)
-  , Flag "ddump-rn-trace"          (setDumpFlag Opt_D_dump_rn_trace)
-  , Flag "ddump-if-trace"          (setDumpFlag Opt_D_dump_if_trace)
-  , Flag "ddump-tc-trace"          (setDumpFlag Opt_D_dump_tc_trace)
-  , Flag "ddump-splices"           (setDumpFlag Opt_D_dump_splices)
-  , Flag "ddump-rn-stats"          (setDumpFlag Opt_D_dump_rn_stats)
-  , Flag "ddump-opt-cmm"           (setDumpFlag Opt_D_dump_opt_cmm)
-  , Flag "ddump-simpl-stats"       (setDumpFlag Opt_D_dump_simpl_stats)
-  , Flag "ddump-bcos"              (setDumpFlag Opt_D_dump_BCOs)
-  , Flag "dsource-stats"           (setDumpFlag Opt_D_source_stats)
-  , Flag "dverbose-core2core"      (NoArg (do { setVerbosity (Just 2)
-                                              ; setVerboseCore2Core }))
-  , Flag "dverbose-stg2stg"        (setDumpFlag Opt_D_verbose_stg2stg)
-  , Flag "ddump-hi"                (setDumpFlag Opt_D_dump_hi)
-  , Flag "ddump-minimal-imports"   (setDumpFlag Opt_D_dump_minimal_imports)
-  , Flag "ddump-vect"              (setDumpFlag Opt_D_dump_vect)
-  , Flag "ddump-hpc"               (setDumpFlag Opt_D_dump_hpc)
-  , Flag "ddump-mod-cycles"        (setDumpFlag Opt_D_dump_mod_cycles)
-  , Flag "ddump-view-pattern-commoning" (setDumpFlag Opt_D_dump_view_pattern_commoning)
-  , Flag "ddump-to-file"           (setDumpFlag Opt_DumpToFile)
-  , Flag "ddump-hi-diffs"          (setDumpFlag Opt_D_dump_hi_diffs)
-  , Flag "ddump-rtti"      	   (setDumpFlag Opt_D_dump_rtti)
-  , Flag "dcore-lint"              (NoArg (setDynFlag Opt_DoCoreLinting))
-  , Flag "dstg-lint"               (NoArg (setDynFlag Opt_DoStgLinting))
-  , Flag "dcmm-lint"               (NoArg (setDynFlag Opt_DoCmmLinting))
-  , Flag "dasm-lint"               (NoArg (setDynFlag Opt_DoAsmLinting))
-  , Flag "dshow-passes"            (NoArg (do forceRecompile
-                                              setVerbosity (Just 2)))
-  , Flag "dfaststring-stats"       (NoArg (setDynFlag Opt_D_faststring_stats))
+  , flagA "ddump-cpranal"           (setDumpFlag Opt_D_dump_cpranal)
+  , flagA "ddump-deriv"             (setDumpFlag Opt_D_dump_deriv)
+  , flagA "ddump-ds"                (setDumpFlag Opt_D_dump_ds)
+  , flagA "ddump-flatC"             (setDumpFlag Opt_D_dump_flatC)
+  , flagA "ddump-foreign"           (setDumpFlag Opt_D_dump_foreign)
+  , flagA "ddump-inlinings"         (setDumpFlag Opt_D_dump_inlinings)
+  , flagA "ddump-rule-firings"      (setDumpFlag Opt_D_dump_rule_firings)
+  , flagA "ddump-rule-rewrites"     (setDumpFlag Opt_D_dump_rule_rewrites)
+  , flagA "ddump-occur-anal"        (setDumpFlag Opt_D_dump_occur_anal)
+  , flagA "ddump-parsed"            (setDumpFlag Opt_D_dump_parsed)
+  , flagA "ddump-rn"                (setDumpFlag Opt_D_dump_rn)
+  , flagA "ddump-simpl"             (setDumpFlag Opt_D_dump_simpl)
+  , flagA "ddump-simpl-iterations"  (setDumpFlag Opt_D_dump_simpl_iterations)
+  , flagA "ddump-simpl-phases"      (OptPrefix setDumpSimplPhases)
+  , flagA "ddump-spec"              (setDumpFlag Opt_D_dump_spec)
+  , flagA "ddump-prep"              (setDumpFlag Opt_D_dump_prep)
+  , flagA "ddump-stg"               (setDumpFlag Opt_D_dump_stg)
+  , flagA "ddump-stranal"           (setDumpFlag Opt_D_dump_stranal)
+  , flagA "ddump-tc"                (setDumpFlag Opt_D_dump_tc)
+  , flagA "ddump-types"             (setDumpFlag Opt_D_dump_types)
+  , flagA "ddump-rules"             (setDumpFlag Opt_D_dump_rules)
+  , flagA "ddump-cse"               (setDumpFlag Opt_D_dump_cse)
+  , flagA "ddump-worker-wrapper"    (setDumpFlag Opt_D_dump_worker_wrapper)
+  , flagA "ddump-rn-trace"          (setDumpFlag Opt_D_dump_rn_trace)
+  , flagA "ddump-if-trace"          (setDumpFlag Opt_D_dump_if_trace)
+  , flagA "ddump-tc-trace"          (setDumpFlag Opt_D_dump_tc_trace)
+  , flagA "ddump-splices"           (setDumpFlag Opt_D_dump_splices)
+  , flagA "ddump-rn-stats"          (setDumpFlag Opt_D_dump_rn_stats)
+  , flagA "ddump-opt-cmm"           (setDumpFlag Opt_D_dump_opt_cmm)
+  , flagA "ddump-simpl-stats"       (setDumpFlag Opt_D_dump_simpl_stats)
+  , flagA "ddump-bcos"              (setDumpFlag Opt_D_dump_BCOs)
+  , flagA "dsource-stats"           (setDumpFlag Opt_D_source_stats)
+  , flagA "dverbose-core2core"      (NoArg (do { setVerbosity (Just 2)
+                                               ; setVerboseCore2Core }))
+  , flagA "dverbose-stg2stg"        (setDumpFlag Opt_D_verbose_stg2stg)
+  , flagA "ddump-hi"                (setDumpFlag Opt_D_dump_hi)
+  , flagA "ddump-minimal-imports"   (setDumpFlag Opt_D_dump_minimal_imports)
+  , flagA "ddump-vect"              (setDumpFlag Opt_D_dump_vect)
+  , flagA "ddump-hpc"               (setDumpFlag Opt_D_dump_hpc)
+  , flagA "ddump-mod-cycles"        (setDumpFlag Opt_D_dump_mod_cycles)
+  , flagA "ddump-view-pattern-commoning" (setDumpFlag Opt_D_dump_view_pattern_commoning)
+  , flagA "ddump-to-file"           (setDumpFlag Opt_DumpToFile)
+  , flagA "ddump-hi-diffs"          (setDumpFlag Opt_D_dump_hi_diffs)
+  , flagA "ddump-rtti"      	    (setDumpFlag Opt_D_dump_rtti)
+  , flagA "dcore-lint"              (NoArg (setDynFlag Opt_DoCoreLinting))
+  , flagA "dstg-lint"               (NoArg (setDynFlag Opt_DoStgLinting))
+  , flagA "dcmm-lint"               (NoArg (setDynFlag Opt_DoCmmLinting))
+  , flagA "dasm-lint"               (NoArg (setDynFlag Opt_DoAsmLinting))
+  , flagA "dshow-passes"            (NoArg (do { forceRecompile
+                                               ; setVerbosity (Just 2) }))
+  , flagA "dfaststring-stats"       (NoArg (setDynFlag Opt_D_faststring_stats))
 
         ------ Machine dependant (-m<blah>) stuff ---------------------------
 
hunk ./compiler/main/DynFlags.hs 1469
-  , Flag "monly-2-regs" (noArg (\s -> s{stolen_x86_regs = 2}))
-  , Flag "monly-3-regs" (noArg (\s -> s{stolen_x86_regs = 3}))
-  , Flag "monly-4-regs" (noArg (\s -> s{stolen_x86_regs = 4}))
-  , Flag "msse2"        (NoArg (setDynFlag Opt_SSE2))
+  , flagA "monly-2-regs" (noArg (\s -> s{stolen_x86_regs = 2}))
+  , flagA "monly-3-regs" (noArg (\s -> s{stolen_x86_regs = 3}))
+  , flagA "monly-4-regs" (noArg (\s -> s{stolen_x86_regs = 4}))
+  , flagA "msse2"        (NoArg (setDynFlag Opt_SSE2))
 
      ------ Warning opts -------------------------------------------------
hunk ./compiler/main/DynFlags.hs 1475
-  , Flag "W"      (NoArg (mapM_ setDynFlag   minusWOpts))
-  , Flag "Werror" (NoArg (setDynFlag         Opt_WarnIsError))
-  , Flag "Wwarn"  (NoArg (unSetDynFlag       Opt_WarnIsError))
-  , Flag "Wall"   (NoArg (mapM_ setDynFlag   minusWallOpts))
-  , Flag "Wnot"   (NoArg (do { mapM_ unSetDynFlag minusWallOpts
-                             ; deprecate "Use -w instead" }))
-  , Flag "w"      (NoArg (mapM_ unSetDynFlag minuswRemovesOpts))
+  , flagA "W"      (NoArg (mapM_ setDynFlag   minusWOpts))
+  , flagA "Werror" (NoArg (setDynFlag         Opt_WarnIsError))
+  , flagA "Wwarn"  (NoArg (unSetDynFlag       Opt_WarnIsError))
+  , flagA "Wall"   (NoArg (mapM_ setDynFlag   minusWallOpts))
+  , flagA "Wnot"   (NoArg (do { mapM_ unSetDynFlag minusWallOpts
+                              ; deprecate "Use -w instead" }))
+  , flagA "w"      (NoArg (mapM_ unSetDynFlag minuswRemovesOpts))
 
         ------ Optimisation flags ------------------------------------------
hunk ./compiler/main/DynFlags.hs 1484
-  , Flag "O"      (noArg (setOptLevel 1))
-  , Flag "Onot"   (noArgDF (setOptLevel 0) "Use -O0 instead")
-  , Flag "Odph"   (noArg setDPHOpt)
-  , Flag "O"      (OptIntSuffix (\mb_n -> upd (setOptLevel (mb_n `orElse` 1))))
+  , flagA "O"      (noArg (setOptLevel 1))
+  , flagA "Onot"   (noArgDF (setOptLevel 0) "Use -O0 instead")
+  , flagA "Odph"   (noArg setDPHOpt)
+  , flagA "O"      (OptIntSuffix (\mb_n -> upd (setOptLevel (mb_n `orElse` 1))))
                 -- If the number is missing, use 1
 
hunk ./compiler/main/DynFlags.hs 1490
-  , Flag "fsimplifier-phases"          (intSuffix (\n d -> d{ simplPhases = n }))
-  , Flag "fmax-simplifier-iterations"  (intSuffix (\n d -> d{ maxSimplIterations = n }))
-  , Flag "fspec-constr-threshold"      (intSuffix (\n d -> d{ specConstrThreshold = Just n }))
-  , Flag "fno-spec-constr-threshold"   (noArg (\d -> d{ specConstrThreshold = Nothing }))
-  , Flag "fspec-constr-count"          (intSuffix (\n d -> d{ specConstrCount = Just n }))
-  , Flag "fno-spec-constr-count"       (noArg (\d -> d{ specConstrCount = Nothing }))
-  , Flag "fliberate-case-threshold"    (intSuffix (\n d -> d{ liberateCaseThreshold = Just n }))
-  , Flag "fno-liberate-case-threshold" (noArg (\d -> d{ liberateCaseThreshold = Nothing }))
-  , Flag "frule-check"                 (SepArg (\s -> upd (\d -> d{ ruleCheck = Just s })))
-  , Flag "fcontext-stack"              (intSuffix (\n d -> d{ ctxtStkDepth = n }))
-  , Flag "fstrictness-before"          (intSuffix (\n d -> d{ strictnessBefore = n : strictnessBefore d }))
-  , Flag "ffloat-lam-args"             (intSuffix (\n d -> d{ floatLamArgs = Just n }))
-  , Flag "ffloat-all-lams"             (intSuffix (\n d -> d{ floatLamArgs = Nothing }))
+  , flagA "fsimplifier-phases"          (intSuffix (\n d -> d{ simplPhases = n }))
+  , flagA "fmax-simplifier-iterations"  (intSuffix (\n d -> d{ maxSimplIterations = n }))
+  , flagA "fspec-constr-threshold"      (intSuffix (\n d -> d{ specConstrThreshold = Just n }))
+  , flagA "fno-spec-constr-threshold"   (noArg (\d -> d{ specConstrThreshold = Nothing }))
+  , flagA "fspec-constr-count"          (intSuffix (\n d -> d{ specConstrCount = Just n }))
+  , flagA "fno-spec-constr-count"       (noArg (\d -> d{ specConstrCount = Nothing }))
+  , flagA "fliberate-case-threshold"    (intSuffix (\n d -> d{ liberateCaseThreshold = Just n }))
+  , flagA "fno-liberate-case-threshold" (noArg (\d -> d{ liberateCaseThreshold = Nothing }))
+  , flagA "frule-check"                 (SepArg (\s -> upd (\d -> d{ ruleCheck = Just s })))
+  , flagA "fcontext-stack"              (intSuffix (\n d -> d{ ctxtStkDepth = n }))
+  , flagA "fstrictness-before"          (intSuffix (\n d -> d{ strictnessBefore = n : strictnessBefore d }))
+  , flagA "ffloat-lam-args"             (intSuffix (\n d -> d{ floatLamArgs = Just n }))
+  , flagA "ffloat-all-lams"             (intSuffix (\n d -> d{ floatLamArgs = Nothing }))
 
         ------ Profiling ----------------------------------------------------
 
hunk ./compiler/main/DynFlags.hs 1508
   -- XXX Should the -f* flags be deprecated?
   -- They don't seem to be documented
-  , Flag "fauto-sccs-on-all-toplevs"   	   (NoArg (setDynFlag Opt_AutoSccsOnAllToplevs))
-  , Flag "auto-all"                    	   (NoArg (setDynFlag Opt_AutoSccsOnAllToplevs))
-  , Flag "no-auto-all"                 	   (NoArg (unSetDynFlag Opt_AutoSccsOnAllToplevs))
-  , Flag "fauto-sccs-on-exported-toplevs"  (NoArg (setDynFlag Opt_AutoSccsOnExportedToplevs))
-  , Flag "auto"                            (NoArg (setDynFlag Opt_AutoSccsOnExportedToplevs))
-  , Flag "no-auto"                         (NoArg (unSetDynFlag Opt_AutoSccsOnExportedToplevs))
-  , Flag "fauto-sccs-on-individual-cafs"   (NoArg (setDynFlag Opt_AutoSccsOnIndividualCafs))
-  , Flag "caf-all"                         (NoArg (setDynFlag Opt_AutoSccsOnIndividualCafs))
-  , Flag "no-caf-all"                      (NoArg (unSetDynFlag Opt_AutoSccsOnIndividualCafs))
+  , flagA "fauto-sccs-on-all-toplevs"   	   (NoArg (setDynFlag Opt_AutoSccsOnAllToplevs))
+  , flagA "auto-all"                    	   (NoArg (setDynFlag Opt_AutoSccsOnAllToplevs))
+  , flagA "no-auto-all"                 	   (NoArg (unSetDynFlag Opt_AutoSccsOnAllToplevs))
+  , flagA "fauto-sccs-on-exported-toplevs"  (NoArg (setDynFlag Opt_AutoSccsOnExportedToplevs))
+  , flagA "auto"                            (NoArg (setDynFlag Opt_AutoSccsOnExportedToplevs))
+  , flagA "no-auto"                         (NoArg (unSetDynFlag Opt_AutoSccsOnExportedToplevs))
+  , flagA "fauto-sccs-on-individual-cafs"   (NoArg (setDynFlag Opt_AutoSccsOnIndividualCafs))
+  , flagA "caf-all"                         (NoArg (setDynFlag Opt_AutoSccsOnIndividualCafs))
+  , flagA "no-caf-all"                      (NoArg (unSetDynFlag Opt_AutoSccsOnIndividualCafs))
 
         ------ DPH flags ----------------------------------------------------
 
hunk ./compiler/main/DynFlags.hs 1520
-  , Flag "fdph-seq"         (NoArg (setDPHBackend DPHSeq))
-  , Flag "fdph-par"         (NoArg (setDPHBackend DPHPar))
-  , Flag "fdph-this"        (NoArg (setDPHBackend DPHThis))
-  , Flag "fdph-none"        (NoArg (setDPHBackend DPHNone))
+  , flagA "fdph-seq"         (NoArg (setDPHBackend DPHSeq))
+  , flagA "fdph-par"         (NoArg (setDPHBackend DPHPar))
+  , flagA "fdph-this"        (NoArg (setDPHBackend DPHThis))
+  , flagA "fdph-none"        (NoArg (setDPHBackend DPHNone))
 
         ------ Compiler flags -----------------------------------------------
 
hunk ./compiler/main/DynFlags.hs 1527
-  , Flag "fasm"             (NoArg (setObjTarget HscAsm))
-  , Flag "fvia-c"           (NoArg (setObjTarget HscC >>
-         (addWarn "The -fvia-c flag will be removed in a future GHC release")))
-  , Flag "fvia-C"           (NoArg (setObjTarget HscC >>
-         (addWarn "The -fvia-C flag will be removed in a future GHC release")))
-  , Flag "fllvm"            (NoArg (setObjTarget HscLlvm))
+  , flagA "fasm"             (NoArg (setObjTarget HscAsm))
+  , flagA "fvia-c"           (NoArg (setObjTarget HscC >>
+          (addWarn "The -fvia-c flag will be removed in a future GHC release")))
+  , flagA "fvia-C"           (NoArg (setObjTarget HscC >>
+          (addWarn "The -fvia-C flag will be removed in a future GHC release")))
+  , flagA "fllvm"            (NoArg (setObjTarget HscLlvm))
 
hunk ./compiler/main/DynFlags.hs 1534
-  , Flag "fno-code"         (NoArg (do upd $ \d -> d{ ghcLink=NoLink }
-                                       setTarget HscNothing))
-  , Flag "fbyte-code"       (NoArg (setTarget HscInterpreted))
-  , Flag "fobject-code"     (NoArg (setTarget defaultHscTarget))
-  , Flag "fglasgow-exts"    (NoArg (enableGlasgowExts >> deprecate "Use individual extensions instead"))
-  , Flag "fno-glasgow-exts" (NoArg (disableGlasgowExts >> deprecate "Use individual extensions instead"))
+  , flagA "fno-code"         (NoArg (do { upd $ \d -> d{ ghcLink=NoLink }
+                                        ; setTarget HscNothing }))
+  , flagA "fbyte-code"       (NoArg (setTarget HscInterpreted))
+  , flagA "fobject-code"     (NoArg (setTarget defaultHscTarget))
+  , flagN "fglasgow-exts"    (NoArg (enableGlasgowExts >> deprecate "Use individual extensions instead"))
+  , flagN "fno-glasgow-exts" (NoArg (disableGlasgowExts >> deprecate "Use individual extensions instead"))
  ]
  ++ map (mkFlag turnOn  "f"    setDynFlag  ) fFlags
  ++ map (mkFlag turnOff "fno-" unSetDynFlag) fFlags
hunk ./compiler/main/DynFlags.hs 1553
 package_flags :: [Flag (CmdLineP DynFlags)]
 package_flags = [
         ------- Packages ----------------------------------------------------
-    Flag "package-conf"         (HasArg extraPkgConf_)
-  , Flag "no-user-package-conf" (NoArg (unSetDynFlag Opt_ReadUserPackageConf))
-  , Flag "package-name"      	(hasArg setPackageName)
-  , Flag "package-id"        	(HasArg exposePackageId)
-  , Flag "package"           	(HasArg exposePackage)
-  , Flag "hide-package"      	(HasArg hidePackage)
-  , Flag "hide-all-packages" 	(NoArg (setDynFlag Opt_HideAllPackages))
-  , Flag "ignore-package"    	(HasArg ignorePackage)
-  , Flag "syslib"            	(HasArg (\s -> do { exposePackage s
-                                                  ; deprecate "Use -package instead" }))
+    flagC "package-conf"         (HasArg extraPkgConf_)
+  , flagC "no-user-package-conf" (NoArg (unSetDynFlag Opt_ReadUserPackageConf))
+  , flagC "package-name"      	 (hasArg setPackageName)
+  , flagC "package-id"        	 (HasArg exposePackageId)
+  , flagC "package"           	 (HasArg exposePackage)
+  , flagC "hide-package"      	 (HasArg hidePackage)
+  , flagC "hide-all-packages" 	 (NoArg (setDynFlag Opt_HideAllPackages))
+  , flagC "ignore-package"    	 (HasArg ignorePackage)
+  , flagC "syslib"            	 (HasArg (\s -> do { exposePackage s
+                                                   ; deprecate "Use -package instead" }))
   ]
 
 type TurnOnFlag = Bool   -- True  <=> we are turning the flag on
hunk ./compiler/main/DynFlags.hs 1572
 
 type FlagSpec flag
    = ( String	-- Flag in string form
+     , FlagSafety
      , flag     -- Flag in internal form
      , TurnOnFlag -> DynP ())    -- Extra action to run when the flag is found
                                  -- Typically, emit a warning or error
hunk ./compiler/main/DynFlags.hs 1582
        -> (flag -> DynP ())	-- ^ What to do when the flag is found
        -> FlagSpec flag		-- ^ Specification of this particular flag
        -> Flag (CmdLineP DynFlags)
-mkFlag turn_on flagPrefix f (name, flag, extra_action)
-    = Flag (flagPrefix ++ name) (NoArg (f flag >> extra_action turn_on))
+mkFlag turn_on flagPrefix f (name, fsafe, flag, extra_action)
+    = Flag (flagPrefix ++ name) fsafe (NoArg (f flag >> extra_action turn_on))
 
 deprecatedForExtension :: String -> TurnOnFlag -> DynP ()
 deprecatedForExtension lang turn_on
hunk ./compiler/main/DynFlags.hs 1604
 -- | These @-f\<blah\>@ flags can all be reversed with @-fno-\<blah\>@
 fFlags :: [FlagSpec DynFlag]
 fFlags = [
-  ( "warn-dodgy-foreign-imports",       Opt_WarnDodgyForeignImports, nop ),
-  ( "warn-dodgy-exports",               Opt_WarnDodgyExports, nop ),
-  ( "warn-dodgy-imports",               Opt_WarnDodgyImports, nop ),
-  ( "warn-duplicate-exports",           Opt_WarnDuplicateExports, nop ),
-  ( "warn-hi-shadowing",                Opt_WarnHiShadows, nop ),
-  ( "warn-implicit-prelude",            Opt_WarnImplicitPrelude, nop ),
-  ( "warn-incomplete-patterns",         Opt_WarnIncompletePatterns, nop ),
-  ( "warn-incomplete-uni-patterns",     Opt_WarnIncompleteUniPatterns, nop ),
-  ( "warn-incomplete-record-updates",   Opt_WarnIncompletePatternsRecUpd, nop ),
-  ( "warn-missing-fields",              Opt_WarnMissingFields, nop ),
-  ( "warn-missing-import-lists",        Opt_WarnMissingImportList, nop ),
-  ( "warn-missing-methods",             Opt_WarnMissingMethods, nop ),
-  ( "warn-missing-signatures",          Opt_WarnMissingSigs, nop ),
-  ( "warn-missing-local-sigs",          Opt_WarnMissingLocalSigs, nop ),
-  ( "warn-name-shadowing",              Opt_WarnNameShadowing, nop ),
-  ( "warn-overlapping-patterns",        Opt_WarnOverlappingPatterns, nop ),
-  ( "warn-type-defaults",               Opt_WarnTypeDefaults, nop ),
-  ( "warn-monomorphism-restriction",    Opt_WarnMonomorphism, nop ),
-  ( "warn-unused-binds",                Opt_WarnUnusedBinds, nop ),
-  ( "warn-unused-imports",              Opt_WarnUnusedImports, nop ),
-  ( "warn-unused-matches",              Opt_WarnUnusedMatches, nop ),
-  ( "warn-warnings-deprecations",       Opt_WarnWarningsDeprecations, nop ),
-  ( "warn-deprecations",                Opt_WarnWarningsDeprecations, nop ),
-  ( "warn-deprecated-flags",            Opt_WarnDeprecatedFlags, nop ),
-  ( "warn-orphans",                     Opt_WarnOrphans, nop ),
-  ( "warn-identities",                  Opt_WarnIdentities, nop ),
-  ( "warn-auto-orphans",                Opt_WarnAutoOrphans, nop ),
-  ( "warn-tabs",                        Opt_WarnTabs, nop ),
-  ( "warn-unrecognised-pragmas",        Opt_WarnUnrecognisedPragmas, nop ),
-  ( "warn-lazy-unlifted-bindings",      Opt_WarnLazyUnliftedBindings, nop),
-  ( "warn-unused-do-bind",              Opt_WarnUnusedDoBind, nop ),
-  ( "warn-wrong-do-bind",               Opt_WarnWrongDoBind, nop ),
-  ( "warn-alternative-layout-rule-transitional", Opt_WarnAlternativeLayoutRuleTransitional, nop ),
-  ( "print-explicit-foralls",           Opt_PrintExplicitForalls, nop ),
-  ( "strictness",                       Opt_Strictness, nop ),
-  ( "specialise",                       Opt_Specialise, nop ),
-  ( "float-in",                         Opt_FloatIn, nop ),
-  ( "static-argument-transformation",   Opt_StaticArgumentTransformation, nop ),
-  ( "full-laziness",                    Opt_FullLaziness, nop ),
-  ( "liberate-case",                    Opt_LiberateCase, nop ),
-  ( "spec-constr",                      Opt_SpecConstr, nop ),
-  ( "cse",                              Opt_CSE, nop ),
-  ( "ignore-interface-pragmas",         Opt_IgnoreInterfacePragmas, nop ),
-  ( "omit-interface-pragmas",           Opt_OmitInterfacePragmas, nop ),
-  ( "expose-all-unfoldings",            Opt_ExposeAllUnfoldings, nop ),
-  ( "do-lambda-eta-expansion",          Opt_DoLambdaEtaExpansion, nop ),
-  ( "ignore-asserts",                   Opt_IgnoreAsserts, nop ),
-  ( "do-eta-reduction",                 Opt_DoEtaReduction, nop ),
-  ( "case-merge",                       Opt_CaseMerge, nop ),
-  ( "unbox-strict-fields",              Opt_UnboxStrictFields, nop ),
-  ( "method-sharing",                   Opt_MethodSharing, 
+  ( "warn-dodgy-foreign-imports",       AlwaysAllowed, Opt_WarnDodgyForeignImports, nop ),
+  ( "warn-dodgy-exports",               AlwaysAllowed, Opt_WarnDodgyExports, nop ),
+  ( "warn-dodgy-imports",               AlwaysAllowed, Opt_WarnDodgyImports, nop ),
+  ( "warn-duplicate-exports",           AlwaysAllowed, Opt_WarnDuplicateExports, nop ),
+  ( "warn-hi-shadowing",                AlwaysAllowed, Opt_WarnHiShadows, nop ),
+  ( "warn-implicit-prelude",            AlwaysAllowed, Opt_WarnImplicitPrelude, nop ),
+  ( "warn-incomplete-patterns",         AlwaysAllowed, Opt_WarnIncompletePatterns, nop ),
+  ( "warn-incomplete-uni-patterns",     AlwaysAllowed, Opt_WarnIncompleteUniPatterns, nop ),
+  ( "warn-incomplete-record-updates",   AlwaysAllowed, Opt_WarnIncompletePatternsRecUpd, nop ),
+  ( "warn-missing-fields",              AlwaysAllowed, Opt_WarnMissingFields, nop ),
+  ( "warn-missing-import-lists",        AlwaysAllowed, Opt_WarnMissingImportList, nop ),
+  ( "warn-missing-methods",             AlwaysAllowed, Opt_WarnMissingMethods, nop ),
+  ( "warn-missing-signatures",          AlwaysAllowed, Opt_WarnMissingSigs, nop ),
+  ( "warn-missing-local-sigs",          AlwaysAllowed, Opt_WarnMissingLocalSigs, nop ),
+  ( "warn-name-shadowing",              AlwaysAllowed, Opt_WarnNameShadowing, nop ),
+  ( "warn-overlapping-patterns",        AlwaysAllowed, Opt_WarnOverlappingPatterns, nop ),
+  ( "warn-type-defaults",               AlwaysAllowed, Opt_WarnTypeDefaults, nop ),
+  ( "warn-monomorphism-restriction",    AlwaysAllowed, Opt_WarnMonomorphism, nop ),
+  ( "warn-unused-binds",                AlwaysAllowed, Opt_WarnUnusedBinds, nop ),
+  ( "warn-unused-imports",              AlwaysAllowed, Opt_WarnUnusedImports, nop ),
+  ( "warn-unused-matches",              AlwaysAllowed, Opt_WarnUnusedMatches, nop ),
+  ( "warn-warnings-deprecations",       AlwaysAllowed, Opt_WarnWarningsDeprecations, nop ),
+  ( "warn-deprecations",                AlwaysAllowed, Opt_WarnWarningsDeprecations, nop ),
+  ( "warn-deprecated-flags",            AlwaysAllowed, Opt_WarnDeprecatedFlags, nop ),
+  ( "warn-orphans",                     AlwaysAllowed, Opt_WarnOrphans, nop ),
+  ( "warn-identities",                  AlwaysAllowed, Opt_WarnIdentities, nop ),
+  ( "warn-auto-orphans",                AlwaysAllowed, Opt_WarnAutoOrphans, nop ),
+  ( "warn-tabs",                        AlwaysAllowed, Opt_WarnTabs, nop ),
+  ( "warn-unrecognised-pragmas",        AlwaysAllowed, Opt_WarnUnrecognisedPragmas, nop ),
+  ( "warn-lazy-unlifted-bindings",      AlwaysAllowed, Opt_WarnLazyUnliftedBindings, nop),
+  ( "warn-unused-do-bind",              AlwaysAllowed, Opt_WarnUnusedDoBind, nop ),
+  ( "warn-wrong-do-bind",               AlwaysAllowed, Opt_WarnWrongDoBind, nop ),
+  ( "warn-alternative-layout-rule-transitional", AlwaysAllowed, Opt_WarnAlternativeLayoutRuleTransitional, nop ),
+  ( "print-explicit-foralls",           AlwaysAllowed, Opt_PrintExplicitForalls, nop ),
+  ( "strictness",                       AlwaysAllowed, Opt_Strictness, nop ),
+  ( "specialise",                       AlwaysAllowed, Opt_Specialise, nop ),
+  ( "float-in",                         AlwaysAllowed, Opt_FloatIn, nop ),
+  ( "static-argument-transformation",   AlwaysAllowed, Opt_StaticArgumentTransformation, nop ),
+  ( "full-laziness",                    AlwaysAllowed, Opt_FullLaziness, nop ),
+  ( "liberate-case",                    AlwaysAllowed, Opt_LiberateCase, nop ),
+  ( "spec-constr",                      AlwaysAllowed, Opt_SpecConstr, nop ),
+  ( "cse",                              AlwaysAllowed, Opt_CSE, nop ),
+  ( "ignore-interface-pragmas",         AlwaysAllowed, Opt_IgnoreInterfacePragmas, nop ),
+  ( "omit-interface-pragmas",           AlwaysAllowed, Opt_OmitInterfacePragmas, nop ),
+  ( "expose-all-unfoldings",            AlwaysAllowed, Opt_ExposeAllUnfoldings, nop ),
+  ( "do-lambda-eta-expansion",          AlwaysAllowed, Opt_DoLambdaEtaExpansion, nop ),
+  ( "ignore-asserts",                   AlwaysAllowed, Opt_IgnoreAsserts, nop ),
+  ( "do-eta-reduction",                 AlwaysAllowed, Opt_DoEtaReduction, nop ),
+  ( "case-merge",                       AlwaysAllowed, Opt_CaseMerge, nop ),
+  ( "unbox-strict-fields",              AlwaysAllowed, Opt_UnboxStrictFields, nop ),
+  ( "method-sharing",                   AlwaysAllowed, Opt_MethodSharing, 
      \_ -> deprecate "doesn't do anything any more"),
      -- Remove altogether in GHC 7.2
hunk ./compiler/main/DynFlags.hs 1657
-  ( "dicts-cheap",                      Opt_DictsCheap, nop ),
-  ( "excess-precision",                 Opt_ExcessPrecision, nop ),
-  ( "eager-blackholing",                Opt_EagerBlackHoling, nop ),
-  ( "asm-mangling",                     Opt_DoAsmMangling, nop ),
-  ( "print-bind-result",                Opt_PrintBindResult, nop ),
-  ( "force-recomp",                     Opt_ForceRecomp, nop ),
-  ( "hpc-no-auto",                      Opt_Hpc_No_Auto, nop ),
-  ( "rewrite-rules",                    Opt_EnableRewriteRules, useInstead "enable-rewrite-rules" ),
-  ( "enable-rewrite-rules",             Opt_EnableRewriteRules, nop ),
-  ( "break-on-exception",               Opt_BreakOnException, nop ),
-  ( "break-on-error",                   Opt_BreakOnError, nop ),
-  ( "print-evld-with-show",             Opt_PrintEvldWithShow, nop ),
-  ( "print-bind-contents",              Opt_PrintBindContents, nop ),
-  ( "run-cps",                          Opt_RunCPS, nop ),
-  ( "run-cpsz",                         Opt_RunCPSZ, nop ),
-  ( "new-codegen",                      Opt_TryNewCodeGen, nop ),
-  ( "convert-to-zipper-and-back",       Opt_ConvertToZipCfgAndBack, nop ),
-  ( "vectorise",                        Opt_Vectorise, nop ),
-  ( "regs-graph",                       Opt_RegsGraph, nop ),
-  ( "regs-iterative",                   Opt_RegsIterative, nop ),
-  ( "gen-manifest",                     Opt_GenManifest, nop ),
-  ( "embed-manifest",                   Opt_EmbedManifest, nop ),
-  ( "ext-core",                         Opt_EmitExternalCore, nop ),
-  ( "shared-implib",                    Opt_SharedImplib, nop ),
-  ( "ghci-sandbox",                     Opt_GhciSandbox, nop ),
-  ( "helpful-errors",                   Opt_HelpfulErrors, nop ),
-  ( "building-cabal-package",           Opt_BuildingCabalPackage, nop ),
-  ( "implicit-import-qualified",        Opt_ImplicitImportQualified, nop )
+  ( "dicts-cheap",                      AlwaysAllowed, Opt_DictsCheap, nop ),
+  ( "excess-precision",                 AlwaysAllowed, Opt_ExcessPrecision, nop ),
+  ( "eager-blackholing",                AlwaysAllowed, Opt_EagerBlackHoling, nop ),
+  ( "asm-mangling",                     AlwaysAllowed, Opt_DoAsmMangling, nop ),
+  ( "print-bind-result",                AlwaysAllowed, Opt_PrintBindResult, nop ),
+  ( "force-recomp",                     AlwaysAllowed, Opt_ForceRecomp, nop ),
+  ( "hpc-no-auto",                      AlwaysAllowed, Opt_Hpc_No_Auto, nop ),
+  ( "rewrite-rules",                    AlwaysAllowed, Opt_EnableRewriteRules, useInstead "enable-rewrite-rules" ),
+  ( "enable-rewrite-rules",             AlwaysAllowed, Opt_EnableRewriteRules, nop ),
+  ( "break-on-exception",               AlwaysAllowed, Opt_BreakOnException, nop ),
+  ( "break-on-error",                   AlwaysAllowed, Opt_BreakOnError, nop ),
+  ( "print-evld-with-show",             AlwaysAllowed, Opt_PrintEvldWithShow, nop ),
+  ( "print-bind-contents",              AlwaysAllowed, Opt_PrintBindContents, nop ),
+  ( "run-cps",                          AlwaysAllowed, Opt_RunCPS, nop ),
+  ( "run-cpsz",                         AlwaysAllowed, Opt_RunCPSZ, nop ),
+  ( "new-codegen",                      AlwaysAllowed, Opt_TryNewCodeGen, nop ),
+  ( "convert-to-zipper-and-back",       AlwaysAllowed, Opt_ConvertToZipCfgAndBack, nop ),
+  ( "vectorise",                        AlwaysAllowed, Opt_Vectorise, nop ),
+  ( "regs-graph",                       AlwaysAllowed, Opt_RegsGraph, nop ),
+  ( "regs-iterative",                   AlwaysAllowed, Opt_RegsIterative, nop ),
+  ( "gen-manifest",                     AlwaysAllowed, Opt_GenManifest, nop ),
+  ( "embed-manifest",                   AlwaysAllowed, Opt_EmbedManifest, nop ),
+  ( "ext-core",                         AlwaysAllowed, Opt_EmitExternalCore, nop ),
+  ( "shared-implib",                    AlwaysAllowed, Opt_SharedImplib, nop ),
+  ( "ghci-sandbox",                     AlwaysAllowed, Opt_GhciSandbox, nop ),
+  ( "helpful-errors",                   AlwaysAllowed, Opt_HelpfulErrors, nop ),
+  ( "building-cabal-package",           AlwaysAllowed, Opt_BuildingCabalPackage, nop ),
+  ( "implicit-import-qualified",        AlwaysAllowed, Opt_ImplicitImportQualified, nop )
   ]
 
 -- | These @-f\<blah\>@ flags can all be reversed with @-fno-\<blah\>@
hunk ./compiler/main/DynFlags.hs 1690
 fLangFlags :: [FlagSpec ExtensionFlag]
 fLangFlags = [
-  ( "th",                               Opt_TemplateHaskell,
+  ( "th",                               CmdLineOnly, Opt_TemplateHaskell,
     deprecatedForExtension "TemplateHaskell" >> checkTemplateHaskellOk ),
hunk ./compiler/main/DynFlags.hs 1692
-  ( "fi",                               Opt_ForeignFunctionInterface,
+  ( "fi",                               RestrictedFunction, Opt_ForeignFunctionInterface,
     deprecatedForExtension "ForeignFunctionInterface" ),
hunk ./compiler/main/DynFlags.hs 1694
-  ( "ffi",                              Opt_ForeignFunctionInterface,
+  ( "ffi",                              RestrictedFunction, Opt_ForeignFunctionInterface,
     deprecatedForExtension "ForeignFunctionInterface" ),
hunk ./compiler/main/DynFlags.hs 1696
-  ( "arrows",                           Opt_Arrows,
+  ( "arrows",                           AlwaysAllowed, Opt_Arrows,
     deprecatedForExtension "Arrows" ),
hunk ./compiler/main/DynFlags.hs 1698
-  ( "generics",                         Opt_Generics,
+  ( "generics",                         AlwaysAllowed, Opt_Generics,
     deprecatedForExtension "Generics" ),
hunk ./compiler/main/DynFlags.hs 1700
-  ( "implicit-prelude",                 Opt_ImplicitPrelude,
+  ( "implicit-prelude",                 AlwaysAllowed, Opt_ImplicitPrelude,
     deprecatedForExtension "ImplicitPrelude" ),
hunk ./compiler/main/DynFlags.hs 1702
-  ( "bang-patterns",                    Opt_BangPatterns,
+  ( "bang-patterns",                    AlwaysAllowed, Opt_BangPatterns,
     deprecatedForExtension "BangPatterns" ),
hunk ./compiler/main/DynFlags.hs 1704
-  ( "monomorphism-restriction",         Opt_MonomorphismRestriction,
+  ( "monomorphism-restriction",         AlwaysAllowed, Opt_MonomorphismRestriction,
     deprecatedForExtension "MonomorphismRestriction" ),
hunk ./compiler/main/DynFlags.hs 1706
-  ( "mono-pat-binds",                   Opt_MonoPatBinds,
+  ( "mono-pat-binds",                   AlwaysAllowed, Opt_MonoPatBinds,
     deprecatedForExtension "MonoPatBinds" ),
hunk ./compiler/main/DynFlags.hs 1708
-  ( "extended-default-rules",           Opt_ExtendedDefaultRules,
+  ( "extended-default-rules",           AlwaysAllowed, Opt_ExtendedDefaultRules,
     deprecatedForExtension "ExtendedDefaultRules" ),
hunk ./compiler/main/DynFlags.hs 1710
-  ( "implicit-params",                  Opt_ImplicitParams,
+  ( "implicit-params",                  AlwaysAllowed, Opt_ImplicitParams,
     deprecatedForExtension "ImplicitParams" ),
hunk ./compiler/main/DynFlags.hs 1712
-  ( "scoped-type-variables",            Opt_ScopedTypeVariables,
+  ( "scoped-type-variables",            AlwaysAllowed, Opt_ScopedTypeVariables,
     deprecatedForExtension "ScopedTypeVariables" ),
hunk ./compiler/main/DynFlags.hs 1714
-  ( "parr",                             Opt_ParallelArrays,
+  ( "parr",                             AlwaysAllowed, Opt_ParallelArrays,
     deprecatedForExtension "ParallelArrays" ),
hunk ./compiler/main/DynFlags.hs 1716
-  ( "PArr",                             Opt_ParallelArrays,
+  ( "PArr",                             AlwaysAllowed, Opt_ParallelArrays,
     deprecatedForExtension "ParallelArrays" ),
hunk ./compiler/main/DynFlags.hs 1718
-  ( "allow-overlapping-instances",      Opt_OverlappingInstances,
+  ( "allow-overlapping-instances",      RestrictedFunction, Opt_OverlappingInstances,
     deprecatedForExtension "OverlappingInstances" ),
hunk ./compiler/main/DynFlags.hs 1720
-  ( "allow-undecidable-instances",      Opt_UndecidableInstances,
+  ( "allow-undecidable-instances",      AlwaysAllowed, Opt_UndecidableInstances,
     deprecatedForExtension "UndecidableInstances" ),
hunk ./compiler/main/DynFlags.hs 1722
-  ( "allow-incoherent-instances",       Opt_IncoherentInstances,
+  ( "allow-incoherent-instances",       AlwaysAllowed, Opt_IncoherentInstances,
     deprecatedForExtension "IncoherentInstances" )
   ]
 
hunk ./compiler/main/DynFlags.hs 1727
 supportedLanguages :: [String]
-supportedLanguages = [ name | (name, _, _) <- languageFlags ]
+supportedLanguages = [ name | (name, _, _, _) <- languageFlags ]
 
 supportedLanguageOverlays :: [String]
hunk ./compiler/main/DynFlags.hs 1730
-supportedLanguageOverlays = [ name | (name, _, _) <- safeHaskellFlags ]
+supportedLanguageOverlays = [ name | (name, _, _, _) <- safeHaskellFlags ]
 
 supportedExtensions :: [String]
hunk ./compiler/main/DynFlags.hs 1733
-supportedExtensions = [ name' | (name, _, _) <- xFlags, name' <- [name, "No" ++ name] ]
+supportedExtensions = [ name' | (name, _, _, _) <- xFlags, name' <- [name, "No" ++ name] ]
 
 supportedLanguagesAndExtensions :: [String]
 supportedLanguagesAndExtensions =
hunk ./compiler/main/DynFlags.hs 1742
 -- | These -X<blah> flags cannot be reversed with -XNo<blah>
 languageFlags :: [FlagSpec Language]
 languageFlags = [
-  ( "Haskell98",                        Haskell98, nop ),
-  ( "Haskell2010",                      Haskell2010, nop )
+  ( "Haskell98",   AlwaysAllowed, Haskell98, nop ),
+  ( "Haskell2010", AlwaysAllowed, Haskell2010, nop )
   ]
 
 -- | These -X<blah> flags cannot be reversed with -XNo<blah>
hunk ./compiler/main/DynFlags.hs 1750
 -- They are used to place hard requirements on what GHC Haskell language
 -- features can be used.
 safeHaskellFlags :: [FlagSpec SafeHaskellMode]
-safeHaskellFlags = map mkF [Sf_SafeImports, Sf_SafeLanguage, Sf_Trustworthy, Sf_Safe]
-    where mkF flag = (show flag, flag, nop)
+safeHaskellFlags = [mkF Sf_SafeImports, mkF' Sf_SafeLanguage,
+                    mkF Sf_Trustworthy, mkF' Sf_Safe]
+    where mkF  flag = (show flag, AlwaysAllowed, flag, nop)
+          mkF' flag = (show flag, EnablesSafe,   flag, nop)
 
 -- | These -X<blah> flags can all be reversed with -XNo<blah>
 xFlags :: [FlagSpec ExtensionFlag]
hunk ./compiler/main/DynFlags.hs 1758
 xFlags = [
-  ( "CPP",                              Opt_Cpp, nop ),
-  ( "PostfixOperators",                 Opt_PostfixOperators, nop ),
-  ( "TupleSections",                    Opt_TupleSections, nop ),
-  ( "PatternGuards",                    Opt_PatternGuards, nop ),
-  ( "UnicodeSyntax",                    Opt_UnicodeSyntax, nop ),
-  ( "MagicHash",                        Opt_MagicHash, nop ),
-  ( "PolymorphicComponents",            Opt_PolymorphicComponents, nop ),
-  ( "ExistentialQuantification",        Opt_ExistentialQuantification, nop ),
-  ( "KindSignatures",                   Opt_KindSignatures, nop ),
-  ( "EmptyDataDecls",                   Opt_EmptyDataDecls, nop ),
-  ( "ParallelListComp",                 Opt_ParallelListComp, nop ),
-  ( "TransformListComp",                Opt_TransformListComp, nop ),
-  ( "ForeignFunctionInterface",         Opt_ForeignFunctionInterface, nop ),
-  ( "UnliftedFFITypes",                 Opt_UnliftedFFITypes, nop ),
-  ( "GHCForeignImportPrim",             Opt_GHCForeignImportPrim, nop ),
-  ( "LiberalTypeSynonyms",              Opt_LiberalTypeSynonyms, nop ),
-  ( "Rank2Types",                       Opt_Rank2Types, nop ),
-  ( "RankNTypes",                       Opt_RankNTypes, nop ),
-  ( "ImpredicativeTypes",               Opt_ImpredicativeTypes, nop), 
-  ( "TypeOperators",                    Opt_TypeOperators, nop ),
-  ( "RecursiveDo",                      Opt_RecursiveDo,
+  ( "CPP",                              CmdLineOnly,   Opt_Cpp, nop ),
+  ( "PostfixOperators",                 AlwaysAllowed, Opt_PostfixOperators, nop ),
+  ( "TupleSections",                    AlwaysAllowed, Opt_TupleSections, nop ),
+  ( "PatternGuards",                    AlwaysAllowed, Opt_PatternGuards, nop ),
+  ( "UnicodeSyntax",                    AlwaysAllowed, Opt_UnicodeSyntax, nop ),
+  ( "MagicHash",                        AlwaysAllowed, Opt_MagicHash, nop ),
+  ( "PolymorphicComponents",            AlwaysAllowed, Opt_PolymorphicComponents, nop ),
+  ( "ExistentialQuantification",        AlwaysAllowed, Opt_ExistentialQuantification, nop ),
+  ( "KindSignatures",                   AlwaysAllowed, Opt_KindSignatures, nop ),
+  ( "EmptyDataDecls",                   AlwaysAllowed, Opt_EmptyDataDecls, nop ),
+  ( "ParallelListComp",                 AlwaysAllowed, Opt_ParallelListComp, nop ),
+  ( "TransformListComp",                AlwaysAllowed, Opt_TransformListComp, nop ),
+  ( "ForeignFunctionInterface",    RestrictedFunction, Opt_ForeignFunctionInterface, nop ),
+  ( "UnliftedFFITypes",                 AlwaysAllowed, Opt_UnliftedFFITypes, nop ),
+  ( "GHCForeignImportPrim",             AlwaysAllowed, Opt_GHCForeignImportPrim, nop ),
+  ( "LiberalTypeSynonyms",              AlwaysAllowed, Opt_LiberalTypeSynonyms, nop ),
+  ( "Rank2Types",                       AlwaysAllowed, Opt_Rank2Types, nop ),
+  ( "RankNTypes",                       AlwaysAllowed, Opt_RankNTypes, nop ),
+  ( "ImpredicativeTypes",               AlwaysAllowed, Opt_ImpredicativeTypes, nop), 
+  ( "TypeOperators",                    AlwaysAllowed, Opt_TypeOperators, nop ),
+  ( "RecursiveDo",                      AlwaysAllowed, Opt_RecursiveDo,
     deprecatedForExtension "DoRec"),
hunk ./compiler/main/DynFlags.hs 1780
-  ( "DoRec",                            Opt_DoRec, nop ),
-  ( "Arrows",                           Opt_Arrows, nop ),
-  ( "ParallelArrays",                   Opt_ParallelArrays, nop ),
-  ( "TemplateHaskell",                  Opt_TemplateHaskell, checkTemplateHaskellOk ),
-  ( "QuasiQuotes",                      Opt_QuasiQuotes, nop ),
-  ( "Generics",                         Opt_Generics, nop ),
-  ( "ImplicitPrelude",                  Opt_ImplicitPrelude, nop ),
-  ( "RecordWildCards",                  Opt_RecordWildCards, nop ),
-  ( "NamedFieldPuns",                   Opt_RecordPuns, nop ),
-  ( "RecordPuns",                       Opt_RecordPuns,
+  ( "DoRec",                            AlwaysAllowed, Opt_DoRec, nop ),
+  ( "Arrows",                           AlwaysAllowed, Opt_Arrows, nop ),
+  ( "ParallelArrays",                   AlwaysAllowed, Opt_ParallelArrays, nop ),
+  ( "TemplateHaskell",                  CmdLineOnly,   Opt_TemplateHaskell, checkTemplateHaskellOk ),
+  ( "QuasiQuotes",                      AlwaysAllowed, Opt_QuasiQuotes, nop ),
+  ( "Generics",                         AlwaysAllowed, Opt_Generics, nop ),
+  ( "ImplicitPrelude",                  AlwaysAllowed, Opt_ImplicitPrelude, nop ),
+  ( "RecordWildCards",                  AlwaysAllowed, Opt_RecordWildCards, nop ),
+  ( "NamedFieldPuns",                   AlwaysAllowed, Opt_RecordPuns, nop ),
+  ( "RecordPuns",                       AlwaysAllowed, Opt_RecordPuns,
     deprecatedForExtension "NamedFieldPuns" ),
hunk ./compiler/main/DynFlags.hs 1791
-  ( "DisambiguateRecordFields",         Opt_DisambiguateRecordFields, nop ),
-  ( "OverloadedStrings",                Opt_OverloadedStrings, nop ),
-  ( "GADTs",                            Opt_GADTs, nop ),
-  ( "GADTSyntax",                       Opt_GADTSyntax, nop ),
-  ( "ViewPatterns",                     Opt_ViewPatterns, nop ),
-  ( "TypeFamilies",                     Opt_TypeFamilies, nop ),
-  ( "BangPatterns",                     Opt_BangPatterns, nop ),
-  ( "MonomorphismRestriction",          Opt_MonomorphismRestriction, nop ),
-  ( "NPlusKPatterns",                   Opt_NPlusKPatterns, nop ),
-  ( "DoAndIfThenElse",                  Opt_DoAndIfThenElse, nop ),
-  ( "RebindableSyntax",                 Opt_RebindableSyntax, nop ),
-  ( "MonoPatBinds",                     Opt_MonoPatBinds, nop ),
-  ( "ExplicitForAll",                   Opt_ExplicitForAll, nop ),
-  ( "AlternativeLayoutRule",            Opt_AlternativeLayoutRule, nop ),
-  ( "AlternativeLayoutRuleTransitional",Opt_AlternativeLayoutRuleTransitional, nop ),
-  ( "DatatypeContexts",                 Opt_DatatypeContexts, nop ),
-  ( "NondecreasingIndentation",         Opt_NondecreasingIndentation, nop ),
-  ( "RelaxedLayout",                    Opt_RelaxedLayout, nop ),
-  ( "MonoLocalBinds",                   Opt_MonoLocalBinds, nop ),
-  ( "RelaxedPolyRec",                   Opt_RelaxedPolyRec, 
+  ( "DisambiguateRecordFields",         AlwaysAllowed, Opt_DisambiguateRecordFields, nop ),
+  ( "OverloadedStrings",                AlwaysAllowed, Opt_OverloadedStrings, nop ),
+  ( "GADTs",                            AlwaysAllowed, Opt_GADTs, nop ),
+  ( "GADTSyntax",                       AlwaysAllowed, Opt_GADTSyntax, nop ),
+  ( "ViewPatterns",                     AlwaysAllowed, Opt_ViewPatterns, nop ),
+  ( "TypeFamilies",                     AlwaysAllowed, Opt_TypeFamilies, nop ),
+  ( "BangPatterns",                     AlwaysAllowed, Opt_BangPatterns, nop ),
+  ( "MonomorphismRestriction",          AlwaysAllowed, Opt_MonomorphismRestriction, nop ),
+  ( "NPlusKPatterns",                   AlwaysAllowed, Opt_NPlusKPatterns, nop ),
+  ( "DoAndIfThenElse",                  AlwaysAllowed, Opt_DoAndIfThenElse, nop ),
+  ( "RebindableSyntax",                 AlwaysAllowed, Opt_RebindableSyntax, nop ),
+  ( "MonoPatBinds",                     AlwaysAllowed, Opt_MonoPatBinds, nop ),
+  ( "ExplicitForAll",                   AlwaysAllowed, Opt_ExplicitForAll, nop ),
+  ( "AlternativeLayoutRule",            AlwaysAllowed, Opt_AlternativeLayoutRule, nop ),
+  ( "AlternativeLayoutRuleTransitional",AlwaysAllowed, Opt_AlternativeLayoutRuleTransitional, nop ),
+  ( "DatatypeContexts",                 AlwaysAllowed, Opt_DatatypeContexts, nop ),
+  ( "NondecreasingIndentation",         AlwaysAllowed, Opt_NondecreasingIndentation, nop ),
+  ( "RelaxedLayout",                    AlwaysAllowed, Opt_RelaxedLayout, nop ),
+  ( "MonoLocalBinds",                   AlwaysAllowed, Opt_MonoLocalBinds, nop ),
+  ( "RelaxedPolyRec",                   AlwaysAllowed, Opt_RelaxedPolyRec, 
     \ turn_on -> if not turn_on 
                  then deprecate "You can't turn off RelaxedPolyRec any more"
                  else return () ),
hunk ./compiler/main/DynFlags.hs 1814
-  ( "ExtendedDefaultRules",             Opt_ExtendedDefaultRules, nop ),
-  ( "ImplicitParams",                   Opt_ImplicitParams, nop ),
-  ( "ScopedTypeVariables",              Opt_ScopedTypeVariables, nop ),
+  ( "ExtendedDefaultRules",             AlwaysAllowed, Opt_ExtendedDefaultRules, nop ),
+  ( "ImplicitParams",                   AlwaysAllowed, Opt_ImplicitParams, nop ),
+  ( "ScopedTypeVariables",              AlwaysAllowed, Opt_ScopedTypeVariables, nop ),
 
hunk ./compiler/main/DynFlags.hs 1818
-  ( "PatternSignatures",                Opt_ScopedTypeVariables, 
+  ( "PatternSignatures",                AlwaysAllowed, Opt_ScopedTypeVariables, 
     deprecatedForExtension "ScopedTypeVariables" ),
 
hunk ./compiler/main/DynFlags.hs 1821
-  ( "UnboxedTuples",                    Opt_UnboxedTuples, nop ),
-  ( "StandaloneDeriving",               Opt_StandaloneDeriving, nop ),
-  ( "DeriveDataTypeable",               Opt_DeriveDataTypeable, nop ),
-  ( "DeriveFunctor",                    Opt_DeriveFunctor, nop ),
-  ( "DeriveTraversable",                Opt_DeriveTraversable, nop ),
-  ( "DeriveFoldable",                   Opt_DeriveFoldable, nop ),
-  ( "TypeSynonymInstances",             Opt_TypeSynonymInstances, nop ),
-  ( "FlexibleContexts",                 Opt_FlexibleContexts, nop ),
-  ( "FlexibleInstances",                Opt_FlexibleInstances, nop ),
-  ( "ConstrainedClassMethods",          Opt_ConstrainedClassMethods, nop ),
-  ( "MultiParamTypeClasses",            Opt_MultiParamTypeClasses, nop ),
-  ( "FunctionalDependencies",           Opt_FunctionalDependencies, nop ),
-  ( "GeneralizedNewtypeDeriving",       Opt_GeneralizedNewtypeDeriving, nop ),
-  ( "OverlappingInstances",             Opt_OverlappingInstances, nop ),
-  ( "UndecidableInstances",             Opt_UndecidableInstances, nop ),
-  ( "IncoherentInstances",              Opt_IncoherentInstances, nop ),
-  ( "PackageImports",                   Opt_PackageImports, nop )
+  ( "UnboxedTuples",                    AlwaysAllowed, Opt_UnboxedTuples, nop ),
+  ( "StandaloneDeriving",               AlwaysAllowed, Opt_StandaloneDeriving, nop ),
+  ( "DeriveDataTypeable",               AlwaysAllowed, Opt_DeriveDataTypeable, nop ),
+  ( "DeriveFunctor",                    AlwaysAllowed, Opt_DeriveFunctor, nop ),
+  ( "DeriveTraversable",                AlwaysAllowed, Opt_DeriveTraversable, nop ),
+  ( "DeriveFoldable",                   AlwaysAllowed, Opt_DeriveFoldable, nop ),
+  ( "TypeSynonymInstances",             AlwaysAllowed, Opt_TypeSynonymInstances, nop ),
+  ( "FlexibleContexts",                 AlwaysAllowed, Opt_FlexibleContexts, nop ),
+  ( "FlexibleInstances",                AlwaysAllowed, Opt_FlexibleInstances, nop ),
+  ( "ConstrainedClassMethods",          AlwaysAllowed, Opt_ConstrainedClassMethods, nop ),
+  ( "MultiParamTypeClasses",            AlwaysAllowed, Opt_MultiParamTypeClasses, nop ),
+  ( "FunctionalDependencies",           AlwaysAllowed, Opt_FunctionalDependencies, nop ),
+  ( "GeneralizedNewtypeDeriving",       NeverAllowed,  Opt_GeneralizedNewtypeDeriving, nop ),
+  ( "OverlappingInstances",        RestrictedFunction, Opt_OverlappingInstances, nop ),
+  ( "UndecidableInstances",             AlwaysAllowed, Opt_UndecidableInstances, nop ),
+  ( "IncoherentInstances",              AlwaysAllowed, Opt_IncoherentInstances, nop ),
+  ( "PackageImports",                   AlwaysAllowed, Opt_PackageImports, nop )
   ]
 
 defaultFlags :: [DynFlag]
hunk ./compiler/main/GHC.hs 463
   return preload
 
 
+parseDynamicFlags :: Monad m =>
+                     DynFlags -> [Located String]
+                  -> m (DynFlags, [Located String], [Located String])
+parseDynamicFlags = parseDynamicFlagsCmdLine
+
 
 -- %************************************************************************
 -- %*							                   *
hunk ./compiler/main/GhcMake.hs 1397
 	let local_opts = getOptions dflags buf src_fn
 
 	(dflags', leftovers, warns)
-            <- parseDynamicNoPackageFlags dflags local_opts
+            <- parseDynamicFilePragma dflags local_opts
         checkProcessArgsResult leftovers
         handleFlagWarnings dflags' warns
 
hunk ./compiler/main/StaticFlagParser.hs 53
   ready <- readIORef v_opt_C_ready
   when ready $ ghcError (ProgramError "Too late for parseStaticFlags: call it before newSession")
 
-  (leftover, errs, warns1) <- processArgs static_flags args
+  (leftover, errs, warns1) <- processArgs static_flags args CmdLineOnly True
   when (not (null errs)) $ ghcError $ errorsToGhcException errs
 
     -- deal with the way flags: the way (eg. prof) gives rise to
hunk ./compiler/main/StaticFlagParser.hs 65
   let unreg_flags | cGhcUnregisterised == "YES" = unregFlags
 		  | otherwise = []
 
-  (more_leftover, errs, warns2) <- processArgs static_flags (unreg_flags ++ way_flags')
+  (more_leftover, errs, warns2) <-
+      processArgs static_flags (unreg_flags ++ way_flags') CmdLineOnly True
 
     -- see sanity code in staticOpts
   writeIORef v_opt_C_ready True
hunk ./compiler/main/StaticFlagParser.hs 107
 
 static_flags = [
         ------- GHCi -------------------------------------------------------
-    Flag "ignore-dot-ghci" (PassFlag addOpt) 
-  , Flag "read-dot-ghci"   (NoArg (removeOpt "-ignore-dot-ghci"))
+    flagC "ignore-dot-ghci" (PassFlag addOpt) 
+  , flagC "read-dot-ghci"   (NoArg (removeOpt "-ignore-dot-ghci"))
 
         ------- ways --------------------------------------------------------
hunk ./compiler/main/StaticFlagParser.hs 111
-  , Flag "prof"           (NoArg (addWay WayProf)) 
-  , Flag "eventlog"       (NoArg (addWay WayEventLog))
-  , Flag "parallel"       (NoArg (addWay WayPar))
-  , Flag "gransim"        (NoArg (addWay WayGran))
-  , Flag "smp"            (NoArg (addWay WayThreaded >> deprecate "Use -threaded instead"))
-  , Flag "debug"          (NoArg (addWay WayDebug))
-  , Flag "ndp"            (NoArg (addWay WayNDP))
-  , Flag "threaded"       (NoArg (addWay WayThreaded))
+  , flagC "prof"           (NoArg (addWay WayProf)) 
+  , flagC "eventlog"       (NoArg (addWay WayEventLog))
+  , flagC "parallel"       (NoArg (addWay WayPar))
+  , flagC "gransim"        (NoArg (addWay WayGran))
+  , flagC "smp"            (NoArg (addWay WayThreaded >> deprecate "Use -threaded instead"))
+  , flagC "debug"          (NoArg (addWay WayDebug))
+  , flagC "ndp"            (NoArg (addWay WayNDP))
+  , flagC "threaded"       (NoArg (addWay WayThreaded))
 
hunk ./compiler/main/StaticFlagParser.hs 120
-  , Flag "ticky"          (PassFlag (\f -> do addOpt f; addWay WayDebug))
+  , flagC "ticky"          (PassFlag (\f -> do addOpt f; addWay WayDebug))
     -- -ticky enables ticky-ticky code generation, and also implies -debug which
     -- is required to get the RTS ticky support.
 
hunk ./compiler/main/StaticFlagParser.hs 125
         ------ Debugging ----------------------------------------------------
-  , Flag "dppr-debug"                  (PassFlag addOpt)
-  , Flag "dppr-cols"                   (AnySuffix addOpt)
-  , Flag "dppr-user-length"            (AnySuffix addOpt)
-  , Flag "dppr-case-as-let"            (PassFlag addOpt)
-  , Flag "dsuppress-all"               (PassFlag addOpt)
-  , Flag "dsuppress-uniques"           (PassFlag addOpt)
-  , Flag "dsuppress-coercions"         (PassFlag addOpt)
-  , Flag "dsuppress-module-prefixes"   (PassFlag addOpt)
-  , Flag "dsuppress-type-applications" (PassFlag addOpt)
-  , Flag "dsuppress-idinfo"            (PassFlag addOpt)
-  , Flag "dsuppress-type-signatures"   (PassFlag addOpt)
-  , Flag "dopt-fuel"                   (AnySuffix addOpt)
-  , Flag "dtrace-level"                (AnySuffix addOpt)
-  , Flag "dno-debug-output"            (PassFlag addOpt)
-  , Flag "dstub-dead-values"           (PassFlag addOpt)
+  , flagC "dppr-debug"                  (PassFlag addOpt)
+  , flagC "dppr-cols"                   (AnySuffix addOpt)
+  , flagC "dppr-user-length"            (AnySuffix addOpt)
+  , flagC "dppr-case-as-let"            (PassFlag addOpt)
+  , flagC "dsuppress-all"               (PassFlag addOpt)
+  , flagC "dsuppress-uniques"           (PassFlag addOpt)
+  , flagC "dsuppress-coercions"         (PassFlag addOpt)
+  , flagC "dsuppress-module-prefixes"   (PassFlag addOpt)
+  , flagC "dsuppress-type-applications" (PassFlag addOpt)
+  , flagC "dsuppress-idinfo"            (PassFlag addOpt)
+  , flagC "dsuppress-type-signatures"   (PassFlag addOpt)
+  , flagC "dopt-fuel"                   (AnySuffix addOpt)
+  , flagC "dtrace-level"                (AnySuffix addOpt)
+  , flagC "dno-debug-output"            (PassFlag addOpt)
+  , flagC "dstub-dead-values"           (PassFlag addOpt)
       -- rest of the debugging flags are dynamic
 
         ----- Linker --------------------------------------------------------
hunk ./compiler/main/StaticFlagParser.hs 143
-  , Flag "static"         (PassFlag addOpt)
-  , Flag "dynamic"        (NoArg (removeOpt "-static" >> addWay WayDyn))
+  , flagC "static"         (PassFlag addOpt)
+  , flagC "dynamic"        (NoArg (removeOpt "-static" >> addWay WayDyn))
     -- ignored for compat w/ gcc:
hunk ./compiler/main/StaticFlagParser.hs 146
-  , Flag "rdynamic"       (NoArg (return ()))
+  , flagC "rdynamic"       (NoArg (return ()))
 
         ----- RTS opts ------------------------------------------------------
hunk ./compiler/main/StaticFlagParser.hs 149
-  , Flag "H"              (HasArg (\s -> liftEwM (setHeapSize (fromIntegral (decodeSize s)))))
+  , flagC "H"              (HasArg (\s -> liftEwM (setHeapSize (fromIntegral (decodeSize s)))))
         
hunk ./compiler/main/StaticFlagParser.hs 151
-  , Flag "Rghc-timing"    (NoArg (liftEwM enableTimingStats))
+  , flagC "Rghc-timing"    (NoArg (liftEwM enableTimingStats))
 
         ------ Compiler flags -----------------------------------------------
 
hunk ./compiler/main/StaticFlagParser.hs 157
         -- -fPIC requires extra checking: only the NCG supports it.
         -- See also DynFlags.parseDynamicFlags.
-  , Flag "fPIC" (PassFlag setPIC)
+  , flagC "fPIC" (PassFlag setPIC)
 
         -- All other "-fno-<blah>" options cancel out "-f<blah>" on the hsc cmdline
hunk ./compiler/main/StaticFlagParser.hs 160
-  , Flag "fno-"
+  , flagC "fno-"
          (PrefixPred (\s -> isStaticFlag ("f"++s)) (\s -> removeOpt ("-f"++s)))
         
 
hunk ./compiler/main/StaticFlagParser.hs 165
         -- Pass all remaining "-f<blah>" options to hsc
-  , Flag "f" (AnySuffixPred isStaticFlag addOpt)
+  , flagC "f" (AnySuffixPred isStaticFlag addOpt)
   ]
 
 setPIC :: String -> StaticP ()
hunk ./compiler/typecheck/TcDeriv.lhs 987
   where
     why = ptext (sLit "You need -X") <> text flag_str 
           <+> ptext (sLit "to derive an instance for this class")
-    flag_str = case [ s | (s, f, _) <- xFlags, f==flag ] of
+    flag_str = case [ s | (s, _, f, _) <- xFlags, f==flag ] of
                  [s]   -> s
                  other -> pprPanic "checkFlag" (ppr other)
 
hunk ./ghc/Main.hs 482
                       [Located String])
 parseModeFlags args = do
   let ((leftover, errs1, warns), (mModeFlag, errs2, flags')) =
-          runCmdLine (processArgs mode_flags args)
+          runCmdLine (processArgs mode_flags args CmdLineOnly True)
                      (Nothing, [], [])
       mode = case mModeFlag of
              Nothing     -> doMakeMode
hunk ./ghc/Main.hs 498
 mode_flags :: [Flag ModeM]
 mode_flags =
   [  ------- help / version ----------------------------------------------
-    Flag "?"                     (PassFlag (setMode showGhcUsageMode))
-  , Flag "-help"                 (PassFlag (setMode showGhcUsageMode))
-  , Flag "V"                     (PassFlag (setMode showVersionMode))
-  , Flag "-version"              (PassFlag (setMode showVersionMode))
-  , Flag "-numeric-version"      (PassFlag (setMode showNumVersionMode))
-  , Flag "-info"                 (PassFlag (setMode showInfoMode))
-  , Flag "-supported-languages"  (PassFlag (setMode showSupportedExtensionsMode))
-  , Flag "-supported-extensions" (PassFlag (setMode showSupportedExtensionsMode))
+    flagC "?"                     (PassFlag (setMode showGhcUsageMode))
+  , flagC "-help"                 (PassFlag (setMode showGhcUsageMode))
+  , flagC "V"                     (PassFlag (setMode showVersionMode))
+  , flagC "-version"              (PassFlag (setMode showVersionMode))
+  , flagC "-numeric-version"      (PassFlag (setMode showNumVersionMode))
+  , flagC "-info"                 (PassFlag (setMode showInfoMode))
+  , flagC "-supported-languages"  (PassFlag (setMode showSupportedExtensionsMode))
+  , flagC "-supported-extensions" (PassFlag (setMode showSupportedExtensionsMode))
   ] ++
hunk ./ghc/Main.hs 507
-  [ Flag k'                     (PassFlag (setMode mode))
+  [ flagC k'                      (PassFlag (setMode mode))
   | (k, v) <- compilerInfo,
     let k' = "-print-" ++ map (replaceSpace . toLower) k
         replaceSpace ' ' = '-'
hunk ./ghc/Main.hs 517
                FromDynFlags f -> printWithDynFlagsMode f
   ] ++
       ------- interfaces ----------------------------------------------------
-  [ Flag "-show-iface"  (HasArg (\f -> setMode (showInterfaceMode f)
+  [ flagC "-show-iface"  (HasArg (\f -> setMode (showInterfaceMode f)
                                                "--show-iface"))
 
       ------- primary modes ------------------------------------------------
hunk ./ghc/Main.hs 521
-  , Flag "c"            (PassFlag (\f -> do setMode (stopBeforeMode StopLn) f
-                                            addFlag "-no-link" f))
-  , Flag "M"            (PassFlag (setMode doMkDependHSMode))
-  , Flag "E"            (PassFlag (setMode (stopBeforeMode anyHsc)))
-  , Flag "C"            (PassFlag (\f -> do setMode (stopBeforeMode HCc) f
-                                            addFlag "-fvia-C" f))
-  , Flag "S"            (PassFlag (setMode (stopBeforeMode As)))
-  , Flag "-make"        (PassFlag (setMode doMakeMode))
-  , Flag "-interactive" (PassFlag (setMode doInteractiveMode))
-  , Flag "-abi-hash"    (PassFlag (setMode doAbiHashMode))
-  , Flag "e"            (SepArg   (\s -> setMode (doEvalMode s) "-e"))
+  , flagC "c"            (PassFlag (\f -> do setMode (stopBeforeMode StopLn) f
+                                             addFlag "-no-link" f))
+  , flagC "M"            (PassFlag (setMode doMkDependHSMode))
+  , flagC "E"            (PassFlag (setMode (stopBeforeMode anyHsc)))
+  , flagC "C"            (PassFlag (\f -> do setMode (stopBeforeMode HCc) f
+                                             addFlag "-fvia-C" f))
+  , flagC "S"            (PassFlag (setMode (stopBeforeMode As)))
+  , flagC "-make"        (PassFlag (setMode doMakeMode))
+  , flagC "-interactive" (PassFlag (setMode doInteractiveMode))
+  , flagC "-abi-hash"    (PassFlag (setMode doAbiHashMode))
+  , flagC "e"            (SepArg   (\s -> setMode (doEvalMode s) "-e"))
   ]
 
 setMode :: Mode -> String -> EwM ModeM ()
}

Context:

[fix warning
Simon Marlow <marlowsd@gmail.com>**20110131135951
 Ignore-this: e893d9bfbabf1601133a1e09c50b908
] 
[32-bit fix
Simon Marlow <marlowsd@gmail.com>**20101013154200
 Ignore-this: 7508977c263ed2cec321b40a8b5772a
] 
[update to mingw gcc 4.5.2
Simon Marlow <marlowsd@gmail.com>**20110119135053
 Ignore-this: b9d5cb736a48a0adc5e35eb8a0c191cd
] 
[count fizzled and GC'd sparks separately
Simon Marlow <marlowsd@gmail.com>**20101111132727
 Ignore-this: 4cb4b759aed06659b46cdf76e791e5c9
] 
[count "dud" sparks (expressions that were already evaluated when sparked)
Simon Marlow <marlowsd@gmail.com>**20101101124143
 Ignore-this: ca94824c0e75da0b3688300e7285c7e6
] 
[fix some shutdown memory leaks
Simon Marlow <marlowsd@gmail.com>**20100820093133
 Ignore-this: 3e7b80b5f4846d6c56319c150895953d
] 
[fix DEBUG build
Simon Marlow <marlowsd@gmail.com>**20110131123433
 Ignore-this: f2e009eaa66a14a7c8ec6acc7a4bbdb1
] 
[Fix formatting glitch in documentation
simonpj@microsoft.com**20110128115400
 Ignore-this: 6c410ed19956feac7e0cf68bb40b40b1
] 
[Fix warnings
Simon Marlow <marlowsd@gmail.com>**20110128103639
 Ignore-this: aa7f2c9f9b91f9dabc7b5d5ea26121fd
] 
[Merge in new code generator branch.
Simon Marlow <marlowsd@gmail.com>**20110124121650
 Ignore-this: 7762f21082cb84ec94daaeefd70f5ef2
 This changes the new code generator to make use of the Hoopl package
 for dataflow analysis.  Hoopl is a new boot package, and is maintained
 in a separate upstream git repository (as usual, GHC has its own
 lagging darcs mirror in http://darcs.haskell.org/packages/hoopl).
 
 During this merge I squashed recent history into one patch.  I tried
 to rebase, but the history had some internal conflicts of its own
 which made rebase extremely confusing, so I gave up. The history I
 squashed was:
 
   - Update new codegen to work with latest Hoopl
   - Add some notes on new code gen to cmm-notes
   - Enable Hoopl lag package.
   - Add SPJ note to cmm-notes
   - Improve GC calls on new code generator.
 
 Work in this branch was done by:
    - Milan Straka <fox@ucw.cz>
    - John Dias <dias@cs.tufts.edu>
    - David Terei <davidterei@gmail.com>
 
 Edward Z. Yang <ezyang@mit.edu> merged in further changes from GHC HEAD
 and fixed a few bugs.
] 
[Fix an egregious strictness analyser bug (Trac #4924)
simonpj@microsoft.com**20110128080748
 Ignore-this: 3bf533c3d30b45a8e78b1fec3d9634f
 
 The "virgin" flag was being threaded rather than treated
 like an environment.  As a result, the second and subsequent
 recursive definitions in a module were not getting a
 correctly-initialised fixpoint loop, causing much worse
 strictness analysis results.  Indeed the symptoms in
 Trac #4924 were quite bizarre.
 
 Anyway, it's easily fixed.  Merge to stable branch.
] 
[Refine incomplete-pattern checks (Trac #4905)
simonpj@microsoft.com**20110127131304
 Ignore-this: cf2e0852f20d1cadc6a2cba4272838f6
 
 The changes are:
 
 * New flag -fwarn-incomplete-uni-patterns, which checks for
   incomplete patterns in (a) lambdas, (b) pattern bindings
 
 * New flag is not implied by -W or -Wall (too noisy; and many
   libraries use incomplete pattern bindings)
 
 * Actually do the incomplete-pattern check for pattern bindings
   (previously simply omitted)
 
 * Documentation for new flag
] 
[Fix "make 1" etc following the build system changes
Ian Lynagh <igloo@earth.li>**20110127001739
 Ignore-this: 7ae0a41f2753d7740569f362a97ea5fb
 The logic is now in mk/compiler-ghc.mk rather than being duplicated in
 ghc/Makefile and compiler/Makefile.
] 
[Fix vectorisation of recursive types
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20110126231843
 Ignore-this: 983fc42a659be2e085da9b16f994aa2e
] 
[Fix dependencies among specialisations for imported Ids
simonpj@microsoft.com**20110126172112
 Ignore-this: 364e09c11affe7bfe8f1b934ea28bbb6
 
 This was a subtle one (Trac #4903).  See
   Note [Glom the bindings if imported functions are specialised]
 in Speclialise.
 
 Fundamentally, a specialised binding for an imported Id was being
 declared non-recursive, whereas in fact it can become recursive
 via a RULE.  Once it's specified non-recurive the OccAnal pass
 treats that as gospel -- and that in turn led to infinite inlining.
 
 Easily fixed by glomming all the specialised bindings in a Rec;
 now the OccAnal will sort them out correctly.
] 
[Fix bug in roughTopNames
simonpj@microsoft.com**20110126171803
 Ignore-this: eca8b144162f1bd94e2ccb433bca1e02
 
 roughTopNames was returning a name that in fact might be
 "looked though" by the rule matcher. Result: a rule
 that should match was being pre-emptively discarded.
 
 See Note [Care with roughTopName].
 
 Fixes a bug noticed by Pedro (Trac #4918).
] 
[Comments only, plus a tiny bit of debug printing
simonpj@microsoft.com**20110126171255
 Ignore-this: f84364b2b90fc860e9289dd40d0395ac
] 
[Comments only
simonpj@microsoft.com**20110126171235
 Ignore-this: 79059977f82aaac7f9714ad09e820ea9
] 
[Look through type synonyms when computing orphans
simonpj@microsoft.com**20110126171229
 Ignore-this: 6dfc45dae3a94cdb0022b2d21d6e09f6
 
 I renamed functions tyClsNamesOfTypes to oprhNamesOfType,
 because it's only used in that capacity, and we therefore
 want to look through type synonyms.  Similarly exprOrphNames.
 
 This fixes Trac #4912.
] 
[Bleat a bit more informatively in unionLists
simonpj@microsoft.com**20110126171030
 Ignore-this: 80b276aa3d7971c6d7802b5f6b522d2e
] 
[Keep separate linker flags, for when we want to link with gcc or ld
Ian Lynagh <igloo@earth.li>**20110124233121] 
[Fix validate on OS X 64
Ian Lynagh <igloo@earth.li>**20110124183618] 
[Split main/GHC into GHC and GhcMake
simonpj@microsoft.com**20110125161632
 Ignore-this: 502ea034de77ecd81173161836d78287
 
 There are two things going on in main/GHC.hs.
   * It's the root module of the GHC package
   * It contains lots of stuff for --make
 It is also gigantic (2.7k lines)
 
 This patch splits it into two
   * GHC.hs is the root module for the GHC package
       (1.3k lines)
   * GhcMake.hs contains the stuff for --make
       (1.4k lines)
 
 Happily the functional split divided it almost
 exactly in half.
 
 This is a pure refactoring.  There should be no 
 behavioural change.
] 
[Comments only
simonpj@microsoft.com**20110125131115
 Ignore-this: 7ec4e97a481d06894de940aba59c575d
] 
[Fix Trac #3717 by making exprOkForSpeculation a bit cleverer
simonpj@microsoft.com**20110125110525
 Ignore-this: 13b606b05da69c29bf53aaf408fd602
 
 The main change here is to do with dropping redundant seqs.
 See Note [exprOkForSpeculation: case expressions] in CoreUtils.
] 
[Improve dataToTag# magic
simonpj@microsoft.com**20110125110418
 Ignore-this: 11fdb265e030dec4d5b13ed6b16c9761
 
 dataToTag# is a bit unsatisfactory because it requires
 its argument to be evaluated, and we don't have a good
 way to enforce that. This patch adds some comments, and
 makes exprOkForSpeculation a bit less picky in the case
 of dataToTag# (since the argument may, in fact, not be
 eval'd).
] 
[Fix Trac #4917: try a bit harder to unify on-the-fly
simonpj@microsoft.com**20110125110112
 Ignore-this: e96e0a19ab8517d4ba648efe91f6b379
 
 This is generally a modest improvement but, more important,
 it fixes a "unify-under-forall" problem.  See Note [Avoid deferring].
 
 There's still a lurking unsatisfactory-ness in that we can't
 defer arbitrary constraints that are trapped under a forall.
] 
[DPH options updated
Manuel M T Chakravarty <chak@cse.unsw.edu.au>**20110124043617
 Ignore-this: 6b7d2949b75f9c923f279c1178d2d042
 - '-Odph' is now '-O2 -fsimplifier-phases=3 -fsimplifier-iterations=20'
 - The new option '-fdph-none' is the default; it indicates that no DPH
   backend is selected and is the only valid option if the DPH libraries
   are not installed.  If vectorisation is attempted with -fdph-none a
   suitable error message is generated.
 - Hence, '-fdph-par' (or '-fdph-seq') needs to be explicitly selected
   when using vectorisation and when linking vectorised code.  (There
   seems to be no elegant way to avoid that.)
] 
[Add build system profiling to build system
Ian Lynagh <igloo@earth.li>**20110123151408
 Ignore-this: 75717810be32d60323980f9fd1baa853
] 
[Fix ghci in stage3
Ian Lynagh <igloo@earth.li>**20110123120232] 
[Remove use of non-existent $$(dir) variable in the rts ghc.mk
Ian Lynagh <igloo@earth.li>**20110123021815] 
[Add some missing dependencies
Ian Lynagh <igloo@earth.li>**20110123004208] 
[Tweak some deps to avoid multiple $(wildcard ...)s
Ian Lynagh <igloo@earth.li>**20110123001045
 Ignore-this: 38e53cb6f6b4f27c771ae0ed341f8958
 Note that some things depending on the rts/includes header files now
 depend on more files: They used to include depend on includes/*.h, but
 now they also depend on header files in subdirectories. As far as I can
 see this was a bug.
] 
[Use := when assigning the result of $(wildcard ...)
Ian Lynagh <igloo@earth.li>**20110122224532
 Ignore-this: 67e2ca2ffbcffb5b7f55bd60c17fc6cf
 Avoids repeated evaluations of things that need system calls etc
] 
[Simplify the build system, and remove 2 phases
Ian Lynagh <igloo@earth.li>**20110122190928
 Ignore-this: 7b6184088befcbc44ea47b2f4abf85a9
 From
     http://hackage.haskell.org/trac/ghc/wiki/Building/Architecture/Idiom/PhaseOrdering
 
 Phase 0:
     Includes: package-data.mk files for things built by the
               bootstrapping compiler.
     Builds:   the dependency files for hsc2hs and genprimopcode. We need
               to do this now, as hsc2hs needs to be buildable in phase 1's
               includes (so that we can make the hpc library's .hs source
               files, which in turn is necessary for making its dependency
               files), and genprimopcode needs to be buildable in phase 1's
               includes (so that we can make the primop-*.hs-incl files,
               which are sources for the stage1 compiler library, and thus
               necessary for making its dependency files).
 Phase 1:
     Includes: dependency files for things built by the bootstrapping
               compiler.
     Builds:   package-data.mk files for everything else. Note that this
               requires configuring the packages, which means telling cabal
               which ghc to use, and thus the stage1 compiler gets built
               during this phase. 
 Phase "":
     Includes: dependency files for everything else.
     Builds:   Everything else. 
] 
[Manually control more of the Cabal flags for the compiler and ghc packages
Ian Lynagh <igloo@earth.li>**20110121230552
 Ignore-this: 652b5f6327d246d7e2e47acbca614df2
 For some reason the Windows HEAD builder has started thinking the ghci
 flag should be on in stage 1. This should fix it, and generally make
 things a little more resilient.
] 
[Remove some hardcoded makefile settings
Ian Lynagh <igloo@earth.li>**20110121230245
 Ignore-this: 6b1b68aebdfbe02c15518985d2ea7559
 Now that we used cabal to configure the ghc-bin package they are no
 longer needed.
] 
[tweak newArray# documentation again
Simon Marlow <marlowsd@gmail.com>**20110119140633
 Ignore-this: ceee33428dbad7e0f5eabfa0a2590466
] 
[Fix OSTYPE test
Ian Lynagh <igloo@earth.li>**20110120000308
 Ignore-this: 8fa5d5c03297cb507a166bd85675145c
] 
[Comments only
simonpj@microsoft.com**20110119222247
 Ignore-this: ea531428e9093ecedb895735ed537791
] 
[Add OSTYPE build-system variable, and use it
simonpj@microsoft.com**20110113155023
 Ignore-this: c4a75f0bb27a680924e57ca7075ec116
 
 The use is in install.mk.in, where we need to know when
 we're on Cygwin.
 
 This fixes the build on my Windows box, where I have
 both Msys and Cygwin.
] 
[Remove an extraneous comma that stopped ghc-cabal from building
Ian Lynagh <igloo@earth.li>**20110119222359] 
[Move some make variables around
Ian Lynagh <igloo@earth.li>**20110119221545
 Ignore-this: c57c93f39d72c3baef7c5f466861dd5b
] 
[Remove a debugging 'info'
Ian Lynagh <igloo@earth.li>**20110119203305
 Ignore-this: ea912ba205eaae1d2bcf0cce7c13628d
] 
[Move the PACKAGE_MAGIC evaluation inside package-data.mk
Ian Lynagh <igloo@earth.li>**20110119203229
 Ignore-this: 497c4e83ae75089c24d6c794c4e2891f
] 
[Fix libraries/index.html's haddock dependency on Windows
Ian Lynagh <igloo@earth.li>**20110119172310] 
[Add configure phases for the stage 3 compiler
Ian Lynagh <igloo@earth.li>**20110119130629] 
[Include kfreebsdgnu in the list of Target Platforms.
Marco Silva <marcot@marcot.eti.br>**20110118222352
 Ignore-this: 759482baf33903b98cd837636a3f5328
] 
[Fix documentation bug: newArray# accepts word count, not byte count.
Edward Z. Yang <ezyang@mit.edu>**20110118221834
 Ignore-this: 8daab134bf72a740b89d273fb4e983d5
] 
[Update the location of libffi.dll.a
Ian Lynagh <igloo@earth.li>**20110118164225
 As far as I can see this has been wrong for some time, but only bit
 recently.
] 
[Update the generics docs; pointed out by Christian Maeder
Ian Lynagh <igloo@earth.li>**20110117214632] 
[ghc-cabal now adds the language flag being used
Ian Lynagh <igloo@earth.li>**20110117184833
 Ignore-this: 8198892ef7f8009561d3181425cde942
 This means we get -XHaskell98 added to the list of flags, just like we
 would if we were building with Cabal.
] 
[Reinstate the OS X flags in the LDFLAGS etc variables
Ian Lynagh <igloo@earth.li>**20110117200540
 Ignore-this: 9261baa1843100f65b02fb91c1a0d225
 I expect this will fix:
 http://www.haskell.org/pipermail/cvs-ghc/2011-January/059098.html
] 
[Add NondecreasingIndentation extension to ghc-bin
Ian Lynagh <igloo@earth.li>**20110117200427
 Ignore-this: b6b029ee6dfbda482c91d17e835f9000
] 
[Change an "if ... else return ()" into a "when"
Ian Lynagh <igloo@earth.li>**20110117191714
 Ignore-this: 7de58b728e4fce7f86d7d24a3089e6c7
] 
[Add NondecreasingIndentation to the list of extensions in ghc-pkg
Ian Lynagh <igloo@earth.li>**20110117190610
 Ignore-this: 20ce8144b7b64d1f67de2f6983717da3
] 
[Add NondecreasingIndentation to the list of extensions in the ghc package
Ian Lynagh <igloo@earth.li>**20110117190404
 Ignore-this: 516b45e93c1b3bbb66da5414d9aabef1
] 
[Fix deps on the ghc package
Ian Lynagh <igloo@earth.li>**20110117173010
 The standard libraries/$depname scheme doesn't apply, so we need to
 handle it specially.
] 
[Tidy up gmp cleaning
Ian Lynagh <igloo@earth.li>**20110117121155
 Ignore-this: 61d9a57d14b70732f62d6b2c8d6d197a
] 
[Remove redundant libraries/cabal-bin.hs
Ian Lynagh <igloo@earth.li>**20110116194919
 Ignore-this: 13b4a8d26fa06ec952351603c3bb40ee
] 
[Turn off dtrace unless you override USE_DTRACE
Ian Lynagh <igloo@earth.li>**20110116180306
 Ignore-this: beafc2002091fa7f0e66666004c870a5
 There are problems with dtrace on 64bit 10.5. For now at least, we
 just turn dtrace off unless you override USE_DTRACE
] 
[Simplify a bit of makefile
Ian Lynagh <igloo@earth.li>**20110116175218
 Ignore-this: 18f02e40e36eca2e2cab79c152c72541
] 
[Tweak Windows phase ordering
Ian Lynagh <igloo@earth.li>**20110116173459
 Ignore-this: bb8a70741be4574edc149349acd0f4be
] 
[Handle dependencies of programs on libraries correctly
Ian Lynagh <igloo@earth.li>**20110116155627] 
[It's not clear if LDFLAGS flags will be given to gcc or ld,
Ian Lynagh <igloo@earth.li>**20110116151230
 Ignore-this: a6a2d0b1f550c922c32f6f252e4e3285
 and they accept different flags, so for now do nothing
] 
[Fix cross-package dependency generation on Windows
Ian Lynagh <igloo@earth.li>**20110116150901
 Ignore-this: f78baaa7074ca36a6a4ff8a7e6f2e35
] 
[Add some Windows-only CONFIGURE_PHASEs
Ian Lynagh <igloo@earth.li>**20110116150826
 Ignore-this: abf1bf498609107eb206b22d483613de
] 
[Simplify, and future-proof, a dependency in the build system
Ian Lynagh <igloo@earth.li>**20110116020035
 Ignore-this: d089133430828d041b3601b1e9c8b22a
] 
[Remove an unnecessary phase, and some unnecessary deps
Ian Lynagh <igloo@earth.li>**20110116015943
 Ignore-this: e649b072d006db5db97aee26d3753f65
 now that cross-package deps are tracked correctly.
] 
[We can now pass -include-pkg-deps to the bootstrapping compiler
Ian Lynagh <igloo@earth.li>**20110116015714
 Ignore-this: bdfed941124bb93111f117800be5f2d8
] 
[Remove some flags that are redundant now GHC gets configured by Cabal
Ian Lynagh <igloo@earth.li>**20110116003154
 Ignore-this: 43a023c5103b72c91d53cf3bed7a4c50
] 
[Change some HC_OPTS var handling
Ian Lynagh <igloo@earth.li>**20110116003104
 Ignore-this: 629f4a3d37028f71a477c22ed4e8591e
 In particular, this means ghc gets built with -rtsopt, -threaded, etc again.
] 
[Remove some unnecessary workarounds
Ian Lynagh <igloo@earth.li>**20110116002803
 Ignore-this: 5ecc62f765522c08c44aa0814c5b840e
 We can now rely on cross-package deps working properly, as we require
 GHC 6.12.
] 
[Tidy up a bit
Ian Lynagh <igloo@earth.li>**20110116001121
 Ignore-this: a2baabc6da0cf2877507b7833d5b0fc7
] 
[Build system improvements
Ian Lynagh <igloo@earth.li>**20110115231927
 Ignore-this: 92ea6514addc8aa8734d7e0eb61b50cb
 We no longer use dummy-ghc; instead we don't configure most packages
 until the stage1 compiler is available.
   
 We also now use Cabal for building the ghc-bin package.
 
 There are a couple more sanity checks too.
] 
[Whitespace tweak
Ian Lynagh <igloo@earth.li>**20110115214149
 Ignore-this: 3e564566f311be473e94f6af609bdeaa
] 
[Fix libffi build rules
Ian Lynagh <igloo@earth.li>**20110115202104
 Ignore-this: 57e1763d2079301b0165be7deba29c85
 Fixes a rare race when both libHSffi.a and libHSffi_p.a were being built
 at the same time:
 
 "cp" libffi/dist-install/build/libffi.a libffi/dist-install/build/libHSffi.a
 "cp" libffi/dist-install/build/libffi.a libffi/dist-install/build/libHSffi.a
 "cp" libffi/dist-install/build/libffi.so libffi/dist-install/build/libHSffi-ghc7.1.20110115.so
 cp: cannot create regular file `libffi/dist-install/build/libHSffi.a': File exists
] 
[Fix Trac #4874: specialisation of INLINABLE things
simonpj@microsoft.com**20110114163227
 Ignore-this: b90543117ebddaf3bbeeaf0af0c18699
 
 Johan discovered that when INLINABLE things are specialised
 bad things can happen. This patch implements a hack -- but
 it's a simple hack and it solves the problem.
 
 See Note [Inline specialisations]. 
 
 The hack part is that really INLINABLE should not cause *any* loss
 optimisation, and it does; see Note [Don't w/w INLINABLE things] in
 WorkWrap.
] 
[Comments only
simonpj@microsoft.com**20110114162959
 Ignore-this: f76d4d8f527c3fcd2598ec8cc5fd3049
] 
[Fix a buglet in postInlineUnconditionally
simonpj@microsoft.com**20110114162927
 Ignore-this: 7a7b8610ef863907843d4ae36a8a1a3c
 
 Under obscure circumstances (actually only shown up when fixing something
 else) it was possible for a variable binding to be discarded although
 it was still used.  See Note [Top level and postInlineUnconditionally]
] 
[cope with empty libraries/stamp directory (in git repo)
Simon Marlow <marlowsd@gmail.com>**20110114142406
 Ignore-this: 6e95c44368d784f86a0c1c1d1e24d810
] 
[add .gitignore
Simon Marlow <marlowsd@gmail.com>**20110114142353
 Ignore-this: 23d7cabd2b04eedfe4c33ad94a120474
] 
[Fix longstanding bug in C-- inlining for functions calls.
Edward Z. Yang <ezyang@mit.edu>**20110113130654
 Ignore-this: 79001003b1f3cc5005207ccfed980c21
] 
[fix for remote repos without -r
Simon Marlow <marlowsd@gmail.com>**20110113131147
 Ignore-this: 3ddd8a4c616cad01a2dbdb500fb54279
] 
[add a version of packages that stores all the repos in git
Simon Marlow <marlowsd@gmail.com>**20110113111733
 Ignore-this: fcca2eb2e753ee20bb5abce7f30f5205
] 
[add the -r flag from darcs-all
Simon Marlow <marlowsd@gmail.com>**20110113111654
 Ignore-this: ada88377bd95ebb9c668dd48954f321e
] 
[Make Template Haskell classInstances function return [ClassInstance]
simonpj@microsoft.com**20110113111421
 Ignore-this: d14381f0a94170965414dd8724188356
 
 This is a recently-introduce function, which was returning
 a [Name], being the names of the dfuns.  But what you really
 want (obviously!) is the ClassInstances, and we have a TH type
 for that.
 
 This is an API change, so don't merge into GHC 7.0.  But it's
 a new part of TH which is still settling down.
 
 Fixes Trac #4863.
] 
[Improve the finder's error messages
simonpj@microsoft.com**20110113111233
 Ignore-this: ec4819b0a44af9fd03dc0a8b8e13699d
 
 I'd done all the work to add fuzzy-match suggestions, but they
 weren't really being used!  Here's what you get now
 
    module Foo where
     import Data.Lst
 
 Foo.hs:3:1:
     Failed to load interface for `Data.Lst'
     Perhaps you meant
       Data.List (from base)
       Data.List (needs flag -package haskell2010-1.0.0.0)
       Data.Int (needs flag -package haskell2010-1.0.0.0)
     Use -v to see a list of the files searched for.
] 
[White space only
simonpj@microsoft.com**20110113093931
 Ignore-this: 4e46acca5241615a3283996052a634a
] 
[Produce an error message, not a crash, for HsOpApp with non-var operator
simonpj@microsoft.com**20110112170719
 Ignore-this: df0f6f2e3318f9c33a714609019b0262
 
 Fixes Trac #4877.
] 
[update to work with current packages file format
Simon Marlow <marlowsd@gmail.com>**20110112160224
 Ignore-this: da73498734aadbfbf0a31389a9dc44d
] 
[In configure, test that GHC generates code for the correct platform (#4819)
Simon Marlow <marlowsd@gmail.com>**20110107163541
 Ignore-this: 29541d3896f9c9bcf791510edae70254
 Patch supplied by the bug reporter, tidied up by me.
 
 $ ./configure --with-ghc=$HOME/fp/bin/i386-unknown-linux/ghc --build=x86_64-unknown-linux
 checking for gfind... no
 checking for find... /usr/bin/find
 checking for sort... /usr/bin/sort
 checking for GHC version date... inferred 7.1.20110107
 checking version of ghc... 7.0.1
 checking build system type... x86_64-unknown-linux-gnu
 checking host system type... x86_64-unknown-linux-gnu
 checking target system type... x86_64-unknown-linux-gnu
 Host platform inferred as: i386-unknown-linux
 Target platform inferred as: i386-unknown-linux
 This GHC (/home/simonmar/fp/bin/i386-unknown-linux/ghc) does not generate code for the build platform
    GHC target platform    : i386-unknown-linux
    Desired build platform : x86_64-unknown-linux
] 
[Major refactoring of the type inference engine
simonpj@microsoft.com**20110112145604
 Ignore-this: 6a7fc90c9b798e89505606726cc8090e
 
 This patch embodies many, many changes to the contraint solver, which
 make it simpler, more robust, and more beautiful.  But it has taken
 me ages to get right. The forcing issue was some obscure programs
 involving recursive dictionaries, but these eventually led to a
 massive refactoring sweep.
 
 Main changes are:
  * No more "frozen errors" in the monad.  Instead "insoluble
    constraints" are now part of the WantedConstraints type.
 
  * The WantedConstraint type is a product of bags, instead of (as
    before) a bag of sums.  This eliminates a good deal of tagging and
    untagging.
 
  * This same WantedConstraints data type is used
      - As the way that constraints are gathered
      - As a field of an implication constraint
      - As both argument and result of solveWanted
      - As the argument to reportUnsolved
 
  * We do not generate any evidence for Derived constraints. They are
    purely there to allow "impovement" by unifying unification
    variables.
 
  * In consequence, nothing is ever *rewritten* by a Derived
    constraint.  This removes, by construction, all the horrible
    potential recursive-dictionary loops that were making us tear our
    hair out.  No more isGoodRecEv search either. Hurrah!
 
  * We add the superclass Derived constraints during canonicalisation,
    after checking for duplicates.  So fewer superclass constraints
    are generated than before.
 
  * Skolem tc-tyvars no longer carry SkolemInfo.  Instead, the
    SkolemInfo lives in the GivenLoc of the Implication, where it
    can be tidied, zonked, and substituted nicely.  This alone is
    a major improvement.
 
  * Tidying is improved, so that we tend to get t1, t2, t3, rather
    than t1, t11, t111, etc
 
    Moreover, unification variables are always printed with a digit
    (thus a0, a1, etc), so that plain 'a' is available for a skolem
    arising from a type signature etc. In this way,
      (a) We quietly say which variables are unification variables,
          for those who know and care
      (b) Types tend to get printed as the user expects.  If he writes
              f :: a -> a
              f = ...blah...
          then types involving 'a' get printed with 'a', rather than
          some tidied variant.
 
  * There are significant improvements in error messages, notably
    in the "Cannot deduce X from Y" messages.
] 
[Fix installation on cygwin
Ian Lynagh <igloo@earth.li>**20110111194838
 Ignore-this: fe923d0619da3bd3a34968106c92fdab
] 
[Do dependency analysis when kind-checking type declarations
simonpj@microsoft.com**20110110110351
 Ignore-this: 17a8dee32694d3e1835cf7bb02d3abb5
 
 This patch fixes Trac #4875.  The main point is to do dependency
 analysis on type and class declarations, and kind-check them in
 dependency order, so as to improve error messages.
 
 This patch means that a few programs that would typecheck before won't
 typecheck any more; but before we were (naughtily) going beyond
 Haskell 98 without any language-extension flags, and Trac #4875
 convinces me that doing so is a Bad Idea.
 
 Here's an example that won't typecheck any more
        data T a b = MkT (a b)
        type F k = T k Maybe
 
 If you look at T on its own you'd default 'a' to kind *->*;
 and then kind-checking would fail on F.
 
 But GHC currently accepts this program beause it looks at
 the *occurrences* of T.
] 
[Move imports around (no change in behaviour)
simonpj@microsoft.com**20110110105647
 Ignore-this: d618cabbc52be7d7968de1e0bdd44082
] 
[Make fuzzy matching a little less eager for short identifiers
simonpj@microsoft.com**20110107102855
 Ignore-this: a753643e88433d74b44a480cc0f4170c
 
 For single-character identifiers we now don't make any suggestions
 See comments in Util.fuzzyLookup
] 
[Fix Trac #4870: get the inlining for an imported INLINABLE Id
simonpj@microsoft.com**20110105002712
 Ignore-this: 60c0192eb48590c2e6868d15ba8f84ce
 
 We need the unfolding even for a *recursive* function (indeed
 that's the point) and I was using the wrong function to get it
 (idUnfolding rather than realIdUnfolding).
] 
[Rejig the includes/ installation rules
Ian Lynagh <igloo@earth.li>**20110109181158
 They're a little nicer now, and a regression in the cygwin build is
 fixed (the $i in the destination wasn't surviving being passed through
 cygpath).
] 
[Make DESTDIR an absolute path when installing; fixes #4883
Ian Lynagh <igloo@earth.li>**20110108171635] 
[Add utils/ghc-cabal/Makefile
Ian Lynagh <igloo@earth.li>**20110108144049] 
[Remove redundant import
Ian Lynagh <igloo@earth.li>**20110108130047
 Ignore-this: 1c7fdec77b48319c845c9593b5fb94af
] 
[Improve error message of :set in ghci (ticket #4190).
Michal Terepeta <michal.terepeta@gmail.com>**20101130211505
 Ignore-this: ccc8a0816a900ba8c4a966285a465b23
] 
[Improve error message when importing data constructors (ticket #4058).
Michal Terepeta <michal.terepeta@gmail.com>**20101127211338
 Ignore-this: 3289a08f0391dd90dfef2e0403a04ccd
] 
[catch SIGTSTP and save/restore terminal settings (#4460)
Simon Marlow <marlowsd@gmail.com>**20110107124042
 Ignore-this: 38f7f27bf75178899f466404c048241d
 As far as I can tell, it is the responsibility of the program to save
 and restore its own terminal settings across a suspend/foreground, the
 shell doesn't do it (which seems odd).  So I've added a signal handler
 for SIGTSTP to the RTS which will save and restore the terminal
 settings iff we modified them with hSetBuffering or hSetEcho (we
 already restore them at exit time in these cases).
] 
[comment updates
Simon Marlow <marlowsd@gmail.com>**20110107094236
 Ignore-this: c2b30b0c98645e2847a2749c7fdc167f
] 
[On Cygwin, use a Cygwin-style path for /bin/install's destination
Ian Lynagh <igloo@earth.li>**20110106223030
 
 cygwin's /bin/install doesn't set file modes correctly if the
 destination path is a C: style path:
 
 $ /bin/install -c -m 644 foo /cygdrive/c/cygwin/home/ian/foo2
 $ /bin/install -c -m 644 foo c:/cygwin/home/ian/foo3
 $ ls -l foo*
 -rw-r--r-- 1 ian None 0 2011-01-06 18:28 foo
 -rw-r--r-- 1 ian None 0 2011-01-06 18:29 foo2
 -rwxrwxrwx 1 ian None 0 2011-01-06 18:29 foo3
 
 This causes problems for bindisttest/checkBinaries.sh which then
 thinks that e.g. the userguide HTML files are binaries.
 
 We therefore use a /cygdrive path if we are on cygwin
] 
[Fix mkUserGuidePart program name on Windows
Ian Lynagh <igloo@earth.li>**20110106143707] 
[add comment to remind people to update driver/gcc/gcc.c
Simon Marlow <marlowsd@gmail.com>**20110106152402
 Ignore-this: c07d7ac11eb9221ef821f78aab1807cb
] 
[use Win32 CreateProcess() rather than mingw spawnv() (#4531)
Simon Marlow <marlowsd@gmail.com>**20110106133834
 Ignore-this: 4c0947853549dad034622c044391af6c
] 
[update paths now that we upgraded gcc to 4.5.0
Simon Marlow <marlowsd@gmail.com>**20110106133729
 Ignore-this: f8f9bcad984fdd472e0ae958b66bea9d
] 
[fix markup
Simon Marlow <marlowsd@gmail.com>**20110106093152
 Ignore-this: 555b6e39ae6b5a177b03c5edffc169ab
] 
[fix up multi-line GHCi patch (#4316)
Simon Marlow <marlowsd@gmail.com>**20110105154548
 Ignore-this: 53d5d489bd2a792c01f2cc56a11f3ce6
] 
[multiline commands in GHCi #4316
Vivian McPhail <haskell.vivian.mcphail@gmail.com>**20101105051308
 This patch adds support for multiline commands in GHCi.
 
 The first line of input is lexed.  If there is an active
 layout context once the lexer reaches the end of file, the
 user is prompted for more input.
 
 Multiline input is exited by an empty line and can be escaped 
 with a user interrupt.
 
 Multiline mode is toggled with `:set +m`
] 
[Replace a #if with a Haskell conditional
Ian Lynagh <igloo@earth.li>**20110105183011
 Ignore-this: f08f3a4356586efab2725ad8704b2eba
] 
[Whitespace only in X86.Ppr
Ian Lynagh <igloo@earth.li>**20110105171124] 
[Fix error compiling AsmCodeGen.lhs for PPC Mac (unused makeFar addr)
naur@post11.tele.dk**20101219213555
 Ignore-this: ab25d5f2e2ebe163547d5babaf4b1dbf
] 
[Define cTargetArch and start to use it rather than ifdefs
Ian Lynagh <igloo@earth.li>**20110104220013
 Using Haskell conditionals means the compiler sees all the code, so
 there should be less rot of code specific to uncommon arches. Code
 for other platforms should still be optimised away, although if we want
 to support targetting other arches then we'll need to compile it
 for-real anyway.
] 
[Fix error compiling AsmCodeGen.lhs for PPC Mac (rtsPackageId)
naur@post11.tele.dk**20101219212530
 Ignore-this: 946f6d3e0d3c3ddf2dc07b85e1f82d85
] 
[Rename the c*Platform variables to c*PlatformString
Ian Lynagh <igloo@earth.li>**20110104210250] 
[Fix #4829 (build does not respect --with-gcc option)
gwright@antiope.com**20101221133233
 Ignore-this: 37918feb82f911c2beb75915b6e8b97b
 
 This patch fixes what seems to be the last problem with the --with-gcc
 option.  On OS X, we need to pass the path to gcc to dtrace as the
 preprocessor.  (Internally, dtrace on OS X sets the default preprocessor
 to /usr/bin/gcc.)  ATM, dtrace is only supported on OS X, so we don't
 need any conditionalization.  If dtrace is ported to other platforms,
 we might need to change this. However, usage on other platforms will
 probably be similar to OS X, since many of Apple's changes are to
 use the gnu toolchain instead of the Sun toolchain.
   
] 
[Drop a seven years old workaround for happy
Matthias Kilian <kili@outback.escape.de>**20101231192343
 Ignore-this: a9348c91292c113bd967464fbe859f1f
] 
[Add gcc and ld flags to --info output
Ian Lynagh <igloo@earth.li>**20101220173520] 
[Fix Trac #4525: report type errors in terms of the immediate type synonym
simonpj@microsoft.com**20101224082520
 Ignore-this: a3bd076bfe0e1c6f575b106f77f326c6
 
 This small change means that if you have
      type Age = Int
 and you try to unify Age and Bool, you'll get a complaint about
 not matching Age and Bool, rather than Int and Bool.  See the notes
 with Trac #4525
] 
[Comments only
simonpj@microsoft.com**20101224082310
 Ignore-this: 1f69fa3244663b653607093efcdf7b0
] 
[Implement fuzzy matching for the Finder
simonpj@microsoft.com**20101222175400
 Ignore-this: 4dfbbc07bcb59c5f4cee9a902c89d63e
 
 ..so that you get a more helpful message when
 you mis-spell a module name in an 'import'.
 
 Validates, but not fully tested.
 
 Based on Max's patch in Trac #2442, but heavily refactored.
] 
[Implement fuzzy matching for the renamer
simonpj@microsoft.com**20101222175306
 Ignore-this: 66478736249de793a61612f184d484b0
 
 ...so that you get helpful suggestions when you mis-spell a name
 Based on Max's patch in Trac #2442, but heavily refactored.
] 
[Add fuzzyLookup, a variant of fuzzyMatch
simonpj@microsoft.com**20101222175124
 Ignore-this: f0eafaf275b9edffee176f2fb4effe2f
 
 Plus, I changed quite a bit of layout to make the lines shorter.
] 
[White space only
simonpj@microsoft.com**20101222175001
 Ignore-this: ddabada2042f4529e83d1c1ecb052306
] 
[Layout and white space only
simonpj@microsoft.com**20101222174950
 Ignore-this: bf4e4fd9d39714d0461ab799d6b8ed91
] 
[Tidy up rebindable syntax for MDo
simonpj@microsoft.com**20101222132210
 Ignore-this: b40ae8709e5a39d75f2b2813169af215
 
 For a long time an 'mdo' expression has had a SyntaxTable
 attached to it.  However, we're busy deprecating SyntaxTables
 in favour of rebindable syntax attached to individual Stmts,
 and MDoExpr was totally inconsistent with DoExpr in this
 regard.
 
 This patch tidies it all up.  Now there's no SyntaxTable on
 MDoExpr, and 'modo' is generally handled much more like 'do'.
 
 There is resulting small change in behaviour: now MonadFix is
 required only if you actually *use* recursion in mdo. This
 seems consistent with the implicit dependency analysis that
 is done for mdo.
 
 Still to do:
   * Deal with #4148 (this patch is on the way)
   * Get rid of the last remaining SyntaxTable on HsCmdTop
] 
[Make the occurrence analyser track preInlineUnconditionally
simonpj@microsoft.com**20101222131156
 Ignore-this: 82edb06bcca6106327c2cce9d78c4e61
 
 This fixes a somewhat obscure situation in which an
 over-optimistic use of "occurs once" led to an infinite
 sequence of simplifier iterations.  Se Note [Cascading inlines]
 for the details.
 
 This showed up when compiling rather large DPH programs, which
 run lots of iterations of the simplifier, which in turn made
 compilation take much longer than necessary.
] 
[Make mkDFunUnfolding more robust
simonpj@microsoft.com**20101222130854
 Ignore-this: 10bb4168a7080c843f6613043354151b
 
 It now uses tcSplitDFunTy, which is designed for the purpose and
 allows arbitrary argument types to the dfun, rather than
 tcSplitSigmaTy.  This generality is used in DPH, which has
 internally-generated dfuns with impliciation-typed arguments.
 
 To do this I had to make tcSplitDFunTy return the number of
 arguments, so there are some minor knock-on effects in other
 modules.
] 
[Count allocations more accurately
Simon Marlow <marlowsd@gmail.com>**20101221152956
 Ignore-this: 33a4ed3a77bf35f232aa5c9078e8e380
 The allocation stats (+RTS -s etc.) used to count the slop at the end
 of each nursery block (except the last) as allocated space, now we
 count the allocated words accurately.  This should make allocation
 figures more predictable, too.
 
 This has the side effect of reducing the apparent allocations by a
 small amount (~1%), so remember to take this into account when looking
 at nofib results.
] 
[Add a simple arity analyser
simonpj@microsoft.com**20101221165800
 Ignore-this: d5f3a9f56404d61bb7f374c875b42c49
 
 I've wanted to do this for ages, but never gotten around to
 it.  The main notes are in Note [Arity analysis] in SimplUtils.
 
 The motivating example for arity analysis is this:
 
   f = \x. let g = f (x+1)
           in \y. ...g...
 
 What arity does f have?  Really it should have arity 2, but a naive
 look at the RHS won't see that.  You need a fixpoint analysis which
 says it has arity "infinity" the first time round.
 
 This makes things more robust to the way in which you write code.  For
 example, see Trac #4474 which is fixed by this change.
 
 Not a huge difference, but worth while:
 
         Program           Size    Allocs   Runtime   Elapsed
 --------------------------------------------------------------------------------
             Min          -0.4%     -2.2%    -10.0%    -10.0%
             Max          +2.7%     +0.3%     +7.1%     +6.9%
  Geometric Mean          -0.3%     -0.2%     -2.1%     -2.2%
 
 I don't really believe the runtime numbers, because the machine was
 busy, but the bottom line is that not much changes, and what does
 change reliably (allocation and size) is in the right direction.
] 
[Miscellaneous tidying up and refactoring
simonpj@microsoft.com**20101221161931
 Ignore-this: 7706d3065e6fc1defafe1cb8975b9969
] 
[Comments only
simonpj@microsoft.com**20101221161918
 Ignore-this: 3e269a62da5cbec72d3e4b8328689628
] 
[Single-method classes are implemented with a newtype
simonpj@microsoft.com**20101221161911
 Ignore-this: 4ca00f0b367fbeb8146146bc53116eb7
 
 This patch changes things so that such classes rely on the coercion
 mechanism for inlining (since the constructor is really just a cast)
 rather than on the dfun mechanism, therby removing some needless
 runtime indirections.
] 
[For single-method classes use newtypes
simonpj@microsoft.com**20101101080736
 Ignore-this: d3851f92eb2385501411da57066b775e
 
 This clears up an awkward hack for exprIsConApp_maybe, and
 works better too.  See Note [Single-method classes] in
 TcInstDcls.
] 
[boundTaskExiting: don't set task->stopped unless this is the last call (#4850)
Simon Marlow <marlowsd@gmail.com>**20101221115807
 Ignore-this: 7e1b990aa08b3ea9cdaa9385d8e41e48
 The bug in this case was that we had a worker thread making a foreign
 call which invoked a callback (in this case it was performGC, I
 think).  When the callback ended, boundTaskExiting() was setting
 task->stopped, but the Task is now per-OS-thread, so it is shared by
 the worker that made the original foreign call.  When the foreign call
 returned, because task->stopped was set, the worker was not placed on
 the queue of spare workers.  Somehow the worker woke up again, and
 found the spare_workers queue empty, which lead to a crash.
 
 Two bugs here: task->stopped should not have been set by
 boundTaskExiting (this broke when I split the Task and InCall structs,
 in 6.12.2), and releaseCapabilityAndQueueWorker() should not be
 testing task->stopped anyway, because it should only ever be called
 when task->stopped is false (this is now an assertion).
] 
[releaseCapabilityAndQueueWorker: task->stopped should be false (#4850)
Simon Marlow <marlowsd@gmail.com>**20101221114911
 Ignore-this: b9c430a4bc9d2e0c7f4140d6d6971eae
] 
[Fix Windows build
Simon Marlow <marlowsd@gmail.com>**20101221102101
 Ignore-this: f4773e06d030a335c9ac721af193b8d2
] 
[raiseExceptionHelper: update tso->stackobj->sp before calling threadStackOverflow (#4845)
Simon Marlow <marlowsd@gmail.com>**20101221101411
 Ignore-this: 48495131fcc8c548882a470c2509f9f5
] 
[add 'make re2' for rebuilding stage2 (similarly re1 and re3)
Simon Marlow <marlowsd@gmail.com>**20101221100254
 Ignore-this: 5c0afe3810b66a5b6e53a3a0fe933945
] 
[fix warning
Simon Marlow <marlowsd@gmail.com>**20101216160415
 Ignore-this: 54a0eedfa5b7fc15c31dffffb1b10aad
] 
[Small improvement to CorePrep
simonpj@microsoft.com**20101220123715
 Ignore-this: d0490225ed1895a1a5b97d786ed44260
 
 This change avoids unnecessary bindings. Example
 
      foo (let fn = \x.blah in
           in fn)
 
 We were generating something stupid like
 
     let fn = \x.blah in
     let fn' = \eta. fn eta
     in foo fn
 
 Now we don't.  The change is quite small.
 
 Thanks to Ben for showing me an example of this happening.
] 
[Fix warnings
Ian Lynagh <igloo@earth.li>**20101219202711
 Ignore-this: 898015b086f684de5371bf97a23b9e2e
] 
[Small refactoring
Ian Lynagh <igloo@earth.li>**20101219194032] 
[Drop GhcWithLlvmCodeGen configuration bits
Matthias Kilian <kili@outback.escape.de>**20101219180239
 Ignore-this: 815ed46be7650792f85807c232edfcc
 The LLVM code generator is always built unconditionally, so both the
 configuration variable in mk/config.mk.in as well as the string in
 compilerInfo can be removed.
] 
[Pass --hoogle to haddock; fixes trac #4521
Ian Lynagh <igloo@earth.li>**20101219125243] 
[vectoriser: don't always pass superclass dictionaries to PA dfuns
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101218234838
 Ignore-this: 77c71976db8fc63aeb83f4abdba994d8
 
 This is just a guess at how this should work.
] 
[vectoriser: delete dead code
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101218125350
 Ignore-this: 437eea71ad15ad5dc7902e596597c577
] 
[vectoriser: adapt to new superclass story part I (dictionary construction)
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101218114953
 Ignore-this: 29c9aa46a1622beaae1dcefc4c482a30
] 
[Replace uses of the old try function with the new one
Ian Lynagh <igloo@earth.li>**20101218230827
 Ignore-this: 5dd6c1a4142405aa1aab3fc4ec07eea6
] 
[Replace uses of the old catch function with the new one
Ian Lynagh <igloo@earth.li>**20101218213350] 
[Create ~/.ghc/ if it doesn't already exist; fixes trac #4522
Ian Lynagh <igloo@earth.li>**20101218184925] 
[Document GADTSyntax extension
Ian Lynagh <igloo@earth.li>**20101218150121] 
[Implement GADTSyntax extension
Ian Lynagh <igloo@earth.li>**20101218144550] 
[Whitespace-only in rts/Linker.c
Ian Lynagh <igloo@earth.li>**20101217234124] 
[Add some casts to fix warnings; patch from Greg Wright
Ian Lynagh <igloo@earth.li>**20101217223811] 
[Put an up-to-date Makefile in docs/Makefile
Ian Lynagh <igloo@earth.li>**20101217223707
 It doesn't do anything useful yet, but it works with the new build system
] 
[do not compile part of shared lib RTS with -fno-PIC on Solaris
Karel Gardas <karel.gardas@centrum.cz>**20101217085133
 Ignore-this: 8c8dbb45cac0578a58a3557f1e03c66
] 
[provide shared libraries support on i386-unknown-solaris2 platform
Karel Gardas <karel.gardas@centrum.cz>**20101217084617
 Ignore-this: b6079c6a39a71200a1ee863573e40828
] 
[fix CPP detection of Solaris in NCG
Karel Gardas <karel.gardas@centrum.cz>**20101217084510
 Ignore-this: 9d1ce59d469294eab1f0cbc697e48d69
] 
[Fix checkBinaries on OS X
Ian Lynagh <igloo@earth.li>**20101216201121] 
[Remove redundant HpcMap and HpcSet wrappers around Data.{Map,Set}
Ian Lynagh <igloo@earth.li>**20101216190605] 
[Use "-perm -u+x" rather than "-executable" to find executables
Ian Lynagh <igloo@earth.li>**20101216145235
 On Windows, -executable is matching the html docs.
] 
[Remove a debugging print
Ian Lynagh <igloo@earth.li>**20101216011459] 
[__GLASGOW_HASKELL__ >= 604 is now always true
Ian Lynagh <igloo@earth.li>**20101215214656] 
[Remove more dead code now we require GHC >= 6.12
Ian Lynagh <igloo@earth.li>**20101215213715] 
[refactor and tidy up the section on RTS options
Simon Marlow <marlowsd@gmail.com>**20101216123151
 Ignore-this: 9cdafd687351d8a3ff879b64347f85d3
] 
[Related to #4826: Some minor tweaks to the wording of the User Guide, section 4.16
Orphi <MathematicalOrchid@hotmail.com>**20101209170440
 Ignore-this: c3d942d58594be7d4c2eb4dc3a22f19
] 
[FIX #4826 partial: Add -rtsopts and -with-rtsopts to User Guide section 4.11.6
Orphi <MathematicalOrchid@hotmail.com>**20101209165152
 Ignore-this: 2fc1c0abbb783695773ab0f9c013bbaa
] 
[FIX #4826 partially: Change -f to -? in User Guide section F4.16
Orphi <MathematicalOrchid@hotmail.com>**20101209144148
 Ignore-this: 73410b350e80c8943ae722dec8dea44b
] 
[fix #3910
Simon Marlow <marlowsd@gmail.com>**20101216114452
 Ignore-this: 410e95e188344a523520e192a3fb58ea
] 
[remove an optimisation that wasn't
Simon Marlow <marlowsd@gmail.com>**20101215152656
 Ignore-this: e8413f58e8292c6e7463087d885b3a7d
] 
[fix a warning
Simon Marlow <marlowsd@gmail.com>**20101216105723
 Ignore-this: ed6024378021a698ce638267ed3e21ab
] 
[use EXTERN_INLINE instead of STATIC_INLINE to avoid some gcc warnings
Simon Marlow <marlowsd@gmail.com>**20101216105709
 Ignore-this: d4e1586cf318883a8e611b55df7fbf10
] 
[remove dead code
Simon Marlow <marlowsd@gmail.com>**20101216104944
 Ignore-this: 97a04a3e37c1b28abc222a28bab3d17d
] 
[fix retainer profiling: add missing case for TSO
Simon Marlow <marlowsd@gmail.com>**20101216103900
 Ignore-this: 11bda81ac159f638d719c1f6177702fb
] 
[add a missing STACK case
Simon Marlow <marlowsd@gmail.com>**20101216102100
 Ignore-this: ac1c036b5cbf4209b1d10b6ab1c83f27
] 
[Remove code that is dead now that we need >= 6.12 to build
Ian Lynagh <igloo@earth.li>**20101215201006] 
[fix for large stack allocations
Simon Marlow <marlowsd@gmail.com>**20101215152419
 Ignore-this: d9aca17d68bd99214c126989a2318e79
] 
[Implement stack chunks and separate TSO/STACK objects
Simon Marlow <marlowsd@gmail.com>**20101215120843
 Ignore-this: 73fa9460314d4a4e54456af12bef7960
 
 This patch makes two changes to the way stacks are managed:
 
 1. The stack is now stored in a separate object from the TSO.
 
 This means that it is easier to replace the stack object for a thread
 when the stack overflows or underflows; we don't have to leave behind
 the old TSO as an indirection any more.  Consequently, we can remove
 ThreadRelocated and deRefTSO(), which were a pain.
 
 This is obviously the right thing, but the last time I tried to do it
 it made performance worse.  This time I seem to have cracked it.
 
 2. Stacks are now represented as a chain of chunks, rather than
    a single monolithic object.
 
 The big advantage here is that individual chunks are marked clean or
 dirty according to whether they contain pointers to the young
 generation, and the GC can avoid traversing clean stack chunks during
 a young-generation collection.  This means that programs with deep
 stacks will see a big saving in GC overhead when using the default GC
 settings.
 
 A secondary advantage is that there is much less copying involved as
 the stack grows.  Programs that quickly grow a deep stack will see big
 improvements.
 
 In some ways the implementation is simpler, as nothing special needs
 to be done to reclaim stack as the stack shrinks (the GC just recovers
 the dead stack chunks).  On the other hand, we have to manage stack
 underflow between chunks, so there's a new stack frame
 (UNDERFLOW_FRAME), and we now have separate TSO and STACK objects.
 The total amount of code is probably about the same as before.
 
 There are new RTS flags:
 
    -ki<size> Sets the initial thread stack size (default 1k)  Egs: -ki4k -ki2m
    -kc<size> Sets the stack chunk size (default 32k)
    -kb<size> Sets the stack chunk buffer size (default 1k)
 
 -ki was previously called just -k, and the old name is still accepted
 for backwards compatibility.  These new options are documented.
] 
[comments on SRC_HC_OPTS (#4829)
Simon Marlow <marlowsd@gmail.com>**20101214101340
 Ignore-this: e2bdec00f07b68e82837e77a4faf6514
] 
[fix another sanity error, and refactor/tidy up
Simon Marlow <marlowsd@gmail.com>**20101209163919
 Ignore-this: d5ce953ac78e90fc0e22cd9848d26e2e
] 
[Fix a bug in functorLikeTraverse, which was giving wrong answer for tuples
simonpj@microsoft.com**20101215123725
 Ignore-this: 560220e92429b5b1a6197a62f94a4ff2
 
 This bug led to Trac #4816, which is hereby fixed
] 
[Improve printing for -ddump-deriv
simonpj@microsoft.com**20101215121955
 Ignore-this: 3181c948c4c2471bd99b32c5ee487a1e
] 
[Tighten up what it means to be an "enumeration data constructor"
simonpj@microsoft.com**20101215121927
 Ignore-this: 459b3f9f7994a13094ed87b0768b33a8
 
 See Note [Enumeration types] in TyCon, and comments in Trac #4528
] 
[Allow enumerations to have phantom arguments.
simonpj@microsoft.com**20101215121817
 Ignore-this: 32ef8cb869e6e38c2e43b3ae87b1b9a8
 
 The bytecode generator was being too eager.
 Fixes Trac #4528, or rather, a near variant.
] 
[Instance declaration overlap allowed if *either* has -XOverlappingInstances
simonpj@microsoft.com**20101214180500
 Ignore-this: f1b1492541a7e0464ebc6adb45510a2e
 
 This satisfies Trac #3877.  Documentation is changed too.
 I'm not sure if this should go in 7.0.2.
] 
[Fix Trac #4841: behave right with TypeSynonymInstances and NoFlexibleInstances
simonpj@microsoft.com**20101214174755
 Ignore-this: dccd707fdca84904b7885170a296ecb6
 
 When we have TypeSynonymInstances without FlexibleInstances we should still
 insist on a H98-style instance head, after looking through the synonym.
 
 This patch also make FlexibleInstances imply TypeSynonymInstances.  Anything
 else is a bit awkward, and not very useful.
 
] 
[Fix Trac #3731: more superclass subtlety (sigh)
simonpj@microsoft.com**20101214180344
 Ignore-this: f4168e59f3164303ba7be022ba19c37b
 
 I will add more comments, but I want to commit this tonight,
 so the overnight builds get it.
] 
[Less verbose debug print
simonpj@microsoft.com**20101214180248
 Ignore-this: e405e8545763e913155abe43daf7e36c
] 
[Wibble to InstEnv.instanceHead
simonpj@microsoft.com**20101214082939
 Ignore-this: 851db517f8638a0aeb7ad461298f7e9f
 
 Fixes an accidental glitch in T1835
] 
[Remove dead code now that we require the bootstrapping compiler be >= 6.12
Ian Lynagh <igloo@earth.li>**20101214011011] 
[GHC 6.12 is now needed to build the HEAD
Ian Lynagh <igloo@earth.li>**20101214010923] 
[Add libstdc++-4.5.0-1-mingw32-dll-6.tar.lzma to mingw tarballs
Ian Lynagh <igloo@earth.li>**20101213223153] 
[Fix recursive superclasses (again).  Fixes Trac #4809.
simonpj@microsoft.com**20101213171511
 Ignore-this: b91651397918fd8f0183812f9a070073
 
 This patch finally deals with the super-delicate question of
 superclases in possibly-recursive dictionaries.  The key idea
 is the DFun Superclass Invariant (see TcInstDcls):
 
      In the body of a DFun, every superclass argument to the
      returned dictionary is
        either   * one of the arguments of the DFun,
        or       * constant, bound at top level
 
 To establish the invariant, we add new "silent" superclass
 argument(s) to each dfun, so that the dfun does not do superclass
 selection internally.  There's a bit of hoo-ha to make sure that
 we don't print those silent arguments in error messages; a knock
 on effect was a change in interface-file format.
 
 A second change is that instead of the complex and fragile
 "self dictionary binding" in TcInstDcls and TcClassDcl,
 using the same mechanism for existential pattern bindings.
 See Note [Subtle interaction of recursion and overlap] in TcInstDcls
 and Note [Binding when looking up instances] in InstEnv.
 
 Main notes are here:
 
   * Note [Silent Superclass Arguments] in TcInstDcls,
     including the DFun Superclass Invariant
 
 Main code changes are:
 
   * The code for MkId.mkDictFunId and mkDictFunTy
 
   * DFunUnfoldings get a little more complicated;
     their arguments are a new type DFunArg (in CoreSyn)
 
   * No "self" argument in tcInstanceMethod
   * No special tcSimplifySuperClasss
   * No "dependents" argument to EvDFunApp
 
 IMPORTANT
    It turns out that it's quite tricky to generate the right
    DFunUnfolding for a specialised dfun, when you use SPECIALISE
    INSTANCE.  For now I've just commented it out (in DsBinds) but
    that'll lose some optimisation, and I need to get back to
    this.
] 
[Doing the smart canonicalization only if we are not simplifying a Rule LHS.
dimitris@microsoft.com**20101210132221
 Also, same thing now applies for adding superclasses.
 
] 
[Moved canonicalisation inside solveInteract
dimitris@microsoft.com**20101209141215
 
 Moreover canonicalisation now is "clever", i.e. it never canonicalizes a class 
 constraint if it can already discharge it from some other inert or previously
 encountered constraints. See Note [Avoiding the superclass explosion]
 
] 
[GHCi linker: Assume non-Haskell libraries are dynamic libs
Ian Lynagh <igloo@earth.li>**20101213124930
 Ignore-this: aa153a8f6e309c7b3dae7e46bb7a9583
 This works around a segfault we get when trying to load libiconv.a on
 some platforms.
] 
[Add --version support to ghc-cabal
Ian Lynagh <igloo@earth.li>**20101212213600
 Ignore-this: ef696dcb1b96a23765f9f18e75a56f5
] 
[Don't link the GHC RTS into our C-only programs
Ian Lynagh <igloo@earth.li>**20101210185402
 Ignore-this: 56f620f7eb16a03e7497a161bc48458e
] 
[Build a copy of ghc-cabal with the in-tree compiler, for the bindist
Ian Lynagh <igloo@earth.li>**20101210181123] 
[Add a test that all programs in the bindist were built with the right GHC
Ian Lynagh <igloo@earth.li>**20101210161218
 They should use the GHC from the build tree, not the bootstrapping compiler.
] 
[Fix Trac #4534: renamer bug
simonpj@microsoft.com**20101210084530
 Ignore-this: 8163bfa3a56344cfe89ad17c62e9655d
   
 The renamer wasn't attaching the right used-variables to a
 TransformStmt constructor.
 
 The real modification is in RnExpr; the rest is just
 pretty-printing and white space.
] 
[White space only
simonpj@microsoft.com**20101210084255
 Ignore-this: 3fcf8a4fc8c15052c379a135951d53ea
] 
[Comments only
simonpj@microsoft.com**20101210084116
 Ignore-this: 55bb1de129b1c9513751885eaa84b884
] 
[Make the case-to-let transformation a little less eager
simonpj@microsoft.com**20101208172251
 Ignore-this: 55eaa1b5753af31aeb32ec792cb6b662
 
 See Note [Case elimination: lifted case].
 Thanks to Roman for identifying this case.
] 
[warning fix: don't redefine BLOCKS_PER_MBLOCK
Simon Marlow <marlowsd@gmail.com>**20101210094002
 Ignore-this: cadba57f1c38f5e2af1de37d0a79c7ee
] 
[Only reset the event log if logging is turned on (addendum to #4512)
Simon Marlow <marlowsd@gmail.com>**20101210093951
 Ignore-this: c9f85f0de2b11a37337672fba59aecc6
] 
[allocate enough room for the longer filename (addendum to #4512)
Simon Marlow <marlowsd@gmail.com>**20101210093906
 Ignore-this: 270dc0219d98f1e0f9e006102ade7087
] 
[Fix Windows build: move rtsTimerSignal to the POSIX-only section
Simon Marlow <marlowsd@gmail.com>**20101210090045
 Ignore-this: aa1844b70b9f1a44447787c4bbe10d44
] 
[Default the value of -dppr-cols when the static flags aren't initialised yet
Ben Lippmeier <benl@ouroborus.net>**20101210060154
 Ignore-this: 4cea29085ef904f379a8829714c9e180
 If GHC's command line options are bad then the options parser uses the
 pretty printer before the -dppr-cols flag has been read.
] 
[Defensify naked read in LLVM mangler
Ben Lippmeier <benl@ouroborus.net>**20101210045922
 Ignore-this: 1373f597863851bd03e7a7254558ed04
] 
[Formatting only
Ben Lippmeier <benl@ouroborus.net>**20101210042600
 Ignore-this: 20bbcd95c70b59094d0bb8a63e459103
] 
[Always ppr case alts on separate lines
Ben Lippmeier <benl@ouroborus.net>**20101208070508
 Ignore-this: 7e2edd57a61427621aeb254aef84f0f7
] 
[Add -dppr-colsN to set width of dumps
Ben Lippmeier <benl@ouroborus.net>**20101208070245
 Ignore-this: edc64fee6c373b895bb80b83b549ce1a
] 
[Add -dppr-case-as-let to print "strict lets" as actual lets
Ben Lippmeier <benl@ouroborus.net>**20101208065548
 Ignore-this: eb1d122dbd73b5263cae3a9f8259a838
] 
[Suppress more info with -dsuppress-idinfo
Ben Lippmeier <benl@ouroborus.net>**20101208063037
 Ignore-this: 5e8213d7b8d2905e245917aa3e83efc5
] 
[Implement -dsuppress-type-signatures
Ben Lippmeier <benl@ouroborus.net>**20101208062814
 Ignore-this: 34dbefe5f8d7fe58ecb26d6a748d1c71
] 
[Add more suppression flags
Ben Lippmeier <benl@ouroborus.net>**20101208020723
 Ignore-this: b010ba9789a2fde6b815f33494fcc23c
  -dsuppress-all
  -dsuppress-type-applications
  -dsuppress-idinfo
] 
[fix ticket number (#4505)
Simon Marlow <marlowsd@gmail.com>**20101209120404
 Ignore-this: 5769c5ce2a8d69d62d977a9ae138ec23
] 
[fix warnings
Simon Marlow <marlowsd@gmail.com>**20101209115844
 Ignore-this: ffff37feb2abbfc5bd12940c7007c208
] 
[Catch too-large allocations and emit an error message (#4505)
Simon Marlow <marlowsd@gmail.com>**20101209114005
 Ignore-this: c9013ab63dd0bd62ea045060528550c6
 
 This is a temporary measure until we fix the bug properly (which is
 somewhat tricky, and we think might be easier in the new code
 generator).
 
 For now we get:
 
 ghc-stage2: sorry! (unimplemented feature or known bug)
   (GHC version 7.1 for i386-unknown-linux):
         Trying to allocate more than 1040384 bytes.
 
 See: http://hackage.haskell.org/trac/ghc/ticket/4550
 Suggestion: read data from a file instead of having large static data
 structures in the code.
] 
[Export the value of the signal used by scheduler (#4504)
Dmitry Astapov <dastapov@gmail.com>**20101208183755
 Ignore-this: 427bf8c2469283fc7a6f759440d07d87
] 
[Tweak the "sorry" message a bit
Simon Marlow <marlowsd@gmail.com>**20101208163212
 Ignore-this: aa1ce5bc3c27111548204b740572efbe
 
 -		"sorry! (this is work in progress)\n"
 +		"sorry! (unimplemented feature or known bug)\n"
] 
[:unset settings support
Boris Lykah <lykahb@gmail.com>**20101123190132
 Ignore-this: 5e97c99238f5d2394592858c34c004d
 Added support for settings [args, prog, prompt, editor and stop].
 Now :unset supports the same set of options as :set.
] 
[Fix Windows memory freeing: add a check for fb == NULL; fixes trac #4506
Ian Lynagh <igloo@earth.li>**20101208152349
 Also added a few comments, and a load of code got indented 1 level deeper.
] 
[Fixes for #4512: EventLog.c - provides ability to terminate event logging, Schedule.c - uses them in forkProcess.
Dmitry Astapov <dastapov@gmail.com>**20101203133950
 Ignore-this: 2da7f215d6c22708a18291a416ba8881
] 
[Make CPPFLAGS variables, as well as CFLAGS and LDFLAGS
Ian Lynagh <igloo@earth.li>**20101207010033
 Ignore-this: 2fc1ca1422aae1988d0fe1d29a8485d9
 This fixes the "does unsetenv return void" test in the unix package on
 OS X, if I tell it to make 10.4-compatible binaries. The test uses
 CPPFLAGS but not CFLAGS, so it thought it returned int (as it was
 in 10.5-mode), but the C compiler (using CFLAGS, so in 10.4 mode)
 thought it returned void.
 
 I also added CONF_LD_OPTS_STAGE$3 to the list of things in LDFLAGS,
 which looks like an accidental ommission.
] 
[Add a configure message
Ian Lynagh <igloo@earth.li>**20101206215201] 
[Link even programs containing no Haskell modules with GHC
Ian Lynagh <igloo@earth.li>**20101206203329
 I don't remember why we made it use gcc instead, but going back to
 using ghc doesn't seem to break anything, and should fix the build
 on OS X 10.6.
] 
[Correct the stage that the includes/ tools are built in
Ian Lynagh <igloo@earth.li>**20101206203125] 
[Tweak the cleaning of inplace/; fixes trac #4320
Ian Lynagh <igloo@earth.li>**20101205212048] 
[Close .ghci files after reading them; fixes trac #4487
Ian Lynagh <igloo@earth.li>**20101205205301] 
[Fix the behaviour of :history for ticks surrounding top level functions
pepeiborra@gmail.com**20101203202346
 Ignore-this: 8059d4859c52c0c9a235b937cb8cde1d
] 
[Don't warn of duplicate exports in case of module exports.
Michal Terepeta <michal.terepeta@gmail.com>**20101127212116
 Ignore-this: ea225d517826f971c400bbb68d1405b8
 
 But only when the module exports refer to different modules.
 See ticket #4478.
] 
[Fix whitespace/layout in RnNames.
Michal Terepeta <michal.terepeta@gmail.com>**20101030171303
 Ignore-this: 707a7955fc4fc51683cc5a1dfe57f93
] 
[Tell gcc to support back to OS X 10.5
Ian Lynagh <igloo@earth.li>**20101203201558
 Ignore-this: f02d70e5b9cce50137981c6cb2b62a18
] 
[Make RelaxedLayout off by default
Ian Lynagh <igloo@earth.li>**20101202140808
 I suspect this is a vary rarely used extension to the official layout
 rule.
] 
[Fix up TcInstDcls
simonpj@microsoft.com**20101203180758
 Ignore-this: 9311aeb4ee67c799704afec90b5982d0
 
 I really don't know how this module got left out of my last
 patch, namely
   Thu Dec  2 12:35:47 GMT 2010  simonpj@microsoft.com
   * Re-jig simplifySuperClass (again)
 
 I suggest you don't pull either the patch above, or this
 one, unless you really have to.  I'm not fully confident
 that it works properly yet.  Ran out of time. Sigh.
] 
[throwTo: report the why_blocked value in the barf()
Simon Marlow <marlowsd@gmail.com>**20101203094840
 Ignore-this: 3b167c581be1c51dfe3586cc6359e1d0
] 
[handle ThreadMigrating in throwTo() (#4811)
Simon Marlow <marlowsd@gmail.com>**20101203094818
 Ignore-this: 8ef8cb7fd3b50a27f83c29968131d461
 If a throwTo targets a thread that has just been created with
 forkOnIO, then it is possible the exception strikes while the thread
 is still in the process of migrating.  throwTo() didn't handle this
 case, but it's fairly straightforward.
] 
[removeThreadFromQueue: stub out the link field before returning (#4813)
Simon Marlow <marlowsd@gmail.com>**20101202160838
 Ignore-this: 653ae17bc1120d7f4130da94665002a1
] 
[small tidyup
Simon Marlow <marlowsd@gmail.com>**20101126140620
 Ignore-this: 70b1d5ed4c81a7b29dd5980a2d84aae1
] 
[Fix a recomp bug: make classes/datatypes depend directly on DFuns (#4469)
Simon Marlow <marlowsd@gmail.com>**20101202122349
 Ignore-this: 61c765583bb1d97caa88cf9b4f45b87c
 And remove the old mechanism of recording dfun uses separately,
 because it didn't work.
 
 This wiki page describes recompilation avoidance and fingerprinting.
 I'll update it to describe the new method and what went wrong with the
 old method:
 
 http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance
] 
[make a panic message more informative and suggest -dcore-lint (see #4534)
Simon Marlow <marlowsd@gmail.com>**20101201151706
 Ignore-this: 2a10761925d6f9f52675948baa30f7a
] 
[Re-jig simplifySuperClass (again)
simonpj@microsoft.com**20101202123547
 Ignore-this: fe4062b8988258f6748ebd8fbd6515b5
 
 This fixes the current loop in T3731, and will fix other
 reported loops.  The loops show up when we are generating
 evidence for superclasses in an instance declaration.
 
 The trick is to make the "self" dictionary simplifySuperClass
 depend *explicitly* on the superclass we are currently trying
 to build.  See Note [Dependencies in self dictionaries] in TcSimplify.
 
 That in turn means that EvDFunApp needs a dependency-list, used
 when chasing dependencies in isGoodRecEv.
] 
[A little refactoring (remove redundant argument passed to isGoodRecEv)
simonpj@microsoft.com**20101202123110
 Ignore-this: e517c5c12109a230f08dafb4d1e386df
] 
[Make rebindable if-then-else a little more permissive
simonpj@microsoft.com**20101202122540
 Ignore-this: ddb552cfe307607b42d1e4baf4e3bf21
 
 See Note [Rebindable syntax for if].  Fixes Trac #4798.
 Thanks to Nils Schweinsberg <mail@n-sch.de>
] 
[Improve error message (Trac #4799)
simonpj@microsoft.com**20101202102706
 Ignore-this: d9896e4d182936de1f256c820b96a8cf
] 
[Fix a nasty bug in RULE matching: Trac #4814
simonpj@microsoft.com**20101202102618
 Ignore-this: ba058ad46a02bd2faf3a14de93fd19c6
 
 See Note [Matching lets], which explains it all in detail.
 It took me a day to think of a nice way to fix the bug,
 but I think the result is quite respectable. Subtle, though.
] 
[Rename -XPArr to -XParallelArrays
Ben Lippmeier <benl@ouroborus.net>**20101130075415
 Ignore-this: 21b37680a7f25800d1200b59ad0b6b39
] 
[FIX #1845 (unconditional relative branch out of range)
pho@cielonegro.org**20101130143014
 Ignore-this: df234bd8ad937104c455656fe3c33732
 
 Don't use mmap on powerpc-apple-darwin as mmap doesn't support
 reallocating but we need to allocate jump islands just after each
 object images. Otherwise relative branches to jump islands can fail
 due to 24-bits displacement overflow.
] 
[rts/Linker.c (loadArchive):
pho@cielonegro.org**20101130142700
 Ignore-this: bc84f9369ce5c2d289440701b7a3a2ab
 
 This routine should be aware of Mach-O misalignment of malloc'ed memory regions.
] 
[rts/Linker.c (machoGetMisalignment):
pho@cielonegro.org**20101130123355
 Ignore-this: 75425600049efd587e9873578e26392f
 
 Use fseek(3) instead of rewind(3) to move the file position indicator back to the initial position. Otherwise we can't use this function in loadArchive().
] 
[rts/Linker.c (ocFlushInstructionCache):
pho@cielonegro.org**20101130121425
 Ignore-this: 1e2c207e4b1d17387617ec5d645204b7
 
 I found this function causes a segfault when ocAllocateSymbolExtras() has allocated a separate memory region for jump islands.
] 
[Remove NewQualifiedOperators
Ian Lynagh <igloo@earth.li>**20101201181117
 The extension was rejected by Haskell', and deprecated in 7.0.
] 
[fix ref to utils/ext-core, which moved to Hackage (extcore package)
Simon Marlow <marlowsd@gmail.com>**20101201092147
 Ignore-this: 272a7daaa335ef60bcc645db70b4d68b
] 
[fix floating-point/FFI section: fenv is C99, not POSIX
Simon Marlow <marlowsd@gmail.com>**20101201092119
 Ignore-this: ce8b3edd428e4f77691dd739b5b4ae73
] 
[Fixed some 'unused vars' warnings
keller@cse.unsw.edu.au**20101130013425
 Ignore-this: 35790d443faa23b87e4ba442e62376a3
] 
[vectScalarLam handles int, float, and double now
keller@cse.unsw.edu.au**20101129231043
 Ignore-this: 6d67bdc8dd8577184040e791e6f3d0
] 
[Handling of lets, letrec and case when checking if a lambda expr needs to be vectorised
keller@cse.unsw.edu.au**20101115051225
 Ignore-this: 1db6ed63d7b3f6d093e019322b407ff7
] 
[Document the behaviour of fenv.h functions with GHC (#4391)
Simon Marlow <marlowsd@gmail.com>**20101126125336
 Ignore-this: bc4eab49428d567505a28add6fed90f1
] 
[Remove the no-ghci-lib warning in ghc-pkg
Ian Lynagh <igloo@earth.li>**20101127235805
 GHCi libs are no longer necessary, as we can use the .a or .so versions
 instead.
] 
[Add GNU-variant support to the .a parser, and other improvements/tidyups
Ian Lynagh <igloo@earth.li>**20101127223945] 
[Re-indent only
Ian Lynagh <igloo@earth.li>**20101127191646] 
[Improve linker debugging for archive files
Ian Lynagh <igloo@earth.li>**20101127190907] 
[Always enable the archive-loading code
Ian Lynagh <igloo@earth.li>**20101127173000
 If the GHCi .o lib doesn't exist, load the .a instead
] 
[Inherit the ForceSpecConstr flag in non-recursive nested bindings
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101127125025
 Ignore-this: 401391eae25cefcb4afaba2e357decc1
 
 This makes sure that join points are fully specialised in loops which are
 marked as ForceSpecConstr.
] 
[Document -ddump-rule-firings and -ddump-rule-rewrites
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101127123528
 Ignore-this: beade2efe0cd767c0ce9d4f45a3380ba
] 
[New flag -dddump-rule-rewrites
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101127122022
 Ignore-this: c0ef5b8a199fbd1ef020258d2cde85a3
 
 Now, -ddump-rule-firings only shows the names of the rules that fired (it would
 show "before" and "after" with -dverbose-core2core previously) and
 -ddump-rule-rewrites always shows the "before" and "after" bits, even without
 -dverbose-core2core.
] 
[Acutally, wild-card variables *can* have occurrences
simonpj@microsoft.com**20101126162409
 Ignore-this: 544bffed75eeccef03a1097f98524eea
 
 This patch removes the Lint test, and comments why
] 
[Tidy up the handling of wild-card binders, and make Lint check it
simonpj@microsoft.com**20101126133210
 Ignore-this: 9e0be9f7867d53046ee5b0e478a0f433
 
 See Note [WildCard binders] in SimplEnv.  Spotted by Roman.
] 
[Substitution should just substitute, not optimise
simonpj@microsoft.com**20101125172356
 Ignore-this: 657628d9b6796ceb5f915c43d56e4a06
 
 This was causing Trac #4524, by optimising
      (e |> co)  to   e
 on the LHS of a rule.  Result, the template variable
 'co' wasn't bound any more.
 
 Now that substition doesn't optimise, it seems sensible to call
 simpleOptExpr rather than substExpr when substituting in the
 RHS of rules.  Not a big deal either way.
] 
[Make SpecConstr "look through" identity coercions
simonpj@microsoft.com**20101125172138
 Ignore-this: c1cc585ed890a7702c33987e971e0af6
] 
[Comment only
simonpj@microsoft.com**20101125172011
 Ignore-this: 3c7be8791badd00dcca9610ebb8981d1
] 
[White space only
simonpj@microsoft.com**20101101080748
 Ignore-this: f7133fc6b22ae263c6672543a8534a6f
] 
[Keep a maximum of 6 spare worker threads per Capability (#4262)
Simon Marlow <marlowsd@gmail.com>**20101125135729
 Ignore-this: a020786569656bf2f3a1717b65d463bd
] 
[Unicide OtherNumber category should be allowed in identifiers (#4373)
Simon Marlow <marlowsd@gmail.com>**20101115095444
 Ignore-this: e331b6ddb17550163ee91bd283348800
] 
[vectoriser: fix warning
Ben Lippmeier <benl@ouroborus.net>**20101126044036
 Ignore-this: e1a66bb405bf2f3f56b42c3b13fd4bf3
] 
[vectoriser: fix warning
Ben Lippmeier <benl@ouroborus.net>**20101126042950
 Ignore-this: df8dd25bcfb3946c2974b13953a2f2c7
] 
[vectoriser: take class directly from the instance tycon
Ben Lippmeier <benl@ouroborus.net>**20101126042900
 Ignore-this: 626a416717a5a059f39e53f4ec95fc66
] 
[vectoriser: comments only
Ben Lippmeier <benl@ouroborus.net>**20101125073201
 Ignore-this: 8846ea8895307083bd1ebbc5d7fb1c5
] 
[vectoriser: follow changes in mkClass
Ben Lippmeier <benl@ouroborus.net>**20101125062349
 Ignore-this: d5018cc022686d4272e126ca9a12283a
] 
[vectoriser: tracing wibbles
Ben Lippmeier <benl@ouroborus.net>**20101125062332
 Ignore-this: c2024d8f03bc03bee2851f4f1c139fd5
] 
[mkDFunUnfolding wants the type of the dfun to be a PredTy
benl@ouroborus.net**20100914062939
 Ignore-this: 7aa6e6b140746184cf00355b50c83b66
] 
[vectoriser: fix conflicts
Ben Lippmeier <benl@ouroborus.net>**20101125060904
 Ignore-this: cc3decab1affada8629ca3818b76b3bf
] 
[Comments and formatting only
benl@ouroborus.net**20100914062903
 Ignore-this: b0fc25f0952cafd56cc25353936327d4
] 
[Comments and formatting to type environment vectoriser
benl@ouroborus.net**20100909080405
 Ignore-this: ab8549d53f845c9d82ed9a525fda3906
] 
[Don't mix implicit and explicit layout
Ian Lynagh <igloo@earth.li>**20101124231514] 
[Whitespace only
Ian Lynagh <igloo@earth.li>**20101124230655] 
[Separate NondecreasingIndentation out into its own extension
Ian Lynagh <igloo@earth.li>**20101124220507] 
[Add another GHC layout rule relaxation to RelaxedLayout
Ian Lynagh <igloo@earth.li>**20101124205957] 
[Remove an unused build system variable: GhcDir
Ian Lynagh <igloo@earth.li>**20101124140455] 
[Remove unused build system variable: GhcHasEditline
Ian Lynagh <igloo@earth.li>**20101124140415] 
[Remove unused variables from the build system: HBC, NHC, MKDEPENDHS
Ian Lynagh <igloo@earth.li>**20101124140052] 
[Remove references to Haskell 98
Ian Lynagh <igloo@earth.li>**20101123233536
 They are no longer right, as we have Haskell' generating new Haskell
 standards.
] 
[Tweak a configure test
Ian Lynagh <igloo@earth.li>**20101123170621] 
[Add a configure test for the visibility hidden attribute
Ian Lynagh <igloo@earth.li>**20101123170541] 
[sanity: fix places where we weren't filling fresh memory with 0xaa
Simon Marlow <marlowsd@gmail.com>**20101029092843
 Ignore-this: 2cb18f7f5afcaf33371aeffce67e218f
] 
[Just some alpha renaming
Ian Lynagh <igloo@earth.li>**20101121144455
 Ignore-this: d5e807c5470840efc199e29f7d50804c
] 
[Fix bug #3165 (:history throws irrefutable pattern failed)
pepeiborra@gmail.com**20101115223623
 Ignore-this: 73edf56e502b4d0385bc044133b27946
 
 I ran across this bug and took the time to fix it, closing
 a long time due TODO in InteractiveEval.hs
 
 Instead of looking around to find the enclosing declaration
 of a tick, this patch makes use of the information already collected during the
 coverage desugaring phase
] 
[For bindists, build ghc-pwd with stage 1
Ian Lynagh <igloo@earth.li>**20101121183520
 Ignore-this: a3b5c8b78c81ec1b6d5fbf23da346ff5
 rather then the bootstrapping compiler. This fixes problems where the
 bootstrapping compiler dynamically links against libraries not on the
 target machine.
] 
[Makefile tweak
Ian Lynagh <igloo@earth.li>**20101121183342
 Ignore-this: cd55a2819c1a5fd36da1bc7a75d2ded1
] 
[Fix a makefile include ordering sanity check
Ian Lynagh <igloo@earth.li>**20101121174916
 Ignore-this: d0bdd41c4b618944d04ecb4f54fdd0f1
] 
[Add an extension for GHC's layout-rule relaxations
Ian Lynagh <igloo@earth.li>**20101120215340
 Still TODO: Add the other relaxation (#1060) and update the alternative
 layout rule to use the extension.
] 
[Tweak the bindist configure.ac.in
Ian Lynagh <igloo@earth.li>**20101120173735] 
[configure.ac tweaks
Ian Lynagh <igloo@earth.li>**20101120170245] 
[When testing the bindist, tell it where gcc is
Ian Lynagh <igloo@earth.li>**20101120155920
 The location isn't baked into the bindist, as it may differ from
 machine to machine.
] 
[Comments only
simonpj@microsoft.com**20101119100153
 Ignore-this: 7abd5d965ea805770449d6f8dadbb921
] 
[ForceSpecConstr now forces specialisation even for arguments which aren't scrutinised
Roman Leshchinskiy <rl@cse.unsw.edu.au>**20101118212839
 Ignore-this: db45721d29a694e53746f8b76513efa4
] 
[Move the superclass generation to the canonicaliser
simonpj@microsoft.com**20101118120533
 Ignore-this: 5e0e525402a240b709f2b8104c1682b2
 
 Doing superclass generation in the canonicaliser (rather than
 TcInteract) uses less code, and is generally more efficient.
 
 See Note [Adding superclasses] in TcCanonical.
 
 Fixes Trac #4497.
] 
[Fix the generation of in-scope variables for IfaceLint check
simonpj@microsoft.com**20101118090057
 Ignore-this: bbcdba61ddf89d07fe69ca99c2017e3f
] 
[Comments only
simonpj@microsoft.com**20101118090034
 Ignore-this: fa2936d35a0f7be4e4535ea9e2b7bf7b
] 
[Omit bogus test for -XDeriveFunctor
simonpj@microsoft.com**20101118090028
 Ignore-this: a534243011809ebbb788b910961601c5
 
 It was duplicated in the case of 'deriving( Functor )'
 and wrong for 'deriving( Foldable )'
] 
[Improve error message on advice from a user
simonpj@microsoft.com**20101118085306
 Ignore-this: bd4f3858ff24e602e985288f27d536f3
 
 See Trac #4499
] 
[TAG 2010-11-18
Ian Lynagh <igloo@earth.li>**20101118011554
 Ignore-this: ccadbe7fadd1148d2ee3caa8c8821ec5
] 
Patch bundle hash:
90de31e3f8ff3ceff74acb5485b33b78febcac22
